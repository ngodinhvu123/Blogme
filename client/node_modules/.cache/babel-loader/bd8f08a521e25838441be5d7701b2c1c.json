{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Mapper from '../conversion/mapper';\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText } from '../conversion/downcasthelpers';\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\nimport ModelRange from '../model/range';\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\n\nexport default class DataController {\n  /**\n   * Creates a data controller instance.\n   *\n   * @param {module:engine/model/model~Model} model Data model.\n   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n   */\n  constructor(model, stylesProcessor) {\n    /**\n     * Data model.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model}\n     */\n    this.model = model;\n    /**\n     * Styles processor used during the conversion.\n     *\n     * @readonly\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n\n    this.stylesProcessor = stylesProcessor;\n    /**\n     * Data processor used during the conversion.\n     *\n     * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n     */\n\n    this.processor;\n    /**\n     * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and\n     * cleared directly after the data are converted. However, the mapper is defined as a class property, because\n     * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n     *\n     * @readonly\n     * @member {module:engine/conversion/mapper~Mapper}\n     */\n\n    this.mapper = new Mapper();\n    /**\n     * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n     */\n\n    this.downcastDispatcher = new DowncastDispatcher({\n      mapper: this.mapper\n    });\n    this.downcastDispatcher.on('insert:$text', insertText(), {\n      priority: 'lowest'\n    });\n    /**\n     * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n     *\n     * @readonly\n     * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n     */\n\n    this.upcastDispatcher = new UpcastDispatcher({\n      schema: model.schema\n    });\n    /**\n     * The view document used by the data controller.\n     *\n     * @readonly\n     * @member {module:engine/view/document~Document}\n     */\n\n    this.viewDocument = new ViewDocument(stylesProcessor);\n    /**\n     * The view downcast writer just for data conversion purposes, i.e. to modify\n     * the {@link #viewDocument}.\n     *\n     * @private\n     * @readonly\n     * @member {module:engine/view/downcastwriter~DowncastWriter}\n     */\n\n    this._viewWriter = new ViewDowncastWriter(this.viewDocument); // Define default converters for text and elements.\n    //\n    // Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n    // converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that\n    // element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.\n\n    this.upcastDispatcher.on('text', convertText(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('element', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.upcastDispatcher.on('documentFragment', convertToModelFragment(), {\n      priority: 'lowest'\n    });\n    this.decorate('init'); // Fire `ready` event when initialisation has completed. Such low level listener gives possibility\n    // to plug into initialisation pipeline without interrupting the initialisation flow.\n\n    this.on('init', () => {\n      this.fire('ready');\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n   * formatted by the {@link #processor data processor}.\n   *\n   * @param {Object} [options]\n   * @param {String} [options.rootName='main'] Root name.\n   * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n   * use `'none'`. In such cases exact content will be returned (for example `<p>&nbsp;</p>` for an empty editor).\n   * @returns {String} Output data.\n   */\n\n\n  get(options) {\n    const {\n      rootName = 'main',\n      trim = 'empty'\n    } = options || {};\n\n    if (!this._checkIfRootsExists([rootName])) {\n      /**\n       * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #get} like:\n       *\n       *\t\tdata.get( { rootName: 'root2' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-get-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.', this);\n    }\n\n    const root = this.model.document.getRoot(rootName);\n\n    if (trim === 'empty' && !this.model.hasContent(root, {\n      ignoreWhitespaces: true\n    })) {\n      return '';\n    }\n\n    return this.stringify(root);\n  }\n  /**\n   * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n   * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n   * Element whose content will be stringified.\n   * @returns {String} Output data.\n   */\n\n\n  stringify(modelElementOrFragment) {\n    // Model -> view.\n    const viewDocumentFragment = this.toView(modelElementOrFragment); // View -> data.\n\n    return this.processor.toData(viewDocumentFragment);\n  }\n  /**\n   * Returns the content of the given {@link module:engine/model/element~Element model element} or\n   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n   * converters attached to {@link #downcastDispatcher} to a\n   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n   * Element or document fragment whose content will be converted.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n   */\n\n\n  toView(modelElementOrFragment) {\n    const viewDocument = this.viewDocument;\n    const viewWriter = this._viewWriter; // Clear bindings so the call to this method gives correct results.\n\n    this.mapper.clearBindings(); // First, convert elements.\n\n    const modelRange = ModelRange._createIn(modelElementOrFragment);\n\n    const viewDocumentFragment = new ViewDocumentFragment(viewDocument);\n    this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment); // We have no view controller and rendering do DOM in DataController so view.change() block is not used here.\n\n    this.downcastDispatcher.convertInsert(modelRange, viewWriter);\n\n    if (!modelElementOrFragment.is('documentFragment')) {\n      // Then, if a document element is converted, convert markers.\n      // From all document markers, get those, which \"intersect\" with the converter element.\n      const markers = _getMarkersRelativeToElement(modelElementOrFragment);\n\n      for (const [name, range] of markers) {\n        this.downcastDispatcher.convertMarkerAdd(name, range, viewWriter);\n      }\n    }\n\n    return viewDocumentFragment;\n  }\n  /**\n   * Sets initial input data parsed by the {@link #processor data processor} and\n   * converted by the {@link #upcastDispatcher view-to-model converters}.\n   * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.\n   *\n   * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n   * used by e.g. collaborative editing plugin that syncs remote data on init.\n   *\n   * When data is passed as a string it is initialized on a default `main` root:\n   *\n   *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root.\n   *\n   * To initialize data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n   *\n   *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on the `main` and `title` roots.\n   *\n   * @fires init\n   * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n   * pairs to initialize data on multiple roots at once.\n   * @returns {Promise} Promise that is resolved after the data is set on the editor.\n   */\n\n\n  init(data) {\n    if (this.model.document.version) {\n      /**\n       * Cannot set initial data to not empty {@link module:engine/model/document~Document}.\n       * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,\n       * when the {@link module:engine/model/document~Document#version} is equal 0.\n       *\n       * @error datacontroller-init-document-not-empty\n       */\n      throw new CKEditorError('datacontroller-init-document-not-empty: Trying to set initial data to not empty document.', this);\n    }\n\n    let initialData = {};\n\n    if (typeof data === 'string') {\n      initialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n    } else {\n      initialData = data;\n    }\n\n    if (!this._checkIfRootsExists(Object.keys(initialData))) {\n      /**\n       * Cannot init data on a non-existing root. This error is thrown when {@link #init DataController#init() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #init} like:\n       *\n       * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-init-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.', this);\n    }\n\n    this.model.enqueueChange('transparent', writer => {\n      for (const rootName of Object.keys(initialData)) {\n        const modelRoot = this.model.document.getRoot(rootName);\n        writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);\n      }\n    });\n    return Promise.resolve();\n  }\n  /**\n   * Sets input data parsed by the {@link #processor data processor} and\n   * converted by the {@link #upcastDispatcher view-to-model converters}.\n   * This method can be used any time to replace existing editor data by the new one without clearing the\n   * {@link module:engine/model/document~Document#history document history}.\n   *\n   * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n   * the {@link #parse} method.\n   *\n   * When data is passed as a string it is set on a default `main` root:\n   *\n   *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root.\n   *\n   * To set data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n   *\n   *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots.\n   *\n   * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n   * pairs to set data on multiple roots at once.\n   */\n\n\n  set(data) {\n    let newData = {};\n\n    if (typeof data === 'string') {\n      newData.main = data; // Default root is 'main'. To set data on a different root, object should be passed.\n    } else {\n      newData = data;\n    }\n\n    if (!this._checkIfRootsExists(Object.keys(newData))) {\n      /**\n       * Cannot set data on a non-existing root. This error is thrown when {@link #set DataController#set() method}\n       * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n       * calling {@link #set} like:\n       *\n       * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n       *\n       * will throw this error.\n       *\n       * @error datacontroller-set-non-existent-root\n       */\n      throw new CKEditorError('datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.', this);\n    }\n\n    this.model.enqueueChange('transparent', writer => {\n      writer.setSelection(null);\n      writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());\n\n      for (const rootName of Object.keys(newData)) {\n        // Save to model.\n        const modelRoot = this.model.document.getRoot(rootName);\n        writer.remove(writer.createRangeIn(modelRoot));\n        writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);\n      }\n    });\n  }\n  /**\n   * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n   * attached to the {@link #upcastDispatcher}.\n   *\n   * @see #set\n   * @param {String} data Data to parse.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n   * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n   */\n\n\n  parse(data, context = '$root') {\n    // data -> view\n    const viewDocumentFragment = this.processor.toView(data); // view -> model\n\n    return this.toModel(viewDocumentFragment, context);\n  }\n  /**\n   * Returns the result of the given {@link module:engine/view/element~Element view element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n   * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n   *\n   * When marker elements were converted during the conversion process, it will be set as a document fragment's\n   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n   * Element or document fragment whose content will be converted.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n   * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n   */\n\n\n  toModel(viewElementOrFragment, context = '$root') {\n    return this.model.change(writer => {\n      return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);\n    });\n  }\n  /**\n   * Adds a style processor normalization rules.\n   *\n   * You can implement your own rules as well as use one of the available processor rules:\n   *\n   * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n   * * border: {@link module:engine/view/styles/border~addBorderRules}\n   * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n   * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n   *\n   * @param {Function} callback\n   */\n\n\n  addStyleProcessorRules(callback) {\n    callback(this.stylesProcessor);\n  }\n  /**\n   * Removes all event listeners set by the DataController.\n   */\n\n\n  destroy() {\n    this.stopListening();\n  }\n  /**\n   * Checks if all provided root names are existing editor roots.\n   *\n   * @private\n   * @param {Array.<String>} rootNames Root names to check.\n   * @returns {Boolean} Whether all provided root names are existing editor roots.\n   */\n\n\n  _checkIfRootsExists(rootNames) {\n    for (const rootName of rootNames) {\n      if (!this.model.document.getRootNames().includes(rootName)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Event fired once data initialisation has finished.\n   *\n   * @event ready\n   */\n\n  /**\n   * Event fired after {@link #init init() method} has been run. It can be {@link #listenTo listened to} to adjust/modify\n   * the initialisation flow. However, if the `init` event is stopped or prevented, the {@link #event:ready ready event}\n   * should be fired manually.\n   *\n   * The `init` event is fired by decorated {@link #init} method.\n   * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n   *\n   * @event init\n   */\n\n\n}\nmix(DataController, ObservableMixin); // Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it\n// and which markers are containing it. If the marker is intersecting with element, the intersection is returned.\n\nfunction _getMarkersRelativeToElement(element) {\n  const result = [];\n  const doc = element.root.document;\n\n  if (!doc) {\n    return [];\n  }\n\n  const elementRange = ModelRange._createIn(element);\n\n  for (const marker of doc.model.markers) {\n    const intersection = elementRange.getIntersection(marker.getRange());\n\n    if (intersection) {\n      result.push([marker.name, intersection]);\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js"],"names":["mix","ObservableMixin","CKEditorError","Mapper","DowncastDispatcher","insertText","UpcastDispatcher","convertText","convertToModelFragment","ViewDocumentFragment","ViewDocument","ViewDowncastWriter","ModelRange","DataController","constructor","model","stylesProcessor","processor","mapper","downcastDispatcher","on","priority","upcastDispatcher","schema","viewDocument","_viewWriter","decorate","fire","get","options","rootName","trim","_checkIfRootsExists","root","document","getRoot","hasContent","ignoreWhitespaces","stringify","modelElementOrFragment","viewDocumentFragment","toView","toData","viewWriter","clearBindings","modelRange","_createIn","bindElements","convertInsert","is","markers","_getMarkersRelativeToElement","name","range","convertMarkerAdd","init","data","version","initialData","main","Object","keys","enqueueChange","writer","modelRoot","insert","parse","Promise","resolve","set","newData","setSelection","removeSelectionAttribute","selection","getAttributeKeys","remove","createRangeIn","context","toModel","viewElementOrFragment","change","convert","addStyleProcessorRules","callback","destroy","stopListening","rootNames","getRootNames","includes","element","result","doc","elementRange","marker","intersection","getIntersection","getRange","push"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport Mapper from '../conversion/mapper';\n\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText } from '../conversion/downcasthelpers';\n\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\n\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\n\nimport ModelRange from '../model/range';\n\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class DataController {\n\t/**\n\t * Creates a data controller instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Data model.\n\t * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n\t */\n\tconstructor( model, stylesProcessor ) {\n\t\t/**\n\t\t * Data model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Styles processor used during the conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis.stylesProcessor = stylesProcessor;\n\n\t\t/**\n\t\t * Data processor used during the conversion.\n\t\t *\n\t\t * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n\t\t */\n\t\tthis.processor;\n\n\t\t/**\n\t\t * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and\n\t\t * cleared directly after the data are converted. However, the mapper is defined as a class property, because\n\t\t * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/mapper~Mapper}\n\t\t */\n\t\tthis.mapper = new Mapper();\n\n\t\t/**\n\t\t * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n\t\t */\n\t\tthis.downcastDispatcher = new DowncastDispatcher( {\n\t\t\tmapper: this.mapper\n\t\t} );\n\t\tthis.downcastDispatcher.on( 'insert:$text', insertText(), { priority: 'lowest' } );\n\n\t\t/**\n\t\t * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t\t */\n\t\tthis.upcastDispatcher = new UpcastDispatcher( {\n\t\t\tschema: model.schema\n\t\t} );\n\n\t\t/**\n\t\t * The view document used by the data controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document}\n\t\t */\n\t\tthis.viewDocument = new ViewDocument( stylesProcessor );\n\n\t\t/**\n\t\t * The view downcast writer just for data conversion purposes, i.e. to modify\n\t\t * the {@link #viewDocument}.\n\t\t *\n\t\t * @private\n\t\t * @readonly\n\t\t * @member {module:engine/view/downcastwriter~DowncastWriter}\n\t\t */\n\t\tthis._viewWriter = new ViewDowncastWriter( this.viewDocument );\n\n\t\t// Define default converters for text and elements.\n\t\t//\n\t\t// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n\t\t// converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that\n\t\t// element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.\n\t\tthis.upcastDispatcher.on( 'text', convertText(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'element', convertToModelFragment(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'documentFragment', convertToModelFragment(), { priority: 'lowest' } );\n\n\t\tthis.decorate( 'init' );\n\n\t\t// Fire `ready` event when initialisation has completed. Such low level listener gives possibility\n\t\t// to plug into initialisation pipeline without interrupting the initialisation flow.\n\t\tthis.on( 'init', () => {\n\t\t\tthis.fire( 'ready' );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n\t * formatted by the {@link #processor data processor}.\n\t *\n\t * @param {Object} [options]\n\t * @param {String} [options.rootName='main'] Root name.\n\t * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n\t * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n\t * use `'none'`. In such cases exact content will be returned (for example `<p>&nbsp;</p>` for an empty editor).\n\t * @returns {String} Output data.\n\t */\n\tget( options ) {\n\t\tconst { rootName = 'main', trim = 'empty' } = options || {};\n\n\t\tif ( !this._checkIfRootsExists( [ rootName ] ) ) {\n\t\t\t/**\n\t\t\t * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #get} like:\n\t\t\t *\n\t\t\t *\t\tdata.get( { rootName: 'root2' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-get-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.', this );\n\t\t}\n\n\t\tconst root = this.model.document.getRoot( rootName );\n\n\t\tif ( trim === 'empty' && !this.model.hasContent( root, { ignoreWhitespaces: true } ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.stringify( root );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n\t * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element whose content will be stringified.\n\t * @returns {String} Output data.\n\t */\n\tstringify( modelElementOrFragment ) {\n\t\t// Model -> view.\n\t\tconst viewDocumentFragment = this.toView( modelElementOrFragment );\n\n\t\t// View -> data.\n\t\treturn this.processor.toData( viewDocumentFragment );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n\t * converters attached to {@link #downcastDispatcher} to a\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n\t */\n\ttoView( modelElementOrFragment ) {\n\t\tconst viewDocument = this.viewDocument;\n\t\tconst viewWriter = this._viewWriter;\n\n\t\t// Clear bindings so the call to this method gives correct results.\n\t\tthis.mapper.clearBindings();\n\n\t\t// First, convert elements.\n\t\tconst modelRange = ModelRange._createIn( modelElementOrFragment );\n\t\tconst viewDocumentFragment = new ViewDocumentFragment( viewDocument );\n\n\t\tthis.mapper.bindElements( modelElementOrFragment, viewDocumentFragment );\n\n\t\t// We have no view controller and rendering do DOM in DataController so view.change() block is not used here.\n\t\tthis.downcastDispatcher.convertInsert( modelRange, viewWriter );\n\n\t\tif ( !modelElementOrFragment.is( 'documentFragment' ) ) {\n\t\t\t// Then, if a document element is converted, convert markers.\n\t\t\t// From all document markers, get those, which \"intersect\" with the converter element.\n\t\t\tconst markers = _getMarkersRelativeToElement( modelElementOrFragment );\n\n\t\t\tfor ( const [ name, range ] of markers ) {\n\t\t\t\tthis.downcastDispatcher.convertMarkerAdd( name, range, viewWriter );\n\t\t\t}\n\t\t}\n\n\t\treturn viewDocumentFragment;\n\t}\n\n\t/**\n\t * Sets initial input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.\n\t *\n\t * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n\t * used by e.g. collaborative editing plugin that syncs remote data on init.\n\t *\n\t * When data is passed as a string it is initialized on a default `main` root:\n\t *\n\t *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root.\n\t *\n\t * To initialize data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on the `main` and `title` roots.\n\t *\n\t * @fires init\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to initialize data on multiple roots at once.\n\t * @returns {Promise} Promise that is resolved after the data is set on the editor.\n\t */\n\tinit( data ) {\n\t\tif ( this.model.document.version ) {\n\t\t\t/**\n\t\t\t * Cannot set initial data to not empty {@link module:engine/model/document~Document}.\n\t\t\t * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,\n\t\t\t * when the {@link module:engine/model/document~Document#version} is equal 0.\n\t\t\t *\n\t\t\t * @error datacontroller-init-document-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-document-not-empty: Trying to set initial data to not empty document.', this );\n\t\t}\n\n\t\tlet initialData = {};\n\t\tif ( typeof data === 'string' ) {\n\t\t\tinitialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n\t\t} else {\n\t\t\tinitialData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( initialData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot init data on a non-existing root. This error is thrown when {@link #init DataController#init() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #init} like:\n\t\t\t *\n\t\t\t * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-init-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\tfor ( const rootName of Object.keys( initialData ) ) {\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\t\t\t\twriter.insert( this.parse( initialData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Sets input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * This method can be used any time to replace existing editor data by the new one without clearing the\n\t * {@link module:engine/model/document~Document#history document history}.\n\t *\n\t * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n\t * the {@link #parse} method.\n\t *\n\t * When data is passed as a string it is set on a default `main` root:\n\t *\n\t *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root.\n\t *\n\t * To set data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots.\n\t *\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to set data on multiple roots at once.\n\t */\n\tset( data ) {\n\t\tlet newData = {};\n\n\t\tif ( typeof data === 'string' ) {\n\t\t\tnewData.main = data; // Default root is 'main'. To set data on a different root, object should be passed.\n\t\t} else {\n\t\t\tnewData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( newData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot set data on a non-existing root. This error is thrown when {@link #set DataController#set() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #set} like:\n\t\t\t *\n\t\t\t * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-set-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\twriter.setSelection( null );\n\t\t\twriter.removeSelectionAttribute( this.model.document.selection.getAttributeKeys() );\n\n\t\t\tfor ( const rootName of Object.keys( newData ) ) {\n\t\t\t\t// Save to model.\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\n\t\t\t\twriter.remove( writer.createRangeIn( modelRoot ) );\n\t\t\t\twriter.insert( this.parse( newData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n\t * attached to the {@link #upcastDispatcher}.\n\t *\n\t * @see #set\n\t * @param {String} data Data to parse.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n\t */\n\tparse( data, context = '$root' ) {\n\t\t// data -> view\n\t\tconst viewDocumentFragment = this.processor.toView( data );\n\n\t\t// view -> model\n\t\treturn this.toModel( viewDocumentFragment, context );\n\t}\n\n\t/**\n\t * Returns the result of the given {@link module:engine/view/element~Element view element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n\t * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n\t *\n\t * When marker elements were converted during the conversion process, it will be set as a document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n\t */\n\ttoModel( viewElementOrFragment, context = '$root' ) {\n\t\treturn this.model.change( writer => {\n\t\t\treturn this.upcastDispatcher.convert( viewElementOrFragment, writer, context );\n\t\t} );\n\t}\n\n\t/**\n\t * Adds a style processor normalization rules.\n\t *\n\t * You can implement your own rules as well as use one of the available processor rules:\n\t *\n\t * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n\t * * border: {@link module:engine/view/styles/border~addBorderRules}\n\t * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n\t * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n\t *\n\t * @param {Function} callback\n\t */\n\taddStyleProcessorRules( callback ) {\n\t\tcallback( this.stylesProcessor );\n\t}\n\n\t/**\n\t * Removes all event listeners set by the DataController.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Checks if all provided root names are existing editor roots.\n\t *\n\t * @private\n\t * @param {Array.<String>} rootNames Root names to check.\n\t * @returns {Boolean} Whether all provided root names are existing editor roots.\n\t */\n\t_checkIfRootsExists( rootNames ) {\n\t\tfor ( const rootName of rootNames ) {\n\t\t\tif ( !this.model.document.getRootNames().includes( rootName ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Event fired once data initialisation has finished.\n\t *\n\t * @event ready\n\t */\n\n\t/**\n\t * Event fired after {@link #init init() method} has been run. It can be {@link #listenTo listened to} to adjust/modify\n\t * the initialisation flow. However, if the `init` event is stopped or prevented, the {@link #event:ready ready event}\n\t * should be fired manually.\n\t *\n\t * The `init` event is fired by decorated {@link #init} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event init\n\t */\n}\n\nmix( DataController, ObservableMixin );\n\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it\n// and which markers are containing it. If the marker is intersecting with element, the intersection is returned.\nfunction _getMarkersRelativeToElement( element ) {\n\tconst result = [];\n\tconst doc = element.root.document;\n\n\tif ( !doc ) {\n\t\treturn [];\n\t}\n\n\tconst elementRange = ModelRange._createIn( element );\n\n\tfor ( const marker of doc.model.markers ) {\n\t\tconst intersection = elementRange.getIntersection( marker.getRange() );\n\n\t\tif ( intersection ) {\n\t\t\tresult.push( [ marker.name, intersection ] );\n\t\t}\n\t}\n\n\treturn result;\n}\n"]},"metadata":{},"sourceType":"module"}