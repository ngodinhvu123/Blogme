{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/fakeselectionobserver\n */\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport { debounce } from 'lodash-es';\n/**\n * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens\n * on {@link module:engine/view/document~Document#event:keydown keydown} events and handles moving fake view selection to the correct place\n * if arrow keys are pressed.\n * Fires {@link module:engine/view/document~Document#event:selectionChange selectionChange event} simulating natural behaviour of\n * {@link module:engine/view/observer/selectionobserver~SelectionObserver SelectionObserver}.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\n\nexport default class FakeSelectionObserver extends Observer {\n  /**\n   * Creates new FakeSelectionObserver instance.\n   *\n   * @param {module:engine/view/view~View} view\n   */\n  constructor(view) {\n    super(view);\n    /**\n     * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n     *\n     * @private\n     * @param {Object} data Selection change data.\n     * @method #_fireSelectionChangeDoneDebounced\n     */\n\n    this._fireSelectionChangeDoneDebounced = debounce(data => this.document.fire('selectionChangeDone', data), 200);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  observe() {\n    const document = this.document;\n    document.on('keydown', (eventInfo, data) => {\n      const selection = document.selection;\n\n      if (selection.isFake && _isArrowKeyCode(data.keyCode) && this.isEnabled) {\n        // Prevents default key down handling - no selection change will occur.\n        data.preventDefault();\n\n        this._handleSelectionMove(data.keyCode);\n      }\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    super.destroy();\n\n    this._fireSelectionChangeDoneDebounced.cancel();\n  }\n  /**\n   * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be\n   * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.\n   *\n   * This method fires {@link module:engine/view/document~Document#event:selectionChange} and\n   * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of\n   * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n   *\n   * @private\n   * @param {Number} keyCode\n   * @fires module:engine/view/document~Document#event:selectionChange\n   * @fires module:engine/view/document~Document#event:selectionChangeDone\n   */\n\n\n  _handleSelectionMove(keyCode) {\n    const selection = this.document.selection;\n    const newSelection = new ViewSelection(selection.getRanges(), {\n      backward: selection.isBackward,\n      fake: false\n    }); // Left or up arrow pressed - move selection to start.\n\n    if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {\n      newSelection.setTo(newSelection.getFirstPosition());\n    } // Right or down arrow pressed - move selection to end.\n\n\n    if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {\n      newSelection.setTo(newSelection.getLastPosition());\n    }\n\n    const data = {\n      oldSelection: selection,\n      newSelection,\n      domSelection: null\n    }; // Fire dummy selection change event.\n\n    this.document.fire('selectionChange', data); // Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n    // This function is debounced what means that `selectionChangeDone` event will be fired only when\n    // defined int the function time will elapse since the last time the function was called.\n    // So `selectionChangeDone` will be fired when selection will stop changing.\n\n    this._fireSelectionChangeDoneDebounced(data);\n  }\n\n} // Checks if one of the arrow keys is pressed.\n//\n// @private\n// @param {Number} keyCode\n// @returns {Boolean}\n\nfunction _isArrowKeyCode(keyCode) {\n  return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/view/observer/fakeselectionobserver.js"],"names":["Observer","ViewSelection","keyCodes","debounce","FakeSelectionObserver","constructor","view","_fireSelectionChangeDoneDebounced","data","document","fire","observe","on","eventInfo","selection","isFake","_isArrowKeyCode","keyCode","isEnabled","preventDefault","_handleSelectionMove","priority","destroy","cancel","newSelection","getRanges","backward","isBackward","fake","arrowleft","arrowup","setTo","getFirstPosition","arrowright","arrowdown","getLastPosition","oldSelection","domSelection"],"mappings":"AAAA;;;;;AAKA;;;AAIA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,aAAP,MAA0B,cAA1B;AACA,SAASC,QAAT,QAAyB,wCAAzB;AACA,SAASC,QAAT,QAAyB,WAAzB;AAEA;;;;;;;;;;AASA,eAAe,MAAMC,qBAAN,SAAoCJ,QAApC,CAA6C;AAC3D;;;;;AAKAK,EAAAA,WAAW,CAAEC,IAAF,EAAS;AACnB,UAAOA,IAAP;AAEA;;;;;;;;AAOA,SAAKC,iCAAL,GAAyCJ,QAAQ,CAAEK,IAAI,IAAI,KAAKC,QAAL,CAAcC,IAAd,CAAoB,qBAApB,EAA2CF,IAA3C,CAAV,EAA6D,GAA7D,CAAjD;AACA;AAED;;;;;AAGAG,EAAAA,OAAO,GAAG;AACT,UAAMF,QAAQ,GAAG,KAAKA,QAAtB;AAEAA,IAAAA,QAAQ,CAACG,EAAT,CAAa,SAAb,EAAwB,CAAEC,SAAF,EAAaL,IAAb,KAAuB;AAC9C,YAAMM,SAAS,GAAGL,QAAQ,CAACK,SAA3B;;AAEA,UAAKA,SAAS,CAACC,MAAV,IAAoBC,eAAe,CAAER,IAAI,CAACS,OAAP,CAAnC,IAAuD,KAAKC,SAAjE,EAA6E;AAC5E;AACAV,QAAAA,IAAI,CAACW,cAAL;;AAEA,aAAKC,oBAAL,CAA2BZ,IAAI,CAACS,OAAhC;AACA;AACD,KATD,EASG;AAAEI,MAAAA,QAAQ,EAAE;AAAZ,KATH;AAUA;AAED;;;;;AAGAC,EAAAA,OAAO,GAAG;AACT,UAAMA,OAAN;;AAEA,SAAKf,iCAAL,CAAuCgB,MAAvC;AACA;AAED;;;;;;;;;;;;;;;AAaAH,EAAAA,oBAAoB,CAAEH,OAAF,EAAY;AAC/B,UAAMH,SAAS,GAAG,KAAKL,QAAL,CAAcK,SAAhC;AACA,UAAMU,YAAY,GAAG,IAAIvB,aAAJ,CAAmBa,SAAS,CAACW,SAAV,EAAnB,EAA0C;AAAEC,MAAAA,QAAQ,EAAEZ,SAAS,CAACa,UAAtB;AAAkCC,MAAAA,IAAI,EAAE;AAAxC,KAA1C,CAArB,CAF+B,CAI/B;;AACA,QAAKX,OAAO,IAAIf,QAAQ,CAAC2B,SAApB,IAAiCZ,OAAO,IAAIf,QAAQ,CAAC4B,OAA1D,EAAoE;AACnEN,MAAAA,YAAY,CAACO,KAAb,CAAoBP,YAAY,CAACQ,gBAAb,EAApB;AACA,KAP8B,CAS/B;;;AACA,QAAKf,OAAO,IAAIf,QAAQ,CAAC+B,UAApB,IAAkChB,OAAO,IAAIf,QAAQ,CAACgC,SAA3D,EAAuE;AACtEV,MAAAA,YAAY,CAACO,KAAb,CAAoBP,YAAY,CAACW,eAAb,EAApB;AACA;;AAED,UAAM3B,IAAI,GAAG;AACZ4B,MAAAA,YAAY,EAAEtB,SADF;AAEZU,MAAAA,YAFY;AAGZa,MAAAA,YAAY,EAAE;AAHF,KAAb,CAd+B,CAoB/B;;AACA,SAAK5B,QAAL,CAAcC,IAAd,CAAoB,iBAApB,EAAuCF,IAAvC,EArB+B,CAuB/B;AACA;AACA;AACA;;AACA,SAAKD,iCAAL,CAAwCC,IAAxC;AACA;;AAvF0D,C,CA0F5D;AACA;AACA;AACA;AACA;;AACA,SAASQ,eAAT,CAA0BC,OAA1B,EAAoC;AACnC,SAAOA,OAAO,IAAIf,QAAQ,CAAC+B,UAApB,IACNhB,OAAO,IAAIf,QAAQ,CAAC2B,SADd,IAENZ,OAAO,IAAIf,QAAQ,CAAC4B,OAFd,IAGNb,OAAO,IAAIf,QAAQ,CAACgC,SAHrB;AAIA","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/observer/fakeselectionobserver\n */\n\nimport Observer from './observer';\nimport ViewSelection from '../selection';\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport { debounce } from 'lodash-es';\n\n/**\n * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens\n * on {@link module:engine/view/document~Document#event:keydown keydown} events and handles moving fake view selection to the correct place\n * if arrow keys are pressed.\n * Fires {@link module:engine/view/document~Document#event:selectionChange selectionChange event} simulating natural behaviour of\n * {@link module:engine/view/observer/selectionobserver~SelectionObserver SelectionObserver}.\n *\n * @extends module:engine/view/observer/observer~Observer\n */\nexport default class FakeSelectionObserver extends Observer {\n\t/**\n\t * Creates new FakeSelectionObserver instance.\n\t *\n\t * @param {module:engine/view/view~View} view\n\t */\n\tconstructor( view ) {\n\t\tsuper( view );\n\n\t\t/**\n\t\t * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.\n\t\t *\n\t\t * @private\n\t\t * @param {Object} data Selection change data.\n\t\t * @method #_fireSelectionChangeDoneDebounced\n\t\t */\n\t\tthis._fireSelectionChangeDoneDebounced = debounce( data => this.document.fire( 'selectionChangeDone', data ), 200 );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tobserve() {\n\t\tconst document = this.document;\n\n\t\tdocument.on( 'keydown', ( eventInfo, data ) => {\n\t\t\tconst selection = document.selection;\n\n\t\t\tif ( selection.isFake && _isArrowKeyCode( data.keyCode ) && this.isEnabled ) {\n\t\t\t\t// Prevents default key down handling - no selection change will occur.\n\t\t\t\tdata.preventDefault();\n\n\t\t\t\tthis._handleSelectionMove( data.keyCode );\n\t\t\t}\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._fireSelectionChangeDoneDebounced.cancel();\n\t}\n\n\t/**\n\t * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be\n\t * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.\n\t *\n\t * This method fires {@link module:engine/view/document~Document#event:selectionChange} and\n\t * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of\n\t * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.\n\t *\n\t * @private\n\t * @param {Number} keyCode\n\t * @fires module:engine/view/document~Document#event:selectionChange\n\t * @fires module:engine/view/document~Document#event:selectionChangeDone\n\t */\n\t_handleSelectionMove( keyCode ) {\n\t\tconst selection = this.document.selection;\n\t\tconst newSelection = new ViewSelection( selection.getRanges(), { backward: selection.isBackward, fake: false } );\n\n\t\t// Left or up arrow pressed - move selection to start.\n\t\tif ( keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup ) {\n\t\t\tnewSelection.setTo( newSelection.getFirstPosition() );\n\t\t}\n\n\t\t// Right or down arrow pressed - move selection to end.\n\t\tif ( keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown ) {\n\t\t\tnewSelection.setTo( newSelection.getLastPosition() );\n\t\t}\n\n\t\tconst data = {\n\t\t\toldSelection: selection,\n\t\t\tnewSelection,\n\t\t\tdomSelection: null\n\t\t};\n\n\t\t// Fire dummy selection change event.\n\t\tthis.document.fire( 'selectionChange', data );\n\n\t\t// Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.\n\t\t// This function is debounced what means that `selectionChangeDone` event will be fired only when\n\t\t// defined int the function time will elapse since the last time the function was called.\n\t\t// So `selectionChangeDone` will be fired when selection will stop changing.\n\t\tthis._fireSelectionChangeDoneDebounced( data );\n\t}\n}\n\n// Checks if one of the arrow keys is pressed.\n//\n// @private\n// @param {Number} keyCode\n// @returns {Boolean}\nfunction _isArrowKeyCode( keyCode ) {\n\treturn keyCode == keyCodes.arrowright ||\n\t\tkeyCode == keyCodes.arrowleft ||\n\t\tkeyCode == keyCodes.arrowup ||\n\t\tkeyCode == keyCodes.arrowdown;\n}\n\n"]},"metadata":{},"sourceType":"module"}