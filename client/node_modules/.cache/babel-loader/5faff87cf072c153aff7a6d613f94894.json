{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/downcastwriter\n */\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\n\nexport default class DowncastWriter {\n  /**\n   * @param {module:engine/view/document~Document} document The view document instance.\n   */\n  constructor(document) {\n    /**\n     * The view document instance in which this writer operates.\n     *\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n     * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n     *\n     * @private\n     * @type {Map.<String,Set>}\n     */\n\n    this._cloneGroups = new Map();\n  }\n  /**\n   * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n   * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n   *\n   * Usage:\n   *\n   *\t\t// Sets selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets backward selection to the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to given ranges.\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n   *\t\twriter.setSelection( range );\n   *\n   *\t\t// Sets selection to the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\twriter.setSelection( otherSelection );\n   *\n   * \t\t// Sets collapsed selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\twriter.setSelection( position );\n   *\n   * \t\t// Sets collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'p' );\n   *\t\twriter.setSelection( paragraph, offset );\n   *\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n  \t * that element and ends after the last child of that element.\n   *\n   * \t\twriter.setSelection( paragraph, 'in' );\n   *\n   * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n   *\n   *\t\twriter.setSelection( paragraph, 'on' );\n   *\n   * \t\t// Removes all ranges.\n   *\t\twriter.setSelection( null );\n   *\n   * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Sets selection as backward.\n   *\t\twriter.setSelection( range, { backward: true } );\n   *\n   *\t\t// Sets selection as fake.\n   *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * \t\t// represented in other way, for example by applying proper CSS class.\n   *\t\twriter.setSelection( range, { fake: true } );\n   *\n   * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * \t\t// (and be  properly handled by screen readers).\n   *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   */\n\n\n  setSelection(selectable, placeOrOffset, options) {\n    this.document.selection._setTo(selectable, placeOrOffset, options);\n  }\n  /**\n   * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n   *\n   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n   * parameters.\n   *\n   * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   */\n\n\n  setSelectionFocus(itemOrPosition, offset) {\n    this.document.selection._setFocus(itemOrPosition, offset);\n  }\n  /**\n   * Creates a new {@link module:engine/view/text~Text text node}.\n   *\n   *\t\twriter.createText( 'foo' );\n   *\n   * @param {String} data The text's data.\n   * @returns {module:engine/view/text~Text} The created text node.\n   */\n\n\n  createText(data) {\n    return new Text(this.document, data);\n  }\n  /**\n   * Creates new {@link module:engine/view/attributeelement~AttributeElement}.\n   *\n   *\t\twriter.createAttributeElement( 'strong' );\n   *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n   *\n   *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n   *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n   *\n   *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n   *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Element's attributes.\n   * @param {Object} [options] Element's options.\n   * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n   * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n   */\n\n\n  createAttributeElement(name, attributes, options = {}) {\n    const attributeElement = new AttributeElement(this.document, name, attributes);\n\n    if (options.priority) {\n      attributeElement._priority = options.priority;\n    }\n\n    if (options.id) {\n      attributeElement._id = options.id;\n    }\n\n    return attributeElement;\n  }\n  /**\n   * Creates new {@link module:engine/view/containerelement~ContainerElement}.\n   *\n   *\t\twriter.createContainerElement( 'p' );\n   *\n   *\t\t// Create element with custom attributes.\n   *\t\twriter.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );\n   *\n   *\t\t// Create element with custom styles.\n   *\t\twriter.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );\n   *\n   *\t\t// Create element with custom classes.\n   *\t\twriter.createContainerElement( 'p', { class: 'foo bar baz' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n   */\n\n\n  createContainerElement(name, attributes) {\n    return new ContainerElement(this.document, name, attributes);\n  }\n  /**\n   * Creates new {@link module:engine/view/editableelement~EditableElement}.\n   *\n   *\t\twriter.createEditableElement( 'div' );\n   *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @returns {module:engine/view/editableelement~EditableElement} Created element.\n   */\n\n\n  createEditableElement(name, attributes) {\n    const editableElement = new EditableElement(this.document, name, attributes);\n    editableElement._document = this.document;\n    return editableElement;\n  }\n  /**\n   * Creates new {@link module:engine/view/emptyelement~EmptyElement}.\n   *\n   *\t\twriter.createEmptyElement( 'img' );\n   *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n   */\n\n\n  createEmptyElement(name, attributes) {\n    return new EmptyElement(this.document, name, attributes);\n  }\n  /**\n   * Creates new {@link module:engine/view/uielement~UIElement}.\n   *\n   *\t\twriter.createUIElement( 'span' );\n   *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n   *\n   * Custom render function can be provided as third parameter:\n   *\n   *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n   *\t\t\tconst domElement = this.toDomElement( domDocument );\n   *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n   *\n   *\t\t\treturn domElement;\n   *\t\t} );\n   *\n   * @param {String} name Name of the element.\n   * @param {Object} [attributes] Elements attributes.\n   * @param {Function} [renderFunction] Custom render function.\n   * @returns {module:engine/view/uielement~UIElement} Created element.\n   */\n\n\n  createUIElement(name, attributes, renderFunction) {\n    const uiElement = new UIElement(this.document, name, attributes);\n\n    if (renderFunction) {\n      uiElement.render = renderFunction;\n    }\n\n    return uiElement;\n  }\n  /**\n   * Adds or overwrite element's attribute with a specified key and value.\n   *\n   *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n   *\n   * @param {String} key Attribute key.\n   * @param {String} value Attribute value.\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  setAttribute(key, value, element) {\n    element._setAttribute(key, value);\n  }\n  /**\n   * Removes attribute from the element.\n   *\n   *\t\twriter.removeAttribute( 'href', linkElement );\n   *\n   * @param {String} key Attribute key.\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  removeAttribute(key, element) {\n    element._removeAttribute(key);\n  }\n  /**\n   * Adds specified class to the element.\n   *\n   *\t\twriter.addClass( 'foo', linkElement );\n   *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n   *\n   * @param {Array.<String>|String} className\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  addClass(className, element) {\n    element._addClass(className);\n  }\n  /**\n   * Removes specified class from the element.\n   *\n   *\t\twriter.removeClass( 'foo', linkElement );\n   *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n   *\n   * @param {Array.<String>|String} className\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  removeClass(className, element) {\n    element._removeClass(className);\n  }\n  /**\n   * Adds style to the element.\n   *\n   *\t\twriter.setStyle( 'color', 'red', element );\n   *\t\twriter.setStyle( {\n   *\t\t\tcolor: 'red',\n   *\t\t\tposition: 'fixed'\n   *\t\t}, element );\n   *\n   * **Note**: The passed style can be normalized if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n   *\n   * @param {String|Object} property Property name or object with key - value pairs.\n   * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n   * @param {module:engine/view/element~Element} element Element to set styles on.\n   */\n\n\n  setStyle(property, value, element) {\n    if (isPlainObject(property) && element === undefined) {\n      element = value;\n    }\n\n    element._setStyle(property, value);\n  }\n  /**\n   * Removes specified style from the element.\n   *\n   *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n   *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n   *\n   * **Note**: This method can work with normalized style names if\n   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n   *\n   * @param {Array.<String>|String} property\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  removeStyle(property, element) {\n    element._removeStyle(property);\n  }\n  /**\n   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n   * so they can be used to add special data to elements.\n   *\n   * @param {String|Symbol} key\n   * @param {*} value\n   * @param {module:engine/view/element~Element} element\n   */\n\n\n  setCustomProperty(key, value, element) {\n    element._setCustomProperty(key, value);\n  }\n  /**\n   * Removes a custom property stored under the given key.\n   *\n   * @param {String|Symbol} key\n   * @param {module:engine/view/element~Element} element\n   * @returns {Boolean} Returns true if property was removed.\n   */\n\n\n  removeCustomProperty(key, element) {\n    return element._removeCustomProperty(key);\n  }\n  /**\n   * Breaks attribute nodes at provided position or at boundaries of provided range. It breaks attribute elements inside\n   * up to a container element.\n   *\n   * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:\n   *\n   *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n   *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n   *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n   *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n   *\n   * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n   *\n   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n   * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container`\n   * when {@link module:engine/view/range~Range#start start}\n   * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element`\n   * when trying to break attributes\n   * inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element`\n   * when trying to break attributes\n   * inside {@link module:engine/view/uielement~UIElement UIElement}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n   * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange Position where\n   * to break attribute elements.\n   * @returns {module:engine/view/position~Position|module:engine/view/range~Range} New position or range, after breaking the attribute\n   * elements.\n   */\n\n\n  breakAttributes(positionOrRange) {\n    if (positionOrRange instanceof Position) {\n      return this._breakAttributes(positionOrRange);\n    } else {\n      return this._breakAttributesRange(positionOrRange);\n    }\n  }\n  /**\n   * Breaks {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position. Position\n   * has to be directly inside container element and cannot be in root. Does not break if position is at the beginning\n   * or at the end of it's parent element.\n   *\n   *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n   *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n   *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n   *\t\t<p>foobar^</p> -> <p>foobar</p>^\n   *\n   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n   * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n   * @param {module:engine/view/position~Position} position Position where to break element.\n   * @returns {module:engine/view/position~Position} Position between broken elements. If element has not been broken,\n   * the returned position is placed either before it or after it.\n   */\n\n\n  breakContainer(position) {\n    const element = position.parent;\n\n    if (!element.is('containerElement')) {\n      /**\n       * Trying to break an element which is not a container element.\n       *\n       * @error view-writer-break-non-container-element\n       */\n      throw new CKEditorError('view-writer-break-non-container-element: Trying to break an element which is not a container element.', this.document);\n    }\n\n    if (!element.parent) {\n      /**\n       * Trying to break root element.\n       *\n       * @error view-writer-break-root\n       */\n      throw new CKEditorError('view-writer-break-root: Trying to break root element.', this.document);\n    }\n\n    if (position.isAtStart) {\n      return Position._createBefore(element);\n    } else if (!position.isAtEnd) {\n      const newElement = element._clone(false);\n\n      this.insert(Position._createAfter(element), newElement);\n      const sourceRange = new Range(position, Position._createAt(element, 'end'));\n      const targetPosition = new Position(newElement, 0);\n      this.move(sourceRange, targetPosition);\n    }\n\n    return Position._createAfter(element);\n  }\n  /**\n   * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n   * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n   *\n   * In following examples `<p>` is a container and `<b>` is an attribute element:\n   *\n   *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n   *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n   *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n   *\n   * It will also take care about empty attributes when merging:\n   *\n   *\t\t<p><b>[]</b></p> -> <p>[]</p>\n   *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n   *\n   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n   * @param {module:engine/view/position~Position} position Merge position.\n   * @returns {module:engine/view/position~Position} Position after merge.\n   */\n\n\n  mergeAttributes(position) {\n    const positionOffset = position.offset;\n    const positionParent = position.parent; // When inside text node - nothing to merge.\n\n    if (positionParent.is('text')) {\n      return position;\n    } // When inside empty attribute - remove it.\n\n\n    if (positionParent.is('attributeElement') && positionParent.childCount === 0) {\n      const parent = positionParent.parent;\n      const offset = positionParent.index;\n\n      positionParent._remove();\n\n      this._removeFromClonedElementsGroup(positionParent);\n\n      return this.mergeAttributes(new Position(parent, offset));\n    }\n\n    const nodeBefore = positionParent.getChild(positionOffset - 1);\n    const nodeAfter = positionParent.getChild(positionOffset); // Position should be placed between two nodes.\n\n    if (!nodeBefore || !nodeAfter) {\n      return position;\n    } // When position is between two text nodes.\n\n\n    if (nodeBefore.is('text') && nodeAfter.is('text')) {\n      return mergeTextNodes(nodeBefore, nodeAfter);\n    } // When position is between two same attribute elements.\n    else if (nodeBefore.is('attributeElement') && nodeAfter.is('attributeElement') && nodeBefore.isSimilar(nodeAfter)) {\n        // Move all children nodes from node placed after selection and remove that node.\n        const count = nodeBefore.childCount;\n\n        nodeBefore._appendChild(nodeAfter.getChildren());\n\n        nodeAfter._remove();\n\n        this._removeFromClonedElementsGroup(nodeAfter); // New position is located inside the first node, before new nodes.\n        // Call this method recursively to merge again if needed.\n\n\n        return this.mergeAttributes(new Position(nodeBefore, count));\n      }\n\n    return position;\n  }\n  /**\n   * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n   * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n   *\n   *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n   *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n   *\n   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n   *\n   * @see module:engine/view/attributeelement~AttributeElement\n   * @see module:engine/view/containerelement~ContainerElement\n   * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n   * @param {module:engine/view/position~Position} position Merge position.\n   * @returns {module:engine/view/position~Position} Position after merge.\n   */\n\n\n  mergeContainers(position) {\n    const prev = position.nodeBefore;\n    const next = position.nodeAfter;\n\n    if (!prev || !next || !prev.is('containerElement') || !next.is('containerElement')) {\n      /**\n       * Element before and after given position cannot be merged.\n       *\n       * @error view-writer-merge-containers-invalid-position\n       */\n      throw new CKEditorError('view-writer-merge-containers-invalid-position: ' + 'Element before and after given position cannot be merged.', this.document);\n    }\n\n    const lastChild = prev.getChild(prev.childCount - 1);\n    const newPosition = lastChild instanceof Text ? Position._createAt(lastChild, 'end') : Position._createAt(prev, 'end');\n    this.move(Range._createIn(next), Position._createAt(prev, 'end'));\n    this.remove(Range._createOn(next));\n    return newPosition;\n  }\n  /**\n   * Insert node or nodes at specified position. Takes care about breaking attributes before insertion\n   * and merging them afterwards.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n   * contains instances that are not {@link module:engine/view/text~Text Texts},\n   * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n   * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n   * {@link module:engine/view/emptyelement~EmptyElement EmptyElements} or\n   * {@link module:engine/view/uielement~UIElement UIElements}.\n   *\n   * @param {module:engine/view/position~Position} position Insertion position.\n   * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n   * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n   * module:engine/view/uielement~UIElement|Iterable.<module:engine/view/text~Text|\n   * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n   * module:engine/view/emptyelement~EmptyElement|module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n   * @returns {module:engine/view/range~Range} Range around inserted nodes.\n   */\n\n\n  insert(position, nodes) {\n    nodes = isIterable(nodes) ? [...nodes] : [nodes]; // Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\n    validateNodesToInsert(nodes, this.document);\n    const container = getParentContainer(position);\n\n    if (!container) {\n      /**\n       * Position's parent container cannot be found.\n       *\n       * @error view-writer-invalid-position-container\n       */\n      throw new CKEditorError('view-writer-invalid-position-container', this.document);\n    }\n\n    const insertionPosition = this._breakAttributes(position, true);\n\n    const length = container._insertChild(insertionPosition.offset, nodes);\n\n    for (const node of nodes) {\n      this._addToClonedElementsGroup(node);\n    }\n\n    const endPosition = insertionPosition.getShiftedBy(length);\n    const start = this.mergeAttributes(insertionPosition); // When no nodes were inserted - return collapsed range.\n\n    if (length === 0) {\n      return new Range(start, start);\n    } else {\n      // If start position was merged - move end position.\n      if (!start.isEqual(insertionPosition)) {\n        endPosition.offset--;\n      }\n\n      const end = this.mergeAttributes(endPosition);\n      return new Range(start, end);\n    }\n  }\n  /**\n   * Removes provided range from the container.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n   * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n   * to a collapsed range showing the new position.\n   * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n   */\n\n\n  remove(rangeOrItem) {\n    const range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn(rangeOrItem);\n    validateRangeContainer(range, this.document); // If range is collapsed - nothing to remove.\n\n    if (range.isCollapsed) {\n      return new DocumentFragment(this.document);\n    } // Break attributes at range start and end.\n\n\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n\n    const parentContainer = breakStart.parent;\n    const count = breakEnd.offset - breakStart.offset; // Remove nodes in range.\n\n    const removed = parentContainer._removeChildren(breakStart.offset, count);\n\n    for (const node of removed) {\n      this._removeFromClonedElementsGroup(node);\n    } // Merge after removing.\n\n\n    const mergePosition = this.mergeAttributes(breakStart);\n    range.start = mergePosition;\n    range.end = mergePosition.clone(); // Return removed nodes.\n\n    return new DocumentFragment(this.document, removed);\n  }\n  /**\n   * Removes matching elements from given range.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} range Range to clear.\n   * @param {module:engine/view/element~Element} element Element to remove.\n   */\n\n\n  clear(range, element) {\n    validateRangeContainer(range, this.document); // Create walker on given range.\n    // We walk backward because when we remove element during walk it modifies range end position.\n\n    const walker = range.getWalker({\n      direction: 'backward',\n      ignoreElementEnd: true\n    }); // Let's walk.\n\n    for (const current of walker) {\n      const item = current.item;\n      let rangeToRemove; // When current item matches to the given element.\n\n      if (item.is('element') && element.isSimilar(item)) {\n        // Create range on this element.\n        rangeToRemove = Range._createOn(item); // When range starts inside Text or TextProxy element.\n      } else if (!current.nextPosition.isAfter(range.start) && item.is('textProxy')) {\n        // We need to check if parent of this text matches to given element.\n        const parentElement = item.getAncestors().find(ancestor => {\n          return ancestor.is('element') && element.isSimilar(ancestor);\n        }); // If it is then create range inside this element.\n\n        if (parentElement) {\n          rangeToRemove = Range._createIn(parentElement);\n        }\n      } // If we have found element to remove.\n\n\n      if (rangeToRemove) {\n        // We need to check if element range stick out of the given range and truncate if it is.\n        if (rangeToRemove.end.isAfter(range.end)) {\n          rangeToRemove.end = range.end;\n        }\n\n        if (rangeToRemove.start.isBefore(range.start)) {\n          rangeToRemove.start = range.start;\n        } // At the end we remove range with found element.\n\n\n        this.remove(rangeToRemove);\n      }\n    }\n  }\n  /**\n   * Moves nodes from provided range to target position.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n   * @param {module:engine/view/position~Position} targetPosition Position to insert.\n   * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n   */\n\n\n  move(sourceRange, targetPosition) {\n    let nodes;\n\n    if (targetPosition.isAfter(sourceRange.end)) {\n      targetPosition = this._breakAttributes(targetPosition, true);\n      const parent = targetPosition.parent;\n      const countBefore = parent.childCount;\n      sourceRange = this._breakAttributesRange(sourceRange, true);\n      nodes = this.remove(sourceRange);\n      targetPosition.offset += parent.childCount - countBefore;\n    } else {\n      nodes = this.remove(sourceRange);\n    }\n\n    return this.insert(targetPosition, nodes);\n  }\n  /**\n   * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n   *\n   * If a collapsed range was passed and is same as selection, the selection\n   * will be moved to the inside of the wrapped attribute element.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n   * when {@link module:engine/view/range~Range#start}\n   * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n   * is collapsed and different than view selection.\n   *\n   * @param {module:engine/view/range~Range} range Range to wrap.\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n   * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n  */\n\n\n  wrap(range, attribute) {\n    if (!(attribute instanceof AttributeElement)) {\n      throw new CKEditorError('view-writer-wrap-invalid-attribute', this.document);\n    }\n\n    validateRangeContainer(range, this.document);\n\n    if (!range.isCollapsed) {\n      // Non-collapsed range. Wrap it with the attribute element.\n      return this._wrapRange(range, attribute);\n    } else {\n      // Collapsed range. Wrap position.\n      let position = range.start;\n\n      if (position.parent.is('element') && !_hasNonUiChildren(position.parent)) {\n        position = position.getLastMatchingPosition(value => value.item.is('uiElement'));\n      }\n\n      position = this._wrapPosition(position, attribute);\n      const viewSelection = this.document.selection; // If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\n      if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {\n        this.setSelection(position);\n      }\n\n      return new Range(position);\n    }\n  }\n  /**\n   * Unwraps nodes within provided range from attribute element.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n   * same parent container.\n   *\n   * @param {module:engine/view/range~Range} range\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   */\n\n\n  unwrap(range, attribute) {\n    if (!(attribute instanceof AttributeElement)) {\n      /**\n       * Attribute element need to be instance of attribute element.\n       *\n       * @error view-writer-unwrap-invalid-attribute\n       */\n      throw new CKEditorError('view-writer-unwrap-invalid-attribute', this.document);\n    }\n\n    validateRangeContainer(range, this.document); // If range is collapsed - nothing to unwrap.\n\n    if (range.isCollapsed) {\n      return range;\n    } // Break attributes at range start and end.\n\n\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n\n    const parentContainer = breakStart.parent; // Unwrap children located between break points.\n\n    const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute); // Merge attributes at the both ends and return a new range.\n\n\n    const start = this.mergeAttributes(newRange.start); // If start position was merged - move end position back.\n\n    if (!start.isEqual(newRange.start)) {\n      newRange.end.offset--;\n    }\n\n    const end = this.mergeAttributes(newRange.end);\n    return new Range(start, end);\n  }\n  /**\n   * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n   * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n   * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n   *\n   * New element has to be created because `Element#tagName` property in DOM is readonly.\n   *\n   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n   *\n   * @param {String} newName New name for element.\n   * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n   */\n\n\n  rename(newName, viewElement) {\n    const newElement = new ContainerElement(this.document, newName, viewElement.getAttributes());\n    this.insert(Position._createAfter(viewElement), newElement);\n    this.move(Range._createIn(viewElement), Position._createAt(newElement, 0));\n    this.remove(Range._createOn(viewElement));\n    return newElement;\n  }\n  /**\n   * Cleans up memory by removing obsolete cloned elements group from the writer.\n   *\n   * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n   * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n   * the group will no longer be needed.\n   *\n   * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n   * were removed from the view.\n   *\n   * Keep in mind that group names are equal to the `id` property of the attribute element.\n   *\n   * @param {String} groupName Name of the group to clear.\n   */\n\n\n  clearClonedElementsGroup(groupName) {\n    this._cloneGroups.delete(groupName);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/view/position~Position position},\n   * * parent element and offset (offset defaults to `0`),\n   * * parent element and `'end'` (sets position at the end of that element),\n   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n   *\n   * This method is a shortcut to other constructors such as:\n   *\n   * * {@link #createPositionBefore},\n   * * {@link #createPositionAfter},\n   *\n   * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/view/item~Item view item}.\n   */\n\n\n  createPositionAt(itemOrPosition, offset) {\n    return Position._createAt(itemOrPosition, offset);\n  }\n  /**\n   * Creates a new position after given view item.\n   *\n   * @param {module:engine/view/item~Item} item View item after which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  createPositionAfter(item) {\n    return Position._createAfter(item);\n  }\n  /**\n   * Creates a new position before given view item.\n   *\n   * @param {module:engine/view/item~Item} item View item before which the position should be located.\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  createPositionBefore(item) {\n    return Position._createBefore(item);\n  }\n  /**\n   * Creates a range spanning from `start` position to `end` position.\n   *\n   * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n   *\n   * @param {module:engine/view/position~Position} start Start position.\n   * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  createRange(start, end) {\n    return new Range(start, end);\n  }\n  /**\n   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n   *\n   * @param {module:engine/view/item~Item} item\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  createRangeOn(item) {\n    return Range._createOn(item);\n  }\n  /**\n   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n   * that element and ends after the last child of that element.\n   *\n   * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n   * @returns {module:engine/view/range~Range}\n   */\n\n\n  createRangeIn(element) {\n    return Range._createIn(element);\n  }\n  /**\n   Creates new {@link module:engine/view/selection~Selection} instance.\n   *\n   * \t\t// Creates empty selection without ranges.\n   *\t\tconst selection = writer.createSelection();\n   *\n   *\t\t// Creates selection at the given range.\n   *\t\tconst range = writer.createRange( start, end );\n   *\t\tconst selection = writer.createSelection( range );\n   *\n   *\t\t// Creates selection at the given ranges\n   * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n   *\t\tconst selection = writer.createSelection( ranges );\n   *\n   *\t\t// Creates selection from the other selection.\n   *\t\tconst otherSelection = writer.createSelection();\n   *\t\tconst selection = writer.createSelection( otherSelection );\n   *\n   *\t\t// Creates selection from the document selection.\n   *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n   *\n   * \t\t// Creates selection at the given position.\n   *\t\tconst position = writer.createPositionFromPath( root, path );\n   *\t\tconst selection = writer.createSelection( position );\n   *\n   *\t\t// Creates collapsed selection at the position of given item and offset.\n   *\t\tconst paragraph = writer.createContainerElement( 'p' );\n   *\t\tconst selection = writer.createSelection( paragraph, offset );\n   *\n   *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n   *\t\t// first child of that element and ends after the last child of that element.\n   *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n   *\n   *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n   *\t\t// just after the item.\n   *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n   *\n   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n   *\n   *\t\t// Creates backward selection.\n   *\t\tconst selection = writer.createSelection( range, { backward: true } );\n   *\n   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n   * represented in other way, for example by applying proper CSS class.\n   *\n   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n   * (and be  properly handled by screen readers).\n   *\n   *\t\t// Creates fake selection with label.\n   *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n   *\n   * @param {module:engine/view/selection~Selectable} [selectable=null]\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n   * @param {String} [options.label] Label for the fake selection.\n   * @returns {module:engine/view/selection~Selection}\n   */\n\n\n  createSelection(selectable, placeOrOffset, options) {\n    return new Selection(selectable, placeOrOffset, options);\n  }\n  /**\n   * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n   * `startOffset` and `endOffset` will be wrapped.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} parent\n   * @param {Number} startOffset\n   * @param {Number} endOffset\n   * @param {module:engine/view/element~Element} wrapElement\n   */\n\n\n  _wrapChildren(parent, startOffset, endOffset, wrapElement) {\n    let i = startOffset;\n    const wrapPositions = [];\n\n    while (i < endOffset) {\n      const child = parent.getChild(i);\n      const isText = child.is('text');\n      const isAttribute = child.is('attributeElement');\n      const isEmpty = child.is('emptyElement');\n      const isUI = child.is('uiElement'); //\n      // (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n      //\n      // Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n      // If possible, join elements.\n      //\n      // <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n      //\n\n      if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {\n        wrapPositions.push(new Position(parent, i));\n      } //\n      // Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n      // `wrapElement` (due to priority).\n      //\n      // <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n      // <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n      //\n      else if (isText || isEmpty || isUI || isAttribute && shouldABeOutsideB(wrapElement, child)) {\n          // Clone attribute.\n          const newAttribute = wrapElement._clone(); // Wrap current node with new attribute.\n\n\n          child._remove();\n\n          newAttribute._appendChild(child);\n\n          parent._insertChild(i, newAttribute);\n\n          this._addToClonedElementsGroup(newAttribute);\n\n          wrapPositions.push(new Position(parent, i));\n        } //\n        // If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n        //\n        // <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n        //\n        else if (isAttribute) {\n            this._wrapChildren(child, 0, child.childCount, wrapElement);\n          }\n\n      i++;\n    } // Merge at each wrap.\n\n\n    let offsetChange = 0;\n\n    for (const position of wrapPositions) {\n      position.offset -= offsetChange; // Do not merge with elements outside selected children.\n\n      if (position.offset == startOffset) {\n        continue;\n      }\n\n      const newPosition = this.mergeAttributes(position); // If nodes were merged - other merge offsets will change.\n\n      if (!newPosition.isEqual(position)) {\n        offsetChange++;\n        endOffset--;\n      }\n    }\n\n    return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n  }\n  /**\n   * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n   * `startOffset` and `endOffset` will be unwrapped.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} parent\n   * @param {Number} startOffset\n   * @param {Number} endOffset\n   * @param {module:engine/view/element~Element} unwrapElement\n   */\n\n\n  _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {\n    let i = startOffset;\n    const unwrapPositions = []; // Iterate over each element between provided offsets inside parent.\n    // We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n    // so it could get messy. It is safer to it manually in this case.\n\n    while (i < endOffset) {\n      const child = parent.getChild(i); // Skip all text nodes. There should be no container element's here either.\n\n      if (!child.is('attributeElement')) {\n        i++;\n        continue;\n      } //\n      // (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n      //\n      // If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n      //\n      // <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n      //\n\n\n      if (child.isSimilar(unwrapElement)) {\n        const unwrapped = child.getChildren();\n        const count = child.childCount; // Replace wrapper element with its children\n\n        child._remove();\n\n        parent._insertChild(i, unwrapped);\n\n        this._removeFromClonedElementsGroup(child); // Save start and end position of moved items.\n\n\n        unwrapPositions.push(new Position(parent, i), new Position(parent, i + count)); // Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n\n        i += count;\n        endOffset += count - 1;\n        continue;\n      } //\n      // If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n      // Partial unwrapping will happen only if the elements have the same name.\n      //\n      // <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n      // <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n      //\n\n\n      if (this._unwrapAttributeElement(unwrapElement, child)) {\n        unwrapPositions.push(new Position(parent, i), new Position(parent, i + 1));\n        i++;\n        continue;\n      } //\n      // If other nested attribute is found, look through it's children for elements to unwrap.\n      //\n      // <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n      //\n\n\n      this._unwrapChildren(child, 0, child.childCount, unwrapElement);\n\n      i++;\n    } // Merge at each unwrap.\n\n\n    let offsetChange = 0;\n\n    for (const position of unwrapPositions) {\n      position.offset -= offsetChange; // Do not merge with elements outside selected children.\n\n      if (position.offset == startOffset || position.offset == endOffset) {\n        continue;\n      }\n\n      const newPosition = this.mergeAttributes(position); // If nodes were merged - other merge offsets will change.\n\n      if (!newPosition.isEqual(position)) {\n        offsetChange++;\n        endOffset--;\n      }\n    }\n\n    return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);\n  }\n  /**\n   * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n   * This method will also merge newly added attribute element with its siblings whenever possible.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n   */\n\n\n  _wrapRange(range, attribute) {\n    // Break attributes at range start and end.\n    const {\n      start: breakStart,\n      end: breakEnd\n    } = this._breakAttributesRange(range, true);\n\n    const parentContainer = breakStart.parent; // Wrap all children with attribute.\n\n    const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute); // Merge attributes at the both ends and return a new range.\n\n\n    const start = this.mergeAttributes(newRange.start); // If start position was merged - move end position back.\n\n    if (!start.isEqual(newRange.start)) {\n      newRange.end.offset--;\n    }\n\n    const end = this.mergeAttributes(newRange.end);\n    return new Range(start, end);\n  }\n  /**\n   * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n   * This method will also merge newly added attribute element with its siblings whenever possible.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n   *\n   * @private\n   * @param {module:engine/view/position~Position} position\n   * @param {module:engine/view/attributeelement~AttributeElement} attribute\n   * @returns {module:engine/view/position~Position} New position after wrapping.\n   */\n\n\n  _wrapPosition(position, attribute) {\n    // Return same position when trying to wrap with attribute similar to position parent.\n    if (attribute.isSimilar(position.parent)) {\n      return movePositionToTextNode(position.clone());\n    } // When position is inside text node - break it and place new position between two text nodes.\n\n\n    if (position.parent.is('text')) {\n      position = breakTextNode(position);\n    } // Create fake element that will represent position, and will not be merged with other attributes.\n\n\n    const fakePosition = this.createAttributeElement();\n    fakePosition._priority = Number.POSITIVE_INFINITY;\n\n    fakePosition.isSimilar = () => false; // Insert fake element in position location.\n\n\n    position.parent._insertChild(position.offset, fakePosition); // Range around inserted fake attribute element.\n\n\n    const wrapRange = new Range(position, position.getShiftedBy(1)); // Wrap fake element with attribute (it will also merge if possible).\n\n    this.wrap(wrapRange, attribute); // Remove fake element and place new position there.\n\n    const newPosition = new Position(fakePosition.parent, fakePosition.index);\n\n    fakePosition._remove(); // If position is placed between text nodes - merge them and return position inside.\n\n\n    const nodeBefore = newPosition.nodeBefore;\n    const nodeAfter = newPosition.nodeAfter;\n\n    if (nodeBefore instanceof Text && nodeAfter instanceof Text) {\n      return mergeTextNodes(nodeBefore, nodeAfter);\n    } // If position is next to text node - move position inside.\n\n\n    return movePositionToTextNode(newPosition);\n  }\n  /**\n   * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n   * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n   * \telement to element being wrapped.\n   *\n   * \t@private\n   * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n   * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n   * \t@returns {Boolean} Returns `true` if elements are merged.\n   */\n\n\n  _wrapAttributeElement(wrapper, toWrap) {\n    if (!canBeJoined(wrapper, toWrap)) {\n      return false;\n    } // Can't merge if name or priority differs.\n\n\n    if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {\n      return false;\n    } // Check if attributes can be merged.\n\n\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      } // If some attributes are different we cannot wrap.\n\n\n      if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n        return false;\n      }\n    } // Check if styles can be merged.\n\n\n    for (const key of wrapper.getStyleNames()) {\n      if (toWrap.hasStyle(key) && toWrap.getStyle(key) !== wrapper.getStyle(key)) {\n        return false;\n      }\n    } // Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\n\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      } // Move only these attributes that are not present - other are similar.\n\n\n      if (!toWrap.hasAttribute(key)) {\n        this.setAttribute(key, wrapper.getAttribute(key), toWrap);\n      }\n    }\n\n    for (const key of wrapper.getStyleNames()) {\n      if (!toWrap.hasStyle(key)) {\n        this.setStyle(key, wrapper.getStyle(key), toWrap);\n      }\n    }\n\n    for (const key of wrapper.getClassNames()) {\n      if (!toWrap.hasClass(key)) {\n        this.addClass(key, toWrap);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n   * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n   * inside element being unwrapped.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n   * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n   * @returns {Boolean} Returns `true` if elements are unwrapped.\n   **/\n\n\n  _unwrapAttributeElement(wrapper, toUnwrap) {\n    if (!canBeJoined(wrapper, toUnwrap)) {\n      return false;\n    } // Can't unwrap if name or priority differs.\n\n\n    if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {\n      return false;\n    } // Check if AttributeElement has all wrapper attributes.\n\n\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      } // If some attributes are missing or different we cannot unwrap.\n\n\n      if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {\n        return false;\n      }\n    } // Check if AttributeElement has all wrapper classes.\n\n\n    if (!toUnwrap.hasClass(...wrapper.getClassNames())) {\n      return false;\n    } // Check if AttributeElement has all wrapper styles.\n\n\n    for (const key of wrapper.getStyleNames()) {\n      // If some styles are missing or different we cannot unwrap.\n      if (!toUnwrap.hasStyle(key) || toUnwrap.getStyle(key) !== wrapper.getStyle(key)) {\n        return false;\n      }\n    } // Remove all wrapper's attributes from unwrapped element.\n\n\n    for (const key of wrapper.getAttributeKeys()) {\n      // Classes and styles should be checked separately.\n      if (key === 'class' || key === 'style') {\n        continue;\n      }\n\n      this.removeAttribute(key, toUnwrap);\n    } // Remove all wrapper's classes from unwrapped element.\n\n\n    this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap); // Remove all wrapper's styles from unwrapped element.\n\n    this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);\n    return true;\n  }\n  /**\n   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n   *\n   * @private\n   * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n   * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n   * @returns {module:engine/view/range~Range} New range with located at break positions.\n   */\n\n\n  _breakAttributesRange(range, forceSplitText = false) {\n    const rangeStart = range.start;\n    const rangeEnd = range.end;\n    validateRangeContainer(range, this.document); // Break at the collapsed position. Return new collapsed range.\n\n    if (range.isCollapsed) {\n      const position = this._breakAttributes(range.start, forceSplitText);\n\n      return new Range(position, position);\n    }\n\n    const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);\n\n    const count = breakEnd.parent.childCount;\n\n    const breakStart = this._breakAttributes(rangeStart, forceSplitText); // Calculate new break end offset.\n\n\n    breakEnd.offset += breakEnd.parent.childCount - count;\n    return new Range(breakStart, breakEnd);\n  }\n  /**\n   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n   * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n   *\n   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n   * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n   *\n   * @private\n   * @param {module:engine/view/position~Position} position Position where to break attributes.\n   * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n   * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n   */\n\n\n  _breakAttributes(position, forceSplitText = false) {\n    const positionOffset = position.offset;\n    const positionParent = position.parent; // If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\n    if (position.parent.is('emptyElement')) {\n      /**\n       * Cannot break inside EmptyElement instance.\n       *\n       * @error view-writer-cannot-break-empty-element\n       */\n      throw new CKEditorError('view-writer-cannot-break-empty-element', this.document);\n    } // If position is placed inside UIElement - throw an exception as we cannot break inside.\n\n\n    if (position.parent.is('uiElement')) {\n      /**\n       * Cannot break inside UIElement instance.\n       *\n       * @error view-writer-cannot-break-ui-element\n       */\n      throw new CKEditorError('view-writer-cannot-break-ui-element', this.document);\n    } // There are no attributes to break and text nodes breaking is not forced.\n\n\n    if (!forceSplitText && positionParent.is('text') && isContainerOrFragment(positionParent.parent)) {\n      return position.clone();\n    } // Position's parent is container, so no attributes to break.\n\n\n    if (isContainerOrFragment(positionParent)) {\n      return position.clone();\n    } // Break text and start again in new position.\n\n\n    if (positionParent.is('text')) {\n      return this._breakAttributes(breakTextNode(position), forceSplitText);\n    }\n\n    const length = positionParent.childCount; // <p>foo<b><u>bar{}</u></b></p>\n    // <p>foo<b><u>bar</u>[]</b></p>\n    // <p>foo<b><u>bar</u></b>[]</p>\n\n    if (positionOffset == length) {\n      const newPosition = new Position(positionParent.parent, positionParent.index + 1);\n      return this._breakAttributes(newPosition, forceSplitText);\n    } else {\n      // <p>foo<b><u>{}bar</u></b></p>\n      // <p>foo<b>[]<u>bar</u></b></p>\n      // <p>foo{}<b><u>bar</u></b></p>\n      if (positionOffset === 0) {\n        const newPosition = new Position(positionParent.parent, positionParent.index);\n        return this._breakAttributes(newPosition, forceSplitText);\n      } // <p>foo<b><u>b{}ar</u></b></p>\n      // <p>foo<b><u>b[]ar</u></b></p>\n      // <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n      // <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n      else {\n          const offsetAfter = positionParent.index + 1; // Break element.\n\n          const clonedNode = positionParent._clone(); // Insert cloned node to position's parent node.\n\n\n          positionParent.parent._insertChild(offsetAfter, clonedNode);\n\n          this._addToClonedElementsGroup(clonedNode); // Get nodes to move.\n\n\n          const count = positionParent.childCount - positionOffset;\n\n          const nodesToMove = positionParent._removeChildren(positionOffset, count); // Move nodes to cloned node.\n\n\n          clonedNode._appendChild(nodesToMove); // Create new position to work on.\n\n\n          const newPosition = new Position(positionParent.parent, offsetAfter);\n          return this._breakAttributes(newPosition, forceSplitText);\n        }\n    }\n  }\n  /**\n   * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n   * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n   * from the group now keep a reference to the given attribute element.\n   *\n   * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n   *\n   * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n   */\n\n\n  _addToClonedElementsGroup(element) {\n    // Add only if the element is in document tree.\n    if (!element.root.is('rootElement')) {\n      return;\n    } // Traverse the element's children recursively to find other attribute elements that also might got inserted.\n    // The loop is at the beginning so we can make fast returns later in the code.\n\n\n    if (element.is('element')) {\n      for (const child of element.getChildren()) {\n        this._addToClonedElementsGroup(child);\n      }\n    }\n\n    const id = element.id;\n\n    if (!id) {\n      return;\n    }\n\n    let group = this._cloneGroups.get(id);\n\n    if (!group) {\n      group = new Set();\n\n      this._cloneGroups.set(id, group);\n    }\n\n    group.add(element);\n    element._clonesGroup = group;\n  }\n  /**\n   * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n   * from its clones group.\n   *\n   * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n   * This allows to reference the whole group even if the element was already removed from the tree.\n   *\n   * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n   *\n   * @private\n   * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n   */\n\n\n  _removeFromClonedElementsGroup(element) {\n    // Traverse the element's children recursively to find other attribute elements that also got removed.\n    // The loop is at the beginning so we can make fast returns later in the code.\n    if (element.is('element')) {\n      for (const child of element.getChildren()) {\n        this._removeFromClonedElementsGroup(child);\n      }\n    }\n\n    const id = element.id;\n\n    if (!id) {\n      return;\n    }\n\n    const group = this._cloneGroups.get(id);\n\n    if (!group) {\n      return;\n    }\n\n    group.delete(element); // Not removing group from element on purpose!\n    // If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n  }\n\n} // Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\n\nfunction _hasNonUiChildren(parent) {\n  return Array.from(parent.getChildren()).some(child => !child.is('uiElement'));\n}\n/**\n * Attribute element need to be instance of attribute element.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\n\n\nfunction getParentContainer(position) {\n  let parent = position.parent;\n\n  while (!isContainerOrFragment(parent)) {\n    if (!parent) {\n      return undefined;\n    }\n\n    parent = parent.parent;\n  }\n\n  return parent;\n} // Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped otuside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\n\n\nfunction shouldABeOutsideB(a, b) {\n  if (a.priority < b.priority) {\n    return true;\n  } else if (a.priority > b.priority) {\n    return false;\n  } // When priorities are equal and names are different - use identities.\n\n\n  return a.getIdentity() < b.getIdentity();\n} // Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\n\n\nfunction movePositionToTextNode(position) {\n  const nodeBefore = position.nodeBefore;\n\n  if (nodeBefore && nodeBefore.is('text')) {\n    return new Position(nodeBefore, nodeBefore.data.length);\n  }\n\n  const nodeAfter = position.nodeAfter;\n\n  if (nodeAfter && nodeAfter.is('text')) {\n    return new Position(nodeAfter, 0);\n  }\n\n  return position;\n} // Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\n\n\nfunction breakTextNode(position) {\n  if (position.offset == position.parent.data.length) {\n    return new Position(position.parent.parent, position.parent.index + 1);\n  }\n\n  if (position.offset === 0) {\n    return new Position(position.parent.parent, position.parent.index);\n  } // Get part of the text that need to be moved.\n\n\n  const textToMove = position.parent.data.slice(position.offset); // Leave rest of the text in position's parent.\n\n  position.parent._data = position.parent.data.slice(0, position.offset); // Insert new text node after position's parent text node.\n\n  position.parent.parent._insertChild(position.parent.index + 1, new Text(position.root.document, textToMove)); // Return new position between two newly created text nodes.\n\n\n  return new Position(position.parent.parent, position.parent.index + 1);\n} // Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\n\n\nfunction mergeTextNodes(t1, t2) {\n  // Merge text data into first text node and remove second one.\n  const nodeBeforeLength = t1.data.length;\n  t1._data += t2.data;\n\n  t2._remove();\n\n  return new Position(t1, nodeBeforeLength);\n} // Checks if provided nodes are valid to insert. Checks if each node is an instance of\n// {@link module:engine/view/text~Text Text} or {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n// {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElement} or\n// {@link module:engine/view/uielement~UIElement UIElement}.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not {@link module:engine/view/text~Text Texts},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n// {@link module:engine/view/uielement~UIElement UIElements},\n// {@link module:engine/view/attributeelement~AttributeElement AttributeElements} or\n// {@link module:engine/view/containerelement~ContainerElement ContainerElements}.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement\n// |module:engine/view/containerelement~ContainerElement> nodes\n// @param {Object} errorContext\n\n\nfunction validateNodesToInsert(nodes, errorContext) {\n  for (const node of nodes) {\n    if (!validNodesToInsert.some(validNode => node instanceof validNode)) {\n      // eslint-disable-line no-use-before-define\n\n      /**\n       * Inserted nodes should be valid to insert. of {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n       * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n       * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n       * {@link module:engine/view/uielement~UIElement UIElement}, {@link module:engine/view/text~Text Text}.\n       *\n       * @error view-writer-insert-invalid-node\n       */\n      throw new CKEditorError('view-writer-insert-invalid-node', errorContext);\n    }\n\n    if (!node.is('text')) {\n      validateNodesToInsert(node.getChildren(), errorContext);\n    }\n  }\n}\n\nconst validNodesToInsert = [Text, AttributeElement, ContainerElement, EmptyElement, UIElement]; // Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\n\nfunction isContainerOrFragment(node) {\n  return node && (node.is('containerElement') || node.is('documentFragment'));\n} // Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\n\n\nfunction validateRangeContainer(range, errorContext) {\n  const startContainer = getParentContainer(range.start);\n  const endContainer = getParentContainer(range.end);\n\n  if (!startContainer || !endContainer || startContainer !== endContainer) {\n    /**\n     * Range container is invalid. This can happen if {@link module:engine/view/range~Range#start range start} and\n     * {@link module:engine/view/range~Range#end range end} positions are not placed inside same container or\n     * parent container for these positions cannot be found.\n     *\n     * @error view-writer-invalid-range-container\n     */\n    throw new CKEditorError('view-writer-invalid-range-container', errorContext);\n  }\n} // Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\n\n\nfunction canBeJoined(a, b) {\n  return a.id === null && b.id === null;\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js"],"names":["Position","Range","Selection","ContainerElement","AttributeElement","EmptyElement","UIElement","CKEditorError","DocumentFragment","isIterable","Text","EditableElement","isPlainObject","DowncastWriter","constructor","document","_cloneGroups","Map","setSelection","selectable","placeOrOffset","options","selection","_setTo","setSelectionFocus","itemOrPosition","offset","_setFocus","createText","data","createAttributeElement","name","attributes","attributeElement","priority","_priority","id","_id","createContainerElement","createEditableElement","editableElement","_document","createEmptyElement","createUIElement","renderFunction","uiElement","render","setAttribute","key","value","element","_setAttribute","removeAttribute","_removeAttribute","addClass","className","_addClass","removeClass","_removeClass","setStyle","property","undefined","_setStyle","removeStyle","_removeStyle","setCustomProperty","_setCustomProperty","removeCustomProperty","_removeCustomProperty","breakAttributes","positionOrRange","_breakAttributes","_breakAttributesRange","breakContainer","position","parent","is","isAtStart","_createBefore","isAtEnd","newElement","_clone","insert","_createAfter","sourceRange","_createAt","targetPosition","move","mergeAttributes","positionOffset","positionParent","childCount","index","_remove","_removeFromClonedElementsGroup","nodeBefore","getChild","nodeAfter","mergeTextNodes","isSimilar","count","_appendChild","getChildren","mergeContainers","prev","next","lastChild","newPosition","_createIn","remove","_createOn","nodes","validateNodesToInsert","container","getParentContainer","insertionPosition","length","_insertChild","node","_addToClonedElementsGroup","endPosition","getShiftedBy","start","isEqual","end","rangeOrItem","range","validateRangeContainer","isCollapsed","breakStart","breakEnd","parentContainer","removed","_removeChildren","mergePosition","clone","clear","walker","getWalker","direction","ignoreElementEnd","current","item","rangeToRemove","nextPosition","isAfter","parentElement","getAncestors","find","ancestor","isBefore","countBefore","wrap","attribute","_wrapRange","_hasNonUiChildren","getLastMatchingPosition","_wrapPosition","viewSelection","getFirstPosition","unwrap","newRange","_unwrapChildren","rename","newName","viewElement","getAttributes","clearClonedElementsGroup","groupName","delete","createPositionAt","createPositionAfter","createPositionBefore","createRange","createRangeOn","createRangeIn","createSelection","_wrapChildren","startOffset","endOffset","wrapElement","i","wrapPositions","child","isText","isAttribute","isEmpty","isUI","_wrapAttributeElement","push","shouldABeOutsideB","newAttribute","offsetChange","_createFromParentsAndOffsets","unwrapElement","unwrapPositions","unwrapped","_unwrapAttributeElement","movePositionToTextNode","breakTextNode","fakePosition","Number","POSITIVE_INFINITY","wrapRange","wrapper","toWrap","canBeJoined","getAttributeKeys","hasAttribute","getAttribute","getStyleNames","hasStyle","getStyle","getClassNames","hasClass","toUnwrap","Array","from","forceSplitText","rangeStart","rangeEnd","isContainerOrFragment","offsetAfter","clonedNode","nodesToMove","root","group","get","Set","set","add","_clonesGroup","some","a","b","getIdentity","textToMove","slice","_data","t1","t2","nodeBeforeLength","errorContext","validNodesToInsert","validNode","startContainer","endContainer"],"mappings":"AAAA;;;;;AAKA;;;AAIA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,SAASC,aAAT,QAA8B,WAA9B;AAEA;;;;;;;;;;;;;;;;AAeA,eAAe,MAAMC,cAAN,CAAqB;AACnC;;;AAGAC,EAAAA,WAAW,CAAEC,QAAF,EAAa;AACvB;;;;;;AAMA,SAAKA,QAAL,GAAgBA,QAAhB;AAEA;;;;;;;;AAOA,SAAKC,YAAL,GAAoB,IAAIC,GAAJ,EAApB;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEAC,EAAAA,YAAY,CAAEC,UAAF,EAAcC,aAAd,EAA6BC,OAA7B,EAAuC;AAClD,SAAKN,QAAL,CAAcO,SAAd,CAAwBC,MAAxB,CAAgCJ,UAAhC,EAA4CC,aAA5C,EAA2DC,OAA3D;AACA;AAED;;;;;;;;;;;;AAUAG,EAAAA,iBAAiB,CAAEC,cAAF,EAAkBC,MAAlB,EAA2B;AAC3C,SAAKX,QAAL,CAAcO,SAAd,CAAwBK,SAAxB,CAAmCF,cAAnC,EAAmDC,MAAnD;AACA;AAED;;;;;;;;;;AAQAE,EAAAA,UAAU,CAAEC,IAAF,EAAS;AAClB,WAAO,IAAInB,IAAJ,CAAU,KAAKK,QAAf,EAAyBc,IAAzB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;AAmBAC,EAAAA,sBAAsB,CAAEC,IAAF,EAAQC,UAAR,EAAoBX,OAAO,GAAG,EAA9B,EAAmC;AACxD,UAAMY,gBAAgB,GAAG,IAAI7B,gBAAJ,CAAsB,KAAKW,QAA3B,EAAqCgB,IAArC,EAA2CC,UAA3C,CAAzB;;AAEA,QAAKX,OAAO,CAACa,QAAb,EAAwB;AACvBD,MAAAA,gBAAgB,CAACE,SAAjB,GAA6Bd,OAAO,CAACa,QAArC;AACA;;AAED,QAAKb,OAAO,CAACe,EAAb,EAAkB;AACjBH,MAAAA,gBAAgB,CAACI,GAAjB,GAAuBhB,OAAO,CAACe,EAA/B;AACA;;AAED,WAAOH,gBAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;AAkBAK,EAAAA,sBAAsB,CAAEP,IAAF,EAAQC,UAAR,EAAqB;AAC1C,WAAO,IAAI7B,gBAAJ,CAAsB,KAAKY,QAA3B,EAAqCgB,IAArC,EAA2CC,UAA3C,CAAP;AACA;AAED;;;;;;;;;;;;AAUAO,EAAAA,qBAAqB,CAAER,IAAF,EAAQC,UAAR,EAAqB;AACzC,UAAMQ,eAAe,GAAG,IAAI7B,eAAJ,CAAqB,KAAKI,QAA1B,EAAoCgB,IAApC,EAA0CC,UAA1C,CAAxB;AACAQ,IAAAA,eAAe,CAACC,SAAhB,GAA4B,KAAK1B,QAAjC;AAEA,WAAOyB,eAAP;AACA;AAED;;;;;;;;;;;;AAUAE,EAAAA,kBAAkB,CAAEX,IAAF,EAAQC,UAAR,EAAqB;AACtC,WAAO,IAAI3B,YAAJ,CAAkB,KAAKU,QAAvB,EAAiCgB,IAAjC,EAAuCC,UAAvC,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;AAoBAW,EAAAA,eAAe,CAAEZ,IAAF,EAAQC,UAAR,EAAoBY,cAApB,EAAqC;AACnD,UAAMC,SAAS,GAAG,IAAIvC,SAAJ,CAAe,KAAKS,QAApB,EAA8BgB,IAA9B,EAAoCC,UAApC,CAAlB;;AAEA,QAAKY,cAAL,EAAsB;AACrBC,MAAAA,SAAS,CAACC,MAAV,GAAmBF,cAAnB;AACA;;AAED,WAAOC,SAAP;AACA;AAED;;;;;;;;;;;AASAE,EAAAA,YAAY,CAAEC,GAAF,EAAOC,KAAP,EAAcC,OAAd,EAAwB;AACnCA,IAAAA,OAAO,CAACC,aAAR,CAAuBH,GAAvB,EAA4BC,KAA5B;AACA;AAED;;;;;;;;;;AAQAG,EAAAA,eAAe,CAAEJ,GAAF,EAAOE,OAAP,EAAiB;AAC/BA,IAAAA,OAAO,CAACG,gBAAR,CAA0BL,GAA1B;AACA;AAED;;;;;;;;;;;AASAM,EAAAA,QAAQ,CAAEC,SAAF,EAAaL,OAAb,EAAuB;AAC9BA,IAAAA,OAAO,CAACM,SAAR,CAAmBD,SAAnB;AACA;AAED;;;;;;;;;;;AASAE,EAAAA,WAAW,CAAEF,SAAF,EAAaL,OAAb,EAAuB;AACjCA,IAAAA,OAAO,CAACQ,YAAR,CAAsBH,SAAtB;AACA;AAED;;;;;;;;;;;;;;;;;;;AAiBAI,EAAAA,QAAQ,CAAEC,QAAF,EAAYX,KAAZ,EAAmBC,OAAnB,EAA6B;AACpC,QAAKtC,aAAa,CAAEgD,QAAF,CAAb,IAA6BV,OAAO,KAAKW,SAA9C,EAA0D;AACzDX,MAAAA,OAAO,GAAGD,KAAV;AACA;;AAEDC,IAAAA,OAAO,CAACY,SAAR,CAAmBF,QAAnB,EAA6BX,KAA7B;AACA;AAED;;;;;;;;;;;;;;;AAaAc,EAAAA,WAAW,CAAEH,QAAF,EAAYV,OAAZ,EAAsB;AAChCA,IAAAA,OAAO,CAACc,YAAR,CAAsBJ,QAAtB;AACA;AAED;;;;;;;;;;AAQAK,EAAAA,iBAAiB,CAAEjB,GAAF,EAAOC,KAAP,EAAcC,OAAd,EAAwB;AACxCA,IAAAA,OAAO,CAACgB,kBAAR,CAA4BlB,GAA5B,EAAiCC,KAAjC;AACA;AAED;;;;;;;;;AAOAkB,EAAAA,oBAAoB,CAAEnB,GAAF,EAAOE,OAAP,EAAiB;AACpC,WAAOA,OAAO,CAACkB,qBAAR,CAA+BpB,GAA/B,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCAqB,EAAAA,eAAe,CAAEC,eAAF,EAAoB;AAClC,QAAKA,eAAe,YAAYtE,QAAhC,EAA2C;AAC1C,aAAO,KAAKuE,gBAAL,CAAuBD,eAAvB,CAAP;AACA,KAFD,MAEO;AACN,aAAO,KAAKE,qBAAL,CAA4BF,eAA5B,CAAP;AACA;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;AAuBAG,EAAAA,cAAc,CAAEC,QAAF,EAAa;AAC1B,UAAMxB,OAAO,GAAGwB,QAAQ,CAACC,MAAzB;;AAEA,QAAK,CAAGzB,OAAO,CAAC0B,EAAR,CAAY,kBAAZ,CAAR,EAA6C;AAC5C;;;;;AAKA,YAAM,IAAIrE,aAAJ,CACL,uGADK,EAEL,KAAKQ,QAFA,CAAN;AAIA;;AAED,QAAK,CAACmC,OAAO,CAACyB,MAAd,EAAuB;AACtB;;;;;AAKA,YAAM,IAAIpE,aAAJ,CAAmB,uDAAnB,EAA4E,KAAKQ,QAAjF,CAAN;AACA;;AAED,QAAK2D,QAAQ,CAACG,SAAd,EAA0B;AACzB,aAAO7E,QAAQ,CAAC8E,aAAT,CAAwB5B,OAAxB,CAAP;AACA,KAFD,MAEO,IAAK,CAACwB,QAAQ,CAACK,OAAf,EAAyB;AAC/B,YAAMC,UAAU,GAAG9B,OAAO,CAAC+B,MAAR,CAAgB,KAAhB,CAAnB;;AAEA,WAAKC,MAAL,CAAalF,QAAQ,CAACmF,YAAT,CAAuBjC,OAAvB,CAAb,EAA+C8B,UAA/C;AAEA,YAAMI,WAAW,GAAG,IAAInF,KAAJ,CAAWyE,QAAX,EAAqB1E,QAAQ,CAACqF,SAAT,CAAoBnC,OAApB,EAA6B,KAA7B,CAArB,CAApB;AACA,YAAMoC,cAAc,GAAG,IAAItF,QAAJ,CAAcgF,UAAd,EAA0B,CAA1B,CAAvB;AAEA,WAAKO,IAAL,CAAWH,WAAX,EAAwBE,cAAxB;AACA;;AAED,WAAOtF,QAAQ,CAACmF,YAAT,CAAuBjC,OAAvB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BAsC,EAAAA,eAAe,CAAEd,QAAF,EAAa;AAC3B,UAAMe,cAAc,GAAGf,QAAQ,CAAChD,MAAhC;AACA,UAAMgE,cAAc,GAAGhB,QAAQ,CAACC,MAAhC,CAF2B,CAI3B;;AACA,QAAKe,cAAc,CAACd,EAAf,CAAmB,MAAnB,CAAL,EAAmC;AAClC,aAAOF,QAAP;AACA,KAP0B,CAS3B;;;AACA,QAAKgB,cAAc,CAACd,EAAf,CAAmB,kBAAnB,KAA2Cc,cAAc,CAACC,UAAf,KAA8B,CAA9E,EAAkF;AACjF,YAAMhB,MAAM,GAAGe,cAAc,CAACf,MAA9B;AACA,YAAMjD,MAAM,GAAGgE,cAAc,CAACE,KAA9B;;AAEAF,MAAAA,cAAc,CAACG,OAAf;;AACA,WAAKC,8BAAL,CAAqCJ,cAArC;;AAEA,aAAO,KAAKF,eAAL,CAAsB,IAAIxF,QAAJ,CAAc2E,MAAd,EAAsBjD,MAAtB,CAAtB,CAAP;AACA;;AAED,UAAMqE,UAAU,GAAGL,cAAc,CAACM,QAAf,CAAyBP,cAAc,GAAG,CAA1C,CAAnB;AACA,UAAMQ,SAAS,GAAGP,cAAc,CAACM,QAAf,CAAyBP,cAAzB,CAAlB,CArB2B,CAuB3B;;AACA,QAAK,CAACM,UAAD,IAAe,CAACE,SAArB,EAAiC;AAChC,aAAOvB,QAAP;AACA,KA1B0B,CA4B3B;;;AACA,QAAKqB,UAAU,CAACnB,EAAX,CAAe,MAAf,KAA2BqB,SAAS,CAACrB,EAAV,CAAc,MAAd,CAAhC,EAAyD;AACxD,aAAOsB,cAAc,CAAEH,UAAF,EAAcE,SAAd,CAArB;AACA,KAFD,CAGA;AAHA,SAIK,IAAKF,UAAU,CAACnB,EAAX,CAAe,kBAAf,KAAuCqB,SAAS,CAACrB,EAAV,CAAc,kBAAd,CAAvC,IAA6EmB,UAAU,CAACI,SAAX,CAAsBF,SAAtB,CAAlF,EAAsH;AAC1H;AACA,cAAMG,KAAK,GAAGL,UAAU,CAACJ,UAAzB;;AACAI,QAAAA,UAAU,CAACM,YAAX,CAAyBJ,SAAS,CAACK,WAAV,EAAzB;;AAEAL,QAAAA,SAAS,CAACJ,OAAV;;AACA,aAAKC,8BAAL,CAAqCG,SAArC,EAN0H,CAQ1H;AACA;;;AACA,eAAO,KAAKT,eAAL,CAAsB,IAAIxF,QAAJ,CAAc+F,UAAd,EAA0BK,KAA1B,CAAtB,CAAP;AACA;;AAED,WAAO1B,QAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;AAkBA6B,EAAAA,eAAe,CAAE7B,QAAF,EAAa;AAC3B,UAAM8B,IAAI,GAAG9B,QAAQ,CAACqB,UAAtB;AACA,UAAMU,IAAI,GAAG/B,QAAQ,CAACuB,SAAtB;;AAEA,QAAK,CAACO,IAAD,IAAS,CAACC,IAAV,IAAkB,CAACD,IAAI,CAAC5B,EAAL,CAAS,kBAAT,CAAnB,IAAoD,CAAC6B,IAAI,CAAC7B,EAAL,CAAS,kBAAT,CAA1D,EAA0F;AACzF;;;;;AAKA,YAAM,IAAIrE,aAAJ,CAAmB,oDACxB,2DADK,EACwD,KAAKQ,QAD7D,CAAN;AAEA;;AAED,UAAM2F,SAAS,GAAGF,IAAI,CAACR,QAAL,CAAeQ,IAAI,CAACb,UAAL,GAAkB,CAAjC,CAAlB;AACA,UAAMgB,WAAW,GAAGD,SAAS,YAAYhG,IAArB,GAA4BV,QAAQ,CAACqF,SAAT,CAAoBqB,SAApB,EAA+B,KAA/B,CAA5B,GAAqE1G,QAAQ,CAACqF,SAAT,CAAoBmB,IAApB,EAA0B,KAA1B,CAAzF;AAEA,SAAKjB,IAAL,CAAWtF,KAAK,CAAC2G,SAAN,CAAiBH,IAAjB,CAAX,EAAoCzG,QAAQ,CAACqF,SAAT,CAAoBmB,IAApB,EAA0B,KAA1B,CAApC;AACA,SAAKK,MAAL,CAAa5G,KAAK,CAAC6G,SAAN,CAAiBL,IAAjB,CAAb;AAEA,WAAOE,WAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;AAmBAzB,EAAAA,MAAM,CAAER,QAAF,EAAYqC,KAAZ,EAAoB;AACzBA,IAAAA,KAAK,GAAGtG,UAAU,CAAEsG,KAAF,CAAV,GAAsB,CAAE,GAAGA,KAAL,CAAtB,GAAqC,CAAEA,KAAF,CAA7C,CADyB,CAGzB;;AACAC,IAAAA,qBAAqB,CAAED,KAAF,EAAS,KAAKhG,QAAd,CAArB;AAEA,UAAMkG,SAAS,GAAGC,kBAAkB,CAAExC,QAAF,CAApC;;AAEA,QAAK,CAACuC,SAAN,EAAkB;AACjB;;;;;AAKA,YAAM,IAAI1G,aAAJ,CAAmB,wCAAnB,EAA6D,KAAKQ,QAAlE,CAAN;AACA;;AAED,UAAMoG,iBAAiB,GAAG,KAAK5C,gBAAL,CAAuBG,QAAvB,EAAiC,IAAjC,CAA1B;;AACA,UAAM0C,MAAM,GAAGH,SAAS,CAACI,YAAV,CAAwBF,iBAAiB,CAACzF,MAA1C,EAAkDqF,KAAlD,CAAf;;AAEA,SAAM,MAAMO,IAAZ,IAAoBP,KAApB,EAA4B;AAC3B,WAAKQ,yBAAL,CAAgCD,IAAhC;AACA;;AAED,UAAME,WAAW,GAAGL,iBAAiB,CAACM,YAAlB,CAAgCL,MAAhC,CAApB;AACA,UAAMM,KAAK,GAAG,KAAKlC,eAAL,CAAsB2B,iBAAtB,CAAd,CAzByB,CA2BzB;;AACA,QAAKC,MAAM,KAAK,CAAhB,EAAoB;AACnB,aAAO,IAAInH,KAAJ,CAAWyH,KAAX,EAAkBA,KAAlB,CAAP;AACA,KAFD,MAEO;AACN;AACA,UAAK,CAACA,KAAK,CAACC,OAAN,CAAeR,iBAAf,CAAN,EAA2C;AAC1CK,QAAAA,WAAW,CAAC9F,MAAZ;AACA;;AAED,YAAMkG,GAAG,GAAG,KAAKpC,eAAL,CAAsBgC,WAAtB,CAAZ;AAEA,aAAO,IAAIvH,KAAJ,CAAWyH,KAAX,EAAkBE,GAAlB,CAAP;AACA;AACD;AAED;;;;;;;;;;;;;;AAYAf,EAAAA,MAAM,CAAEgB,WAAF,EAAgB;AACrB,UAAMC,KAAK,GAAGD,WAAW,YAAY5H,KAAvB,GAA+B4H,WAA/B,GAA6C5H,KAAK,CAAC6G,SAAN,CAAiBe,WAAjB,CAA3D;AAEAE,IAAAA,sBAAsB,CAAED,KAAF,EAAS,KAAK/G,QAAd,CAAtB,CAHqB,CAKrB;;AACA,QAAK+G,KAAK,CAACE,WAAX,EAAyB;AACxB,aAAO,IAAIxH,gBAAJ,CAAsB,KAAKO,QAA3B,CAAP;AACA,KARoB,CAUrB;;;AACA,UAAM;AAAE2G,MAAAA,KAAK,EAAEO,UAAT;AAAqBL,MAAAA,GAAG,EAAEM;AAA1B,QAAuC,KAAK1D,qBAAL,CAA4BsD,KAA5B,EAAmC,IAAnC,CAA7C;;AACA,UAAMK,eAAe,GAAGF,UAAU,CAACtD,MAAnC;AAEA,UAAMyB,KAAK,GAAG8B,QAAQ,CAACxG,MAAT,GAAkBuG,UAAU,CAACvG,MAA3C,CAdqB,CAgBrB;;AACA,UAAM0G,OAAO,GAAGD,eAAe,CAACE,eAAhB,CAAiCJ,UAAU,CAACvG,MAA5C,EAAoD0E,KAApD,CAAhB;;AAEA,SAAM,MAAMkB,IAAZ,IAAoBc,OAApB,EAA8B;AAC7B,WAAKtC,8BAAL,CAAqCwB,IAArC;AACA,KArBoB,CAuBrB;;;AACA,UAAMgB,aAAa,GAAG,KAAK9C,eAAL,CAAsByC,UAAtB,CAAtB;AACAH,IAAAA,KAAK,CAACJ,KAAN,GAAcY,aAAd;AACAR,IAAAA,KAAK,CAACF,GAAN,GAAYU,aAAa,CAACC,KAAd,EAAZ,CA1BqB,CA4BrB;;AACA,WAAO,IAAI/H,gBAAJ,CAAsB,KAAKO,QAA3B,EAAqCqH,OAArC,CAAP;AACA;AAED;;;;;;;;;;;;AAUAI,EAAAA,KAAK,CAAEV,KAAF,EAAS5E,OAAT,EAAmB;AACvB6E,IAAAA,sBAAsB,CAAED,KAAF,EAAS,KAAK/G,QAAd,CAAtB,CADuB,CAGvB;AACA;;AACA,UAAM0H,MAAM,GAAGX,KAAK,CAACY,SAAN,CAAiB;AAC/BC,MAAAA,SAAS,EAAE,UADoB;AAE/BC,MAAAA,gBAAgB,EAAE;AAFa,KAAjB,CAAf,CALuB,CAUvB;;AACA,SAAM,MAAMC,OAAZ,IAAuBJ,MAAvB,EAAgC;AAC/B,YAAMK,IAAI,GAAGD,OAAO,CAACC,IAArB;AACA,UAAIC,aAAJ,CAF+B,CAI/B;;AACA,UAAKD,IAAI,CAAClE,EAAL,CAAS,SAAT,KAAwB1B,OAAO,CAACiD,SAAR,CAAmB2C,IAAnB,CAA7B,EAAyD;AACxD;AACAC,QAAAA,aAAa,GAAG9I,KAAK,CAAC6G,SAAN,CAAiBgC,IAAjB,CAAhB,CAFwD,CAGxD;AACA,OAJD,MAIO,IAAK,CAACD,OAAO,CAACG,YAAR,CAAqBC,OAArB,CAA8BnB,KAAK,CAACJ,KAApC,CAAD,IAAgDoB,IAAI,CAAClE,EAAL,CAAS,WAAT,CAArD,EAA8E;AACpF;AACA,cAAMsE,aAAa,GAAGJ,IAAI,CAACK,YAAL,GAAoBC,IAApB,CAA0BC,QAAQ,IAAI;AAC3D,iBAAOA,QAAQ,CAACzE,EAAT,CAAa,SAAb,KAA4B1B,OAAO,CAACiD,SAAR,CAAmBkD,QAAnB,CAAnC;AACA,SAFqB,CAAtB,CAFoF,CAMpF;;AACA,YAAKH,aAAL,EAAqB;AACpBH,UAAAA,aAAa,GAAG9I,KAAK,CAAC2G,SAAN,CAAiBsC,aAAjB,CAAhB;AACA;AACD,OAnB8B,CAqB/B;;;AACA,UAAKH,aAAL,EAAqB;AACpB;AACA,YAAKA,aAAa,CAACnB,GAAd,CAAkBqB,OAAlB,CAA2BnB,KAAK,CAACF,GAAjC,CAAL,EAA8C;AAC7CmB,UAAAA,aAAa,CAACnB,GAAd,GAAoBE,KAAK,CAACF,GAA1B;AACA;;AAED,YAAKmB,aAAa,CAACrB,KAAd,CAAoB4B,QAApB,CAA8BxB,KAAK,CAACJ,KAApC,CAAL,EAAmD;AAClDqB,UAAAA,aAAa,CAACrB,KAAd,GAAsBI,KAAK,CAACJ,KAA5B;AACA,SARmB,CAUpB;;;AACA,aAAKb,MAAL,CAAakC,aAAb;AACA;AACD;AACD;AAED;;;;;;;;;;;;;;AAYAxD,EAAAA,IAAI,CAAEH,WAAF,EAAeE,cAAf,EAAgC;AACnC,QAAIyB,KAAJ;;AAEA,QAAKzB,cAAc,CAAC2D,OAAf,CAAwB7D,WAAW,CAACwC,GAApC,CAAL,EAAiD;AAChDtC,MAAAA,cAAc,GAAG,KAAKf,gBAAL,CAAuBe,cAAvB,EAAuC,IAAvC,CAAjB;AAEA,YAAMX,MAAM,GAAGW,cAAc,CAACX,MAA9B;AACA,YAAM4E,WAAW,GAAG5E,MAAM,CAACgB,UAA3B;AAEAP,MAAAA,WAAW,GAAG,KAAKZ,qBAAL,CAA4BY,WAA5B,EAAyC,IAAzC,CAAd;AAEA2B,MAAAA,KAAK,GAAG,KAAKF,MAAL,CAAazB,WAAb,CAAR;AAEAE,MAAAA,cAAc,CAAC5D,MAAf,IAA2BiD,MAAM,CAACgB,UAAP,GAAoB4D,WAA/C;AACA,KAXD,MAWO;AACNxC,MAAAA,KAAK,GAAG,KAAKF,MAAL,CAAazB,WAAb,CAAR;AACA;;AAED,WAAO,KAAKF,MAAL,CAAaI,cAAb,EAA6ByB,KAA7B,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;AAqBAyC,EAAAA,IAAI,CAAE1B,KAAF,EAAS2B,SAAT,EAAqB;AACxB,QAAK,EAAGA,SAAS,YAAYrJ,gBAAxB,CAAL,EAAkD;AACjD,YAAM,IAAIG,aAAJ,CAAmB,oCAAnB,EAAyD,KAAKQ,QAA9D,CAAN;AACA;;AAEDgH,IAAAA,sBAAsB,CAAED,KAAF,EAAS,KAAK/G,QAAd,CAAtB;;AAEA,QAAK,CAAC+G,KAAK,CAACE,WAAZ,EAA0B;AACzB;AACA,aAAO,KAAK0B,UAAL,CAAiB5B,KAAjB,EAAwB2B,SAAxB,CAAP;AACA,KAHD,MAGO;AACN;AACA,UAAI/E,QAAQ,GAAGoD,KAAK,CAACJ,KAArB;;AAEA,UAAKhD,QAAQ,CAACC,MAAT,CAAgBC,EAAhB,CAAoB,SAApB,KAAmC,CAAC+E,iBAAiB,CAAEjF,QAAQ,CAACC,MAAX,CAA1D,EAAgF;AAC/ED,QAAAA,QAAQ,GAAGA,QAAQ,CAACkF,uBAAT,CAAkC3G,KAAK,IAAIA,KAAK,CAAC6F,IAAN,CAAWlE,EAAX,CAAe,WAAf,CAA3C,CAAX;AACA;;AAEDF,MAAAA,QAAQ,GAAG,KAAKmF,aAAL,CAAoBnF,QAApB,EAA8B+E,SAA9B,CAAX;AACA,YAAMK,aAAa,GAAG,KAAK/I,QAAL,CAAcO,SAApC,CATM,CAWN;;AACA,UAAKwI,aAAa,CAAC9B,WAAd,IAA6B8B,aAAa,CAACC,gBAAd,GAAiCpC,OAAjC,CAA0CG,KAAK,CAACJ,KAAhD,CAAlC,EAA4F;AAC3F,aAAKxG,YAAL,CAAmBwD,QAAnB;AACA;;AAED,aAAO,IAAIzE,KAAJ,CAAWyE,QAAX,CAAP;AACA;AACD;AAED;;;;;;;;;;;;AAUAsF,EAAAA,MAAM,CAAElC,KAAF,EAAS2B,SAAT,EAAqB;AAC1B,QAAK,EAAGA,SAAS,YAAYrJ,gBAAxB,CAAL,EAAkD;AACjD;;;;;AAKA,YAAM,IAAIG,aAAJ,CAAmB,sCAAnB,EAA2D,KAAKQ,QAAhE,CAAN;AACA;;AAEDgH,IAAAA,sBAAsB,CAAED,KAAF,EAAS,KAAK/G,QAAd,CAAtB,CAV0B,CAY1B;;AACA,QAAK+G,KAAK,CAACE,WAAX,EAAyB;AACxB,aAAOF,KAAP;AACA,KAfyB,CAiB1B;;;AACA,UAAM;AAAEJ,MAAAA,KAAK,EAAEO,UAAT;AAAqBL,MAAAA,GAAG,EAAEM;AAA1B,QAAuC,KAAK1D,qBAAL,CAA4BsD,KAA5B,EAAmC,IAAnC,CAA7C;;AACA,UAAMK,eAAe,GAAGF,UAAU,CAACtD,MAAnC,CAnB0B,CAqB1B;;AACA,UAAMsF,QAAQ,GAAG,KAAKC,eAAL,CAAsB/B,eAAtB,EAAuCF,UAAU,CAACvG,MAAlD,EAA0DwG,QAAQ,CAACxG,MAAnE,EAA2E+H,SAA3E,CAAjB,CAtB0B,CAwB1B;;;AACA,UAAM/B,KAAK,GAAG,KAAKlC,eAAL,CAAsByE,QAAQ,CAACvC,KAA/B,CAAd,CAzB0B,CA2B1B;;AACA,QAAK,CAACA,KAAK,CAACC,OAAN,CAAesC,QAAQ,CAACvC,KAAxB,CAAN,EAAwC;AACvCuC,MAAAA,QAAQ,CAACrC,GAAT,CAAalG,MAAb;AACA;;AAED,UAAMkG,GAAG,GAAG,KAAKpC,eAAL,CAAsByE,QAAQ,CAACrC,GAA/B,CAAZ;AAEA,WAAO,IAAI3H,KAAJ,CAAWyH,KAAX,EAAkBE,GAAlB,CAAP;AACA;AAED;;;;;;;;;;;;;;AAYAuC,EAAAA,MAAM,CAAEC,OAAF,EAAWC,WAAX,EAAyB;AAC9B,UAAMrF,UAAU,GAAG,IAAI7E,gBAAJ,CAAsB,KAAKY,QAA3B,EAAqCqJ,OAArC,EAA8CC,WAAW,CAACC,aAAZ,EAA9C,CAAnB;AAEA,SAAKpF,MAAL,CAAalF,QAAQ,CAACmF,YAAT,CAAuBkF,WAAvB,CAAb,EAAmDrF,UAAnD;AACA,SAAKO,IAAL,CAAWtF,KAAK,CAAC2G,SAAN,CAAiByD,WAAjB,CAAX,EAA2CrK,QAAQ,CAACqF,SAAT,CAAoBL,UAApB,EAAgC,CAAhC,CAA3C;AACA,SAAK6B,MAAL,CAAa5G,KAAK,CAAC6G,SAAN,CAAiBuD,WAAjB,CAAb;AAEA,WAAOrF,UAAP;AACA;AAED;;;;;;;;;;;;;;;;AAcAuF,EAAAA,wBAAwB,CAAEC,SAAF,EAAc;AACrC,SAAKxJ,YAAL,CAAkByJ,MAAlB,CAA0BD,SAA1B;AACA;AAED;;;;;;;;;;;;;;;;;;;AAiBAE,EAAAA,gBAAgB,CAAEjJ,cAAF,EAAkBC,MAAlB,EAA2B;AAC1C,WAAO1B,QAAQ,CAACqF,SAAT,CAAoB5D,cAApB,EAAoCC,MAApC,CAAP;AACA;AAED;;;;;;;;AAMAiJ,EAAAA,mBAAmB,CAAE7B,IAAF,EAAS;AAC3B,WAAO9I,QAAQ,CAACmF,YAAT,CAAuB2D,IAAvB,CAAP;AACA;AAED;;;;;;;;AAMA8B,EAAAA,oBAAoB,CAAE9B,IAAF,EAAS;AAC5B,WAAO9I,QAAQ,CAAC8E,aAAT,CAAwBgE,IAAxB,CAAP;AACA;AAED;;;;;;;;;;;AASA+B,EAAAA,WAAW,CAAEnD,KAAF,EAASE,GAAT,EAAe;AACzB,WAAO,IAAI3H,KAAJ,CAAWyH,KAAX,EAAkBE,GAAlB,CAAP;AACA;AAED;;;;;;;;AAMAkD,EAAAA,aAAa,CAAEhC,IAAF,EAAS;AACrB,WAAO7I,KAAK,CAAC6G,SAAN,CAAiBgC,IAAjB,CAAP;AACA;AAED;;;;;;;;;AAOAiC,EAAAA,aAAa,CAAE7H,OAAF,EAAY;AACxB,WAAOjD,KAAK,CAAC2G,SAAN,CAAiB1D,OAAjB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4DA8H,EAAAA,eAAe,CAAE7J,UAAF,EAAcC,aAAd,EAA6BC,OAA7B,EAAuC;AACrD,WAAO,IAAInB,SAAJ,CAAeiB,UAAf,EAA2BC,aAA3B,EAA0CC,OAA1C,CAAP;AACA;AAED;;;;;;;;;;;;AAUA4J,EAAAA,aAAa,CAAEtG,MAAF,EAAUuG,WAAV,EAAuBC,SAAvB,EAAkCC,WAAlC,EAAgD;AAC5D,QAAIC,CAAC,GAAGH,WAAR;AACA,UAAMI,aAAa,GAAG,EAAtB;;AAEA,WAAQD,CAAC,GAAGF,SAAZ,EAAwB;AACvB,YAAMI,KAAK,GAAG5G,MAAM,CAACqB,QAAP,CAAiBqF,CAAjB,CAAd;AACA,YAAMG,MAAM,GAAGD,KAAK,CAAC3G,EAAN,CAAU,MAAV,CAAf;AACA,YAAM6G,WAAW,GAAGF,KAAK,CAAC3G,EAAN,CAAU,kBAAV,CAApB;AACA,YAAM8G,OAAO,GAAGH,KAAK,CAAC3G,EAAN,CAAU,cAAV,CAAhB;AACA,YAAM+G,IAAI,GAAGJ,KAAK,CAAC3G,EAAN,CAAU,WAAV,CAAb,CALuB,CAOvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAK6G,WAAW,IAAI,KAAKG,qBAAL,CAA4BR,WAA5B,EAAyCG,KAAzC,CAApB,EAAuE;AACtED,QAAAA,aAAa,CAACO,IAAd,CAAoB,IAAI7L,QAAJ,CAAc2E,MAAd,EAAsB0G,CAAtB,CAApB;AACA,OAFD,CAGA;AACA;AACA;AACA;AACA;AACA;AACA;AATA,WAUK,IAAKG,MAAM,IAAIE,OAAV,IAAqBC,IAArB,IAA+BF,WAAW,IAAIK,iBAAiB,CAAEV,WAAF,EAAeG,KAAf,CAApE,EAA+F;AACnG;AACA,gBAAMQ,YAAY,GAAGX,WAAW,CAACnG,MAAZ,EAArB,CAFmG,CAInG;;;AACAsG,UAAAA,KAAK,CAAC1F,OAAN;;AACAkG,UAAAA,YAAY,CAAC1F,YAAb,CAA2BkF,KAA3B;;AAEA5G,UAAAA,MAAM,CAAC0C,YAAP,CAAqBgE,CAArB,EAAwBU,YAAxB;;AACA,eAAKxE,yBAAL,CAAgCwE,YAAhC;;AAEAT,UAAAA,aAAa,CAACO,IAAd,CAAoB,IAAI7L,QAAJ,CAAc2E,MAAd,EAAsB0G,CAAtB,CAApB;AACA,SAZI,CAaL;AACA;AACA;AACA;AACA;AAjBK,aAkBA,IAAKI,WAAL,EAAmB;AACvB,iBAAKR,aAAL,CAAoBM,KAApB,EAA2B,CAA3B,EAA8BA,KAAK,CAAC5F,UAApC,EAAgDyF,WAAhD;AACA;;AAEDC,MAAAA,CAAC;AACD,KApD2D,CAsD5D;;;AACA,QAAIW,YAAY,GAAG,CAAnB;;AAEA,SAAM,MAAMtH,QAAZ,IAAwB4G,aAAxB,EAAwC;AACvC5G,MAAAA,QAAQ,CAAChD,MAAT,IAAmBsK,YAAnB,CADuC,CAGvC;;AACA,UAAKtH,QAAQ,CAAChD,MAAT,IAAmBwJ,WAAxB,EAAsC;AACrC;AACA;;AAED,YAAMvE,WAAW,GAAG,KAAKnB,eAAL,CAAsBd,QAAtB,CAApB,CARuC,CAUvC;;AACA,UAAK,CAACiC,WAAW,CAACgB,OAAZ,CAAqBjD,QAArB,CAAN,EAAwC;AACvCsH,QAAAA,YAAY;AACZb,QAAAA,SAAS;AACT;AACD;;AAED,WAAOlL,KAAK,CAACgM,4BAAN,CAAoCtH,MAApC,EAA4CuG,WAA5C,EAAyDvG,MAAzD,EAAiEwG,SAAjE,CAAP;AACA;AAED;;;;;;;;;;;;AAUAjB,EAAAA,eAAe,CAAEvF,MAAF,EAAUuG,WAAV,EAAuBC,SAAvB,EAAkCe,aAAlC,EAAkD;AAChE,QAAIb,CAAC,GAAGH,WAAR;AACA,UAAMiB,eAAe,GAAG,EAAxB,CAFgE,CAIhE;AACA;AACA;;AACA,WAAQd,CAAC,GAAGF,SAAZ,EAAwB;AACvB,YAAMI,KAAK,GAAG5G,MAAM,CAACqB,QAAP,CAAiBqF,CAAjB,CAAd,CADuB,CAGvB;;AACA,UAAK,CAACE,KAAK,CAAC3G,EAAN,CAAU,kBAAV,CAAN,EAAuC;AACtCyG,QAAAA,CAAC;AAED;AACA,OARsB,CAUvB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAKE,KAAK,CAACpF,SAAN,CAAiB+F,aAAjB,CAAL,EAAwC;AACvC,cAAME,SAAS,GAAGb,KAAK,CAACjF,WAAN,EAAlB;AACA,cAAMF,KAAK,GAAGmF,KAAK,CAAC5F,UAApB,CAFuC,CAIvC;;AACA4F,QAAAA,KAAK,CAAC1F,OAAN;;AACAlB,QAAAA,MAAM,CAAC0C,YAAP,CAAqBgE,CAArB,EAAwBe,SAAxB;;AAEA,aAAKtG,8BAAL,CAAqCyF,KAArC,EARuC,CAUvC;;;AACAY,QAAAA,eAAe,CAACN,IAAhB,CACC,IAAI7L,QAAJ,CAAc2E,MAAd,EAAsB0G,CAAtB,CADD,EAEC,IAAIrL,QAAJ,CAAc2E,MAAd,EAAsB0G,CAAC,GAAGjF,KAA1B,CAFD,EAXuC,CAgBvC;;AACAiF,QAAAA,CAAC,IAAIjF,KAAL;AACA+E,QAAAA,SAAS,IAAI/E,KAAK,GAAG,CAArB;AAEA;AACA,OAtCsB,CAwCvB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAK,KAAKiG,uBAAL,CAA8BH,aAA9B,EAA6CX,KAA7C,CAAL,EAA4D;AAC3DY,QAAAA,eAAe,CAACN,IAAhB,CACC,IAAI7L,QAAJ,CAAc2E,MAAd,EAAsB0G,CAAtB,CADD,EAEC,IAAIrL,QAAJ,CAAc2E,MAAd,EAAsB0G,CAAC,GAAG,CAA1B,CAFD;AAKAA,QAAAA,CAAC;AAED;AACA,OAxDsB,CA0DvB;AACA;AACA;AACA;AACA;;;AACA,WAAKnB,eAAL,CAAsBqB,KAAtB,EAA6B,CAA7B,EAAgCA,KAAK,CAAC5F,UAAtC,EAAkDuG,aAAlD;;AAEAb,MAAAA,CAAC;AACD,KAzE+D,CA2EhE;;;AACA,QAAIW,YAAY,GAAG,CAAnB;;AAEA,SAAM,MAAMtH,QAAZ,IAAwByH,eAAxB,EAA0C;AACzCzH,MAAAA,QAAQ,CAAChD,MAAT,IAAmBsK,YAAnB,CADyC,CAGzC;;AACA,UAAKtH,QAAQ,CAAChD,MAAT,IAAmBwJ,WAAnB,IAAkCxG,QAAQ,CAAChD,MAAT,IAAmByJ,SAA1D,EAAsE;AACrE;AACA;;AAED,YAAMxE,WAAW,GAAG,KAAKnB,eAAL,CAAsBd,QAAtB,CAApB,CARyC,CAUzC;;AACA,UAAK,CAACiC,WAAW,CAACgB,OAAZ,CAAqBjD,QAArB,CAAN,EAAwC;AACvCsH,QAAAA,YAAY;AACZb,QAAAA,SAAS;AACT;AACD;;AAED,WAAOlL,KAAK,CAACgM,4BAAN,CAAoCtH,MAApC,EAA4CuG,WAA5C,EAAyDvG,MAAzD,EAAiEwG,SAAjE,CAAP;AACA;AAED;;;;;;;;;;;;;;AAYAzB,EAAAA,UAAU,CAAE5B,KAAF,EAAS2B,SAAT,EAAqB;AAC9B;AACA,UAAM;AAAE/B,MAAAA,KAAK,EAAEO,UAAT;AAAqBL,MAAAA,GAAG,EAAEM;AAA1B,QAAuC,KAAK1D,qBAAL,CAA4BsD,KAA5B,EAAmC,IAAnC,CAA7C;;AACA,UAAMK,eAAe,GAAGF,UAAU,CAACtD,MAAnC,CAH8B,CAK9B;;AACA,UAAMsF,QAAQ,GAAG,KAAKgB,aAAL,CAAoB9C,eAApB,EAAqCF,UAAU,CAACvG,MAAhD,EAAwDwG,QAAQ,CAACxG,MAAjE,EAAyE+H,SAAzE,CAAjB,CAN8B,CAQ9B;;;AACA,UAAM/B,KAAK,GAAG,KAAKlC,eAAL,CAAsByE,QAAQ,CAACvC,KAA/B,CAAd,CAT8B,CAW9B;;AACA,QAAK,CAACA,KAAK,CAACC,OAAN,CAAesC,QAAQ,CAACvC,KAAxB,CAAN,EAAwC;AACvCuC,MAAAA,QAAQ,CAACrC,GAAT,CAAalG,MAAb;AACA;;AACD,UAAMkG,GAAG,GAAG,KAAKpC,eAAL,CAAsByE,QAAQ,CAACrC,GAA/B,CAAZ;AAEA,WAAO,IAAI3H,KAAJ,CAAWyH,KAAX,EAAkBE,GAAlB,CAAP;AACA;AAED;;;;;;;;;;;;;;AAYAiC,EAAAA,aAAa,CAAEnF,QAAF,EAAY+E,SAAZ,EAAwB;AACpC;AACA,QAAKA,SAAS,CAACtD,SAAV,CAAqBzB,QAAQ,CAACC,MAA9B,CAAL,EAA8C;AAC7C,aAAO2H,sBAAsB,CAAE5H,QAAQ,CAAC6D,KAAT,EAAF,CAA7B;AACA,KAJmC,CAMpC;;;AACA,QAAK7D,QAAQ,CAACC,MAAT,CAAgBC,EAAhB,CAAoB,MAApB,CAAL,EAAoC;AACnCF,MAAAA,QAAQ,GAAG6H,aAAa,CAAE7H,QAAF,CAAxB;AACA,KATmC,CAWpC;;;AACA,UAAM8H,YAAY,GAAG,KAAK1K,sBAAL,EAArB;AACA0K,IAAAA,YAAY,CAACrK,SAAb,GAAyBsK,MAAM,CAACC,iBAAhC;;AACAF,IAAAA,YAAY,CAACrG,SAAb,GAAyB,MAAM,KAA/B,CAdoC,CAgBpC;;;AACAzB,IAAAA,QAAQ,CAACC,MAAT,CAAgB0C,YAAhB,CAA8B3C,QAAQ,CAAChD,MAAvC,EAA+C8K,YAA/C,EAjBoC,CAmBpC;;;AACA,UAAMG,SAAS,GAAG,IAAI1M,KAAJ,CAAWyE,QAAX,EAAqBA,QAAQ,CAAC+C,YAAT,CAAuB,CAAvB,CAArB,CAAlB,CApBoC,CAsBpC;;AACA,SAAK+B,IAAL,CAAWmD,SAAX,EAAsBlD,SAAtB,EAvBoC,CAyBpC;;AACA,UAAM9C,WAAW,GAAG,IAAI3G,QAAJ,CAAcwM,YAAY,CAAC7H,MAA3B,EAAmC6H,YAAY,CAAC5G,KAAhD,CAApB;;AACA4G,IAAAA,YAAY,CAAC3G,OAAb,GA3BoC,CA6BpC;;;AACA,UAAME,UAAU,GAAGY,WAAW,CAACZ,UAA/B;AACA,UAAME,SAAS,GAAGU,WAAW,CAACV,SAA9B;;AAEA,QAAKF,UAAU,YAAYrF,IAAtB,IAA8BuF,SAAS,YAAYvF,IAAxD,EAA+D;AAC9D,aAAOwF,cAAc,CAAEH,UAAF,EAAcE,SAAd,CAArB;AACA,KAnCmC,CAqCpC;;;AACA,WAAOqG,sBAAsB,CAAE3F,WAAF,CAA7B;AACA;AAED;;;;;;;;;;;;AAUAiF,EAAAA,qBAAqB,CAAEgB,OAAF,EAAWC,MAAX,EAAoB;AACxC,QAAK,CAACC,WAAW,CAAEF,OAAF,EAAWC,MAAX,CAAjB,EAAuC;AACtC,aAAO,KAAP;AACA,KAHuC,CAKxC;;;AACA,QAAKD,OAAO,CAAC7K,IAAR,KAAiB8K,MAAM,CAAC9K,IAAxB,IAAgC6K,OAAO,CAAC1K,QAAR,KAAqB2K,MAAM,CAAC3K,QAAjE,EAA4E;AAC3E,aAAO,KAAP;AACA,KARuC,CAUxC;;;AACA,SAAM,MAAMc,GAAZ,IAAmB4J,OAAO,CAACG,gBAAR,EAAnB,EAAgD;AAC/C;AACA,UAAK/J,GAAG,KAAK,OAAR,IAAmBA,GAAG,KAAK,OAAhC,EAA0C;AACzC;AACA,OAJ8C,CAM/C;;;AACA,UAAK6J,MAAM,CAACG,YAAP,CAAqBhK,GAArB,KAA8B6J,MAAM,CAACI,YAAP,CAAqBjK,GAArB,MAA+B4J,OAAO,CAACK,YAAR,CAAsBjK,GAAtB,CAAlE,EAAgG;AAC/F,eAAO,KAAP;AACA;AACD,KArBuC,CAuBxC;;;AACA,SAAM,MAAMA,GAAZ,IAAmB4J,OAAO,CAACM,aAAR,EAAnB,EAA6C;AAC5C,UAAKL,MAAM,CAACM,QAAP,CAAiBnK,GAAjB,KAA0B6J,MAAM,CAACO,QAAP,CAAiBpK,GAAjB,MAA2B4J,OAAO,CAACQ,QAAR,CAAkBpK,GAAlB,CAA1D,EAAoF;AACnF,eAAO,KAAP;AACA;AACD,KA5BuC,CA8BxC;;;AACA,SAAM,MAAMA,GAAZ,IAAmB4J,OAAO,CAACG,gBAAR,EAAnB,EAAgD;AAC/C;AACA,UAAK/J,GAAG,KAAK,OAAR,IAAmBA,GAAG,KAAK,OAAhC,EAA0C;AACzC;AACA,OAJ8C,CAM/C;;;AACA,UAAK,CAAC6J,MAAM,CAACG,YAAP,CAAqBhK,GAArB,CAAN,EAAmC;AAClC,aAAKD,YAAL,CAAmBC,GAAnB,EAAwB4J,OAAO,CAACK,YAAR,CAAsBjK,GAAtB,CAAxB,EAAqD6J,MAArD;AACA;AACD;;AAED,SAAM,MAAM7J,GAAZ,IAAmB4J,OAAO,CAACM,aAAR,EAAnB,EAA6C;AAC5C,UAAK,CAACL,MAAM,CAACM,QAAP,CAAiBnK,GAAjB,CAAN,EAA+B;AAC9B,aAAKW,QAAL,CAAeX,GAAf,EAAoB4J,OAAO,CAACQ,QAAR,CAAkBpK,GAAlB,CAApB,EAA6C6J,MAA7C;AACA;AACD;;AAED,SAAM,MAAM7J,GAAZ,IAAmB4J,OAAO,CAACS,aAAR,EAAnB,EAA6C;AAC5C,UAAK,CAACR,MAAM,CAACS,QAAP,CAAiBtK,GAAjB,CAAN,EAA+B;AAC9B,aAAKM,QAAL,CAAeN,GAAf,EAAoB6J,MAApB;AACA;AACD;;AAED,WAAO,IAAP;AACA;AAED;;;;;;;;;;;;AAUAR,EAAAA,uBAAuB,CAAEO,OAAF,EAAWW,QAAX,EAAsB;AAC5C,QAAK,CAACT,WAAW,CAAEF,OAAF,EAAWW,QAAX,CAAjB,EAAyC;AACxC,aAAO,KAAP;AACA,KAH2C,CAK5C;;;AACA,QAAKX,OAAO,CAAC7K,IAAR,KAAiBwL,QAAQ,CAACxL,IAA1B,IAAkC6K,OAAO,CAAC1K,QAAR,KAAqBqL,QAAQ,CAACrL,QAArE,EAAgF;AAC/E,aAAO,KAAP;AACA,KAR2C,CAU5C;;;AACA,SAAM,MAAMc,GAAZ,IAAmB4J,OAAO,CAACG,gBAAR,EAAnB,EAAgD;AAC/C;AACA,UAAK/J,GAAG,KAAK,OAAR,IAAmBA,GAAG,KAAK,OAAhC,EAA0C;AACzC;AACA,OAJ8C,CAM/C;;;AACA,UAAK,CAACuK,QAAQ,CAACP,YAAT,CAAuBhK,GAAvB,CAAD,IAAiCuK,QAAQ,CAACN,YAAT,CAAuBjK,GAAvB,MAAiC4J,OAAO,CAACK,YAAR,CAAsBjK,GAAtB,CAAvE,EAAqG;AACpG,eAAO,KAAP;AACA;AACD,KArB2C,CAuB5C;;;AACA,QAAK,CAACuK,QAAQ,CAACD,QAAT,CAAmB,GAAGV,OAAO,CAACS,aAAR,EAAtB,CAAN,EAAwD;AACvD,aAAO,KAAP;AACA,KA1B2C,CA4B5C;;;AACA,SAAM,MAAMrK,GAAZ,IAAmB4J,OAAO,CAACM,aAAR,EAAnB,EAA6C;AAC5C;AACA,UAAK,CAACK,QAAQ,CAACJ,QAAT,CAAmBnK,GAAnB,CAAD,IAA6BuK,QAAQ,CAACH,QAAT,CAAmBpK,GAAnB,MAA6B4J,OAAO,CAACQ,QAAR,CAAkBpK,GAAlB,CAA/D,EAAyF;AACxF,eAAO,KAAP;AACA;AACD,KAlC2C,CAoC5C;;;AACA,SAAM,MAAMA,GAAZ,IAAmB4J,OAAO,CAACG,gBAAR,EAAnB,EAAgD;AAC/C;AACA,UAAK/J,GAAG,KAAK,OAAR,IAAmBA,GAAG,KAAK,OAAhC,EAA0C;AACzC;AACA;;AAED,WAAKI,eAAL,CAAsBJ,GAAtB,EAA2BuK,QAA3B;AACA,KA5C2C,CA8C5C;;;AACA,SAAK9J,WAAL,CAAkB+J,KAAK,CAACC,IAAN,CAAYb,OAAO,CAACS,aAAR,EAAZ,CAAlB,EAAyDE,QAAzD,EA/C4C,CAiD5C;;AACA,SAAKxJ,WAAL,CAAkByJ,KAAK,CAACC,IAAN,CAAYb,OAAO,CAACM,aAAR,EAAZ,CAAlB,EAAyDK,QAAzD;AAEA,WAAO,IAAP;AACA;AAED;;;;;;;;;;;AASA/I,EAAAA,qBAAqB,CAAEsD,KAAF,EAAS4F,cAAc,GAAG,KAA1B,EAAkC;AACtD,UAAMC,UAAU,GAAG7F,KAAK,CAACJ,KAAzB;AACA,UAAMkG,QAAQ,GAAG9F,KAAK,CAACF,GAAvB;AAEAG,IAAAA,sBAAsB,CAAED,KAAF,EAAS,KAAK/G,QAAd,CAAtB,CAJsD,CAMtD;;AACA,QAAK+G,KAAK,CAACE,WAAX,EAAyB;AACxB,YAAMtD,QAAQ,GAAG,KAAKH,gBAAL,CAAuBuD,KAAK,CAACJ,KAA7B,EAAoCgG,cAApC,CAAjB;;AAEA,aAAO,IAAIzN,KAAJ,CAAWyE,QAAX,EAAqBA,QAArB,CAAP;AACA;;AAED,UAAMwD,QAAQ,GAAG,KAAK3D,gBAAL,CAAuBqJ,QAAvB,EAAiCF,cAAjC,CAAjB;;AACA,UAAMtH,KAAK,GAAG8B,QAAQ,CAACvD,MAAT,CAAgBgB,UAA9B;;AACA,UAAMsC,UAAU,GAAG,KAAK1D,gBAAL,CAAuBoJ,UAAvB,EAAmCD,cAAnC,CAAnB,CAfsD,CAiBtD;;;AACAxF,IAAAA,QAAQ,CAACxG,MAAT,IAAmBwG,QAAQ,CAACvD,MAAT,CAAgBgB,UAAhB,GAA6BS,KAAhD;AAEA,WAAO,IAAInG,KAAJ,CAAWgI,UAAX,EAAuBC,QAAvB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;AAeA3D,EAAAA,gBAAgB,CAAEG,QAAF,EAAYgJ,cAAc,GAAG,KAA7B,EAAqC;AACpD,UAAMjI,cAAc,GAAGf,QAAQ,CAAChD,MAAhC;AACA,UAAMgE,cAAc,GAAGhB,QAAQ,CAACC,MAAhC,CAFoD,CAIpD;;AACA,QAAKD,QAAQ,CAACC,MAAT,CAAgBC,EAAhB,CAAoB,cAApB,CAAL,EAA4C;AAC3C;;;;;AAKA,YAAM,IAAIrE,aAAJ,CAAmB,wCAAnB,EAA6D,KAAKQ,QAAlE,CAAN;AACA,KAZmD,CAcpD;;;AACA,QAAK2D,QAAQ,CAACC,MAAT,CAAgBC,EAAhB,CAAoB,WAApB,CAAL,EAAyC;AACxC;;;;;AAKA,YAAM,IAAIrE,aAAJ,CAAmB,qCAAnB,EAA0D,KAAKQ,QAA/D,CAAN;AACA,KAtBmD,CAwBpD;;;AACA,QAAK,CAAC2M,cAAD,IAAmBhI,cAAc,CAACd,EAAf,CAAmB,MAAnB,CAAnB,IAAkDiJ,qBAAqB,CAAEnI,cAAc,CAACf,MAAjB,CAA5E,EAAwG;AACvG,aAAOD,QAAQ,CAAC6D,KAAT,EAAP;AACA,KA3BmD,CA6BpD;;;AACA,QAAKsF,qBAAqB,CAAEnI,cAAF,CAA1B,EAA+C;AAC9C,aAAOhB,QAAQ,CAAC6D,KAAT,EAAP;AACA,KAhCmD,CAkCpD;;;AACA,QAAK7C,cAAc,CAACd,EAAf,CAAmB,MAAnB,CAAL,EAAmC;AAClC,aAAO,KAAKL,gBAAL,CAAuBgI,aAAa,CAAE7H,QAAF,CAApC,EAAkDgJ,cAAlD,CAAP;AACA;;AAED,UAAMtG,MAAM,GAAG1B,cAAc,CAACC,UAA9B,CAvCoD,CAyCpD;AACA;AACA;;AACA,QAAKF,cAAc,IAAI2B,MAAvB,EAAgC;AAC/B,YAAMT,WAAW,GAAG,IAAI3G,QAAJ,CAAc0F,cAAc,CAACf,MAA7B,EAAqCe,cAAc,CAACE,KAAf,GAAuB,CAA5D,CAApB;AAEA,aAAO,KAAKrB,gBAAL,CAAuBoC,WAAvB,EAAoC+G,cAApC,CAAP;AACA,KAJD,MAIO;AACN;AACA;AACA;AACA,UAAKjI,cAAc,KAAK,CAAxB,EAA4B;AAC3B,cAAMkB,WAAW,GAAG,IAAI3G,QAAJ,CAAc0F,cAAc,CAACf,MAA7B,EAAqCe,cAAc,CAACE,KAApD,CAApB;AAEA,eAAO,KAAKrB,gBAAL,CAAuBoC,WAAvB,EAAoC+G,cAApC,CAAP;AACA,OAJD,CAKA;AACA;AACA;AACA;AARA,WASK;AACJ,gBAAMI,WAAW,GAAGpI,cAAc,CAACE,KAAf,GAAuB,CAA3C,CADI,CAGJ;;AACA,gBAAMmI,UAAU,GAAGrI,cAAc,CAACT,MAAf,EAAnB,CAJI,CAMJ;;;AACAS,UAAAA,cAAc,CAACf,MAAf,CAAsB0C,YAAtB,CAAoCyG,WAApC,EAAiDC,UAAjD;;AACA,eAAKxG,yBAAL,CAAgCwG,UAAhC,EARI,CAUJ;;;AACA,gBAAM3H,KAAK,GAAGV,cAAc,CAACC,UAAf,GAA4BF,cAA1C;;AACA,gBAAMuI,WAAW,GAAGtI,cAAc,CAAC2C,eAAf,CAAgC5C,cAAhC,EAAgDW,KAAhD,CAApB,CAZI,CAcJ;;;AACA2H,UAAAA,UAAU,CAAC1H,YAAX,CAAyB2H,WAAzB,EAfI,CAiBJ;;;AACA,gBAAMrH,WAAW,GAAG,IAAI3G,QAAJ,CAAc0F,cAAc,CAACf,MAA7B,EAAqCmJ,WAArC,CAApB;AAEA,iBAAO,KAAKvJ,gBAAL,CAAuBoC,WAAvB,EAAoC+G,cAApC,CAAP;AACA;AACD;AACD;AAED;;;;;;;;;;;;;;AAYAnG,EAAAA,yBAAyB,CAAErE,OAAF,EAAY;AACpC;AACA,QAAK,CAACA,OAAO,CAAC+K,IAAR,CAAarJ,EAAb,CAAiB,aAAjB,CAAN,EAAyC;AACxC;AACA,KAJmC,CAMpC;AACA;;;AACA,QAAK1B,OAAO,CAAC0B,EAAR,CAAY,SAAZ,CAAL,EAA+B;AAC9B,WAAM,MAAM2G,KAAZ,IAAqBrI,OAAO,CAACoD,WAAR,EAArB,EAA6C;AAC5C,aAAKiB,yBAAL,CAAgCgE,KAAhC;AACA;AACD;;AAED,UAAMnJ,EAAE,GAAGc,OAAO,CAACd,EAAnB;;AAEA,QAAK,CAACA,EAAN,EAAW;AACV;AACA;;AAED,QAAI8L,KAAK,GAAG,KAAKlN,YAAL,CAAkBmN,GAAlB,CAAuB/L,EAAvB,CAAZ;;AAEA,QAAK,CAAC8L,KAAN,EAAc;AACbA,MAAAA,KAAK,GAAG,IAAIE,GAAJ,EAAR;;AACA,WAAKpN,YAAL,CAAkBqN,GAAlB,CAAuBjM,EAAvB,EAA2B8L,KAA3B;AACA;;AAEDA,IAAAA,KAAK,CAACI,GAAN,CAAWpL,OAAX;AACAA,IAAAA,OAAO,CAACqL,YAAR,GAAuBL,KAAvB;AACA;AAED;;;;;;;;;;;;;;AAYApI,EAAAA,8BAA8B,CAAE5C,OAAF,EAAY;AACzC;AACA;AACA,QAAKA,OAAO,CAAC0B,EAAR,CAAY,SAAZ,CAAL,EAA+B;AAC9B,WAAM,MAAM2G,KAAZ,IAAqBrI,OAAO,CAACoD,WAAR,EAArB,EAA6C;AAC5C,aAAKR,8BAAL,CAAqCyF,KAArC;AACA;AACD;;AAED,UAAMnJ,EAAE,GAAGc,OAAO,CAACd,EAAnB;;AAEA,QAAK,CAACA,EAAN,EAAW;AACV;AACA;;AAED,UAAM8L,KAAK,GAAG,KAAKlN,YAAL,CAAkBmN,GAAlB,CAAuB/L,EAAvB,CAAd;;AAEA,QAAK,CAAC8L,KAAN,EAAc;AACb;AACA;;AAEDA,IAAAA,KAAK,CAACzD,MAAN,CAAcvH,OAAd,EArByC,CAsBzC;AACA;AACA;;AA1oDkC,C,CA6oDpC;;AACA,SAASyG,iBAAT,CAA4BhF,MAA5B,EAAqC;AACpC,SAAO6I,KAAK,CAACC,IAAN,CAAY9I,MAAM,CAAC2B,WAAP,EAAZ,EAAmCkI,IAAnC,CAAyCjD,KAAK,IAAI,CAACA,KAAK,CAAC3G,EAAN,CAAU,WAAV,CAAnD,CAAP;AACA;AAED;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsC,kBAAT,CAA6BxC,QAA7B,EAAwC;AACvC,MAAIC,MAAM,GAAGD,QAAQ,CAACC,MAAtB;;AAEA,SAAQ,CAACkJ,qBAAqB,CAAElJ,MAAF,CAA9B,EAA2C;AAC1C,QAAK,CAACA,MAAN,EAAe;AACd,aAAOd,SAAP;AACA;;AACDc,IAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACA;;AAED,SAAOA,MAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmH,iBAAT,CAA4B2C,CAA5B,EAA+BC,CAA/B,EAAmC;AAClC,MAAKD,CAAC,CAACvM,QAAF,GAAawM,CAAC,CAACxM,QAApB,EAA+B;AAC9B,WAAO,IAAP;AACA,GAFD,MAEO,IAAKuM,CAAC,CAACvM,QAAF,GAAawM,CAAC,CAACxM,QAApB,EAA+B;AACrC,WAAO,KAAP;AACA,GALiC,CAOlC;;;AACA,SAAOuM,CAAC,CAACE,WAAF,KAAkBD,CAAC,CAACC,WAAF,EAAzB;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASrC,sBAAT,CAAiC5H,QAAjC,EAA4C;AAC3C,QAAMqB,UAAU,GAAGrB,QAAQ,CAACqB,UAA5B;;AAEA,MAAKA,UAAU,IAAIA,UAAU,CAACnB,EAAX,CAAe,MAAf,CAAnB,EAA6C;AAC5C,WAAO,IAAI5E,QAAJ,CAAc+F,UAAd,EAA0BA,UAAU,CAAClE,IAAX,CAAgBuF,MAA1C,CAAP;AACA;;AAED,QAAMnB,SAAS,GAAGvB,QAAQ,CAACuB,SAA3B;;AAEA,MAAKA,SAAS,IAAIA,SAAS,CAACrB,EAAV,CAAc,MAAd,CAAlB,EAA2C;AAC1C,WAAO,IAAI5E,QAAJ,CAAciG,SAAd,EAAyB,CAAzB,CAAP;AACA;;AAED,SAAOvB,QAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS6H,aAAT,CAAwB7H,QAAxB,EAAmC;AAClC,MAAKA,QAAQ,CAAChD,MAAT,IAAmBgD,QAAQ,CAACC,MAAT,CAAgB9C,IAAhB,CAAqBuF,MAA7C,EAAsD;AACrD,WAAO,IAAIpH,QAAJ,CAAc0E,QAAQ,CAACC,MAAT,CAAgBA,MAA9B,EAAsCD,QAAQ,CAACC,MAAT,CAAgBiB,KAAhB,GAAwB,CAA9D,CAAP;AACA;;AAED,MAAKlB,QAAQ,CAAChD,MAAT,KAAoB,CAAzB,EAA6B;AAC5B,WAAO,IAAI1B,QAAJ,CAAc0E,QAAQ,CAACC,MAAT,CAAgBA,MAA9B,EAAsCD,QAAQ,CAACC,MAAT,CAAgBiB,KAAtD,CAAP;AACA,GAPiC,CASlC;;;AACA,QAAMgJ,UAAU,GAAGlK,QAAQ,CAACC,MAAT,CAAgB9C,IAAhB,CAAqBgN,KAArB,CAA4BnK,QAAQ,CAAChD,MAArC,CAAnB,CAVkC,CAYlC;;AACAgD,EAAAA,QAAQ,CAACC,MAAT,CAAgBmK,KAAhB,GAAwBpK,QAAQ,CAACC,MAAT,CAAgB9C,IAAhB,CAAqBgN,KAArB,CAA4B,CAA5B,EAA+BnK,QAAQ,CAAChD,MAAxC,CAAxB,CAbkC,CAelC;;AACAgD,EAAAA,QAAQ,CAACC,MAAT,CAAgBA,MAAhB,CAAuB0C,YAAvB,CAAqC3C,QAAQ,CAACC,MAAT,CAAgBiB,KAAhB,GAAwB,CAA7D,EAAgE,IAAIlF,IAAJ,CAAUgE,QAAQ,CAACuJ,IAAT,CAAclN,QAAxB,EAAkC6N,UAAlC,CAAhE,EAhBkC,CAkBlC;;;AACA,SAAO,IAAI5O,QAAJ,CAAc0E,QAAQ,CAACC,MAAT,CAAgBA,MAA9B,EAAsCD,QAAQ,CAACC,MAAT,CAAgBiB,KAAhB,GAAwB,CAA9D,CAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,cAAT,CAAyB6I,EAAzB,EAA6BC,EAA7B,EAAkC;AACjC;AACA,QAAMC,gBAAgB,GAAGF,EAAE,CAAClN,IAAH,CAAQuF,MAAjC;AACA2H,EAAAA,EAAE,CAACD,KAAH,IAAYE,EAAE,CAACnN,IAAf;;AACAmN,EAAAA,EAAE,CAACnJ,OAAH;;AAEA,SAAO,IAAI7F,QAAJ,CAAc+O,EAAd,EAAkBE,gBAAlB,CAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASjI,qBAAT,CAAgCD,KAAhC,EAAuCmI,YAAvC,EAAsD;AACrD,OAAM,MAAM5H,IAAZ,IAAoBP,KAApB,EAA4B;AAC3B,QAAK,CAACoI,kBAAkB,CAACX,IAAnB,CAA2BY,SAAS,IAAI9H,IAAI,YAAY8H,SAAxD,CAAN,EAA8E;AAAE;;AAC/E;;;;;;;;AAQA,YAAM,IAAI7O,aAAJ,CAAmB,iCAAnB,EAAsD2O,YAAtD,CAAN;AACA;;AAED,QAAK,CAAC5H,IAAI,CAAC1C,EAAL,CAAS,MAAT,CAAN,EAA0B;AACzBoC,MAAAA,qBAAqB,CAAEM,IAAI,CAAChB,WAAL,EAAF,EAAsB4I,YAAtB,CAArB;AACA;AACD;AACD;;AAED,MAAMC,kBAAkB,GAAG,CAAEzO,IAAF,EAAQN,gBAAR,EAA0BD,gBAA1B,EAA4CE,YAA5C,EAA0DC,SAA1D,CAA3B,C,CAEA;AACA;AACA;AACA;;AACA,SAASuN,qBAAT,CAAgCvG,IAAhC,EAAuC;AACtC,SAAOA,IAAI,KAAMA,IAAI,CAAC1C,EAAL,CAAS,kBAAT,KAAiC0C,IAAI,CAAC1C,EAAL,CAAS,kBAAT,CAAvC,CAAX;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmD,sBAAT,CAAiCD,KAAjC,EAAwCoH,YAAxC,EAAuD;AACtD,QAAMG,cAAc,GAAGnI,kBAAkB,CAAEY,KAAK,CAACJ,KAAR,CAAzC;AACA,QAAM4H,YAAY,GAAGpI,kBAAkB,CAAEY,KAAK,CAACF,GAAR,CAAvC;;AAEA,MAAK,CAACyH,cAAD,IAAmB,CAACC,YAApB,IAAoCD,cAAc,KAAKC,YAA5D,EAA2E;AAC1E;;;;;;;AAQA,UAAM,IAAI/O,aAAJ,CAAmB,qCAAnB,EAA0D2O,YAA1D,CAAN;AACA;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASpC,WAAT,CAAsB2B,CAAtB,EAAyBC,CAAzB,EAA6B;AAC5B,SAAOD,CAAC,CAACrM,EAAF,KAAS,IAAT,IAAiBsM,CAAC,CAACtM,EAAF,KAAS,IAAjC;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/downcastwriter\n */\n\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\nexport default class DowncastWriter {\n\t/**\n\t * @param {module:engine/view/document~Document} document The view document instance.\n\t */\n\tconstructor( document ) {\n\t\t/**\n\t\t * The view document instance in which this writer operates.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t\t * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<String,Set>}\n\t\t */\n\t\tthis._cloneGroups = new Map();\n\t}\n\n\t/**\n\t * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n\t * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n\t *\n\t * Usage:\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets backward selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t * \t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t * \t\t// Removes all ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t *\t\t// Sets selection as fake.\n\t *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * \t\t// represented in other way, for example by applying proper CSS class.\n\t *\t\twriter.setSelection( range, { fake: true } );\n\t *\n\t * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * \t\t// (and be  properly handled by screen readers).\n\t *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n\t * parameters.\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\n\t * @param {String} data The text's data.\n\t * @returns {module:engine/view/text~Text} The created text node.\n\t */\n\tcreateText( data ) {\n\t\treturn new Text( this.document, data );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/attributeelement~AttributeElement}.\n\t *\n\t *\t\twriter.createAttributeElement( 'strong' );\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n\t *\n\t *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n\t *\n\t *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n\t *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Element's attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n\t * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n\t */\n\tcreateAttributeElement( name, attributes, options = {} ) {\n\t\tconst attributeElement = new AttributeElement( this.document, name, attributes );\n\n\t\tif ( options.priority ) {\n\t\t\tattributeElement._priority = options.priority;\n\t\t}\n\n\t\tif ( options.id ) {\n\t\t\tattributeElement._id = options.id;\n\t\t}\n\n\t\treturn attributeElement;\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/containerelement~ContainerElement}.\n\t *\n\t *\t\twriter.createContainerElement( 'p' );\n\t *\n\t *\t\t// Create element with custom attributes.\n\t *\t\twriter.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );\n\t *\n\t *\t\t// Create element with custom styles.\n\t *\t\twriter.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );\n\t *\n\t *\t\t// Create element with custom classes.\n\t *\t\twriter.createContainerElement( 'p', { class: 'foo bar baz' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n\t */\n\tcreateContainerElement( name, attributes ) {\n\t\treturn new ContainerElement( this.document, name, attributes );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t *\t\twriter.createEditableElement( 'div' );\n\t *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/editableelement~EditableElement} Created element.\n\t */\n\tcreateEditableElement( name, attributes ) {\n\t\tconst editableElement = new EditableElement( this.document, name, attributes );\n\t\teditableElement._document = this.document;\n\n\t\treturn editableElement;\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/emptyelement~EmptyElement}.\n\t *\n\t *\t\twriter.createEmptyElement( 'img' );\n\t *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n\t */\n\tcreateEmptyElement( name, attributes ) {\n\t\treturn new EmptyElement( this.document, name, attributes );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/uielement~UIElement}.\n\t *\n\t *\t\twriter.createUIElement( 'span' );\n\t *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n\t *\n\t * Custom render function can be provided as third parameter:\n\t *\n\t *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n\t *\t\t\tconst domElement = this.toDomElement( domDocument );\n\t *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n\t *\n\t *\t\t\treturn domElement;\n\t *\t\t} );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {Function} [renderFunction] Custom render function.\n\t * @returns {module:engine/view/uielement~UIElement} Created element.\n\t */\n\tcreateUIElement( name, attributes, renderFunction ) {\n\t\tconst uiElement = new UIElement( this.document, name, attributes );\n\n\t\tif ( renderFunction ) {\n\t\t\tuiElement.render = renderFunction;\n\t\t}\n\n\t\treturn uiElement;\n\t}\n\n\t/**\n\t * Adds or overwrite element's attribute with a specified key and value.\n\t *\n\t *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {String} value Attribute value.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetAttribute( key, value, element ) {\n\t\telement._setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes attribute from the element.\n\t *\n\t *\t\twriter.removeAttribute( 'href', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveAttribute( key, element ) {\n\t\telement._removeAttribute( key );\n\t}\n\n\t/**\n\t * Adds specified class to the element.\n\t *\n\t *\t\twriter.addClass( 'foo', linkElement );\n\t *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\taddClass( className, element ) {\n\t\telement._addClass( className );\n\t}\n\n\t/**\n\t * Removes specified class from the element.\n\t *\n\t *\t\twriter.removeClass( 'foo', linkElement );\n\t *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveClass( className, element ) {\n\t\telement._removeClass( className );\n\t}\n\n\t/**\n\t * Adds style to the element.\n\t *\n\t *\t\twriter.setStyle( 'color', 'red', element );\n\t *\t\twriter.setStyle( {\n\t *\t\t\tcolor: 'red',\n\t *\t\t\tposition: 'fixed'\n\t *\t\t}, element );\n\t *\n\t * **Note**: The passed style can be normalized if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n\t *\n\t * @param {String|Object} property Property name or object with key - value pairs.\n\t * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n\t * @param {module:engine/view/element~Element} element Element to set styles on.\n\t */\n\tsetStyle( property, value, element ) {\n\t\tif ( isPlainObject( property ) && element === undefined ) {\n\t\t\telement = value;\n\t\t}\n\n\t\telement._setStyle( property, value );\n\t}\n\n\t/**\n\t * Removes specified style from the element.\n\t *\n\t *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n\t *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n\t *\n\t * **Note**: This method can work with normalized style names if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n\t *\n\t * @param {Array.<String>|String} property\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveStyle( property, element ) {\n\t\telement._removeStyle( property );\n\t}\n\n\t/**\n\t * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n\t * so they can be used to add special data to elements.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {*} value\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetCustomProperty( key, value, element ) {\n\t\telement._setCustomProperty( key, value );\n\t}\n\n\t/**\n\t * Removes a custom property stored under the given key.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean} Returns true if property was removed.\n\t */\n\tremoveCustomProperty( key, element ) {\n\t\treturn element._removeCustomProperty( key );\n\t}\n\n\t/**\n\t * Breaks attribute nodes at provided position or at boundaries of provided range. It breaks attribute elements inside\n\t * up to a container element.\n\t *\n\t * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:\n\t *\n\t *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n\t *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n\t *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n\t *\n\t * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start start}\n\t * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element`\n\t * when trying to break attributes\n\t * inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element`\n\t * when trying to break attributes\n\t * inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n\t * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange Position where\n\t * to break attribute elements.\n\t * @returns {module:engine/view/position~Position|module:engine/view/range~Range} New position or range, after breaking the attribute\n\t * elements.\n\t */\n\tbreakAttributes( positionOrRange ) {\n\t\tif ( positionOrRange instanceof Position ) {\n\t\t\treturn this._breakAttributes( positionOrRange );\n\t\t} else {\n\t\t\treturn this._breakAttributesRange( positionOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Breaks {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position. Position\n\t * has to be directly inside container element and cannot be in root. Does not break if position is at the beginning\n\t * or at the end of it's parent element.\n\t *\n\t *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n\t *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n\t *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n\t *\t\t<p>foobar^</p> -> <p>foobar</p>^\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n\t * @param {module:engine/view/position~Position} position Position where to break element.\n\t * @returns {module:engine/view/position~Position} Position between broken elements. If element has not been broken,\n\t * the returned position is placed either before it or after it.\n\t */\n\tbreakContainer( position ) {\n\t\tconst element = position.parent;\n\n\t\tif ( !( element.is( 'containerElement' ) ) ) {\n\t\t\t/**\n\t\t\t * Trying to break an element which is not a container element.\n\t\t\t *\n\t\t\t * @error view-writer-break-non-container-element\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-break-non-container-element: Trying to break an element which is not a container element.',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tif ( !element.parent ) {\n\t\t\t/**\n\t\t\t * Trying to break root element.\n\t\t\t *\n\t\t\t * @error view-writer-break-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-break-root: Trying to break root element.', this.document );\n\t\t}\n\n\t\tif ( position.isAtStart ) {\n\t\t\treturn Position._createBefore( element );\n\t\t} else if ( !position.isAtEnd ) {\n\t\t\tconst newElement = element._clone( false );\n\n\t\t\tthis.insert( Position._createAfter( element ), newElement );\n\n\t\t\tconst sourceRange = new Range( position, Position._createAt( element, 'end' ) );\n\t\t\tconst targetPosition = new Position( newElement, 0 );\n\n\t\t\tthis.move( sourceRange, targetPosition );\n\t\t}\n\n\t\treturn Position._createAfter( element );\n\t}\n\n\t/**\n\t * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n\t * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n\t *\n\t * In following examples `<p>` is a container and `<b>` is an attribute element:\n\t *\n\t *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n\t *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n\t *\n\t * It will also take care about empty attributes when merging:\n\t *\n\t *\t\t<p><b>[]</b></p> -> <p>[]</p>\n\t *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeAttributes( position ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// When inside text node - nothing to merge.\n\t\tif ( positionParent.is( 'text' ) ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When inside empty attribute - remove it.\n\t\tif ( positionParent.is( 'attributeElement' ) && positionParent.childCount === 0 ) {\n\t\t\tconst parent = positionParent.parent;\n\t\t\tconst offset = positionParent.index;\n\n\t\t\tpositionParent._remove();\n\t\t\tthis._removeFromClonedElementsGroup( positionParent );\n\n\t\t\treturn this.mergeAttributes( new Position( parent, offset ) );\n\t\t}\n\n\t\tconst nodeBefore = positionParent.getChild( positionOffset - 1 );\n\t\tconst nodeAfter = positionParent.getChild( positionOffset );\n\n\t\t// Position should be placed between two nodes.\n\t\tif ( !nodeBefore || !nodeAfter ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When position is between two text nodes.\n\t\tif ( nodeBefore.is( 'text' ) && nodeAfter.is( 'text' ) ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\t\t// When position is between two same attribute elements.\n\t\telse if ( nodeBefore.is( 'attributeElement' ) && nodeAfter.is( 'attributeElement' ) && nodeBefore.isSimilar( nodeAfter ) ) {\n\t\t\t// Move all children nodes from node placed after selection and remove that node.\n\t\t\tconst count = nodeBefore.childCount;\n\t\t\tnodeBefore._appendChild( nodeAfter.getChildren() );\n\n\t\t\tnodeAfter._remove();\n\t\t\tthis._removeFromClonedElementsGroup( nodeAfter );\n\n\t\t\t// New position is located inside the first node, before new nodes.\n\t\t\t// Call this method recursively to merge again if needed.\n\t\t\treturn this.mergeAttributes( new Position( nodeBefore, count ) );\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n\t * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n\t *\n\t *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n\t *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeContainers( position ) {\n\t\tconst prev = position.nodeBefore;\n\t\tconst next = position.nodeAfter;\n\n\t\tif ( !prev || !next || !prev.is( 'containerElement' ) || !next.is( 'containerElement' ) ) {\n\t\t\t/**\n\t\t\t * Element before and after given position cannot be merged.\n\t\t\t *\n\t\t\t * @error view-writer-merge-containers-invalid-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-merge-containers-invalid-position: ' +\n\t\t\t\t'Element before and after given position cannot be merged.', this.document );\n\t\t}\n\n\t\tconst lastChild = prev.getChild( prev.childCount - 1 );\n\t\tconst newPosition = lastChild instanceof Text ? Position._createAt( lastChild, 'end' ) : Position._createAt( prev, 'end' );\n\n\t\tthis.move( Range._createIn( next ), Position._createAt( prev, 'end' ) );\n\t\tthis.remove( Range._createOn( next ) );\n\n\t\treturn newPosition;\n\t}\n\n\t/**\n\t * Insert node or nodes at specified position. Takes care about breaking attributes before insertion\n\t * and merging them afterwards.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n\t * contains instances that are not {@link module:engine/view/text~Text Texts},\n\t * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n\t * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElements} or\n\t * {@link module:engine/view/uielement~UIElement UIElements}.\n\t *\n\t * @param {module:engine/view/position~Position} position Insertion position.\n\t * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n\t * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n\t * module:engine/view/uielement~UIElement|Iterable.<module:engine/view/text~Text|\n\t * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n\t * module:engine/view/emptyelement~EmptyElement|module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n\t * @returns {module:engine/view/range~Range} Range around inserted nodes.\n\t */\n\tinsert( position, nodes ) {\n\t\tnodes = isIterable( nodes ) ? [ ...nodes ] : [ nodes ];\n\n\t\t// Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\t\tvalidateNodesToInsert( nodes, this.document );\n\n\t\tconst container = getParentContainer( position );\n\n\t\tif ( !container ) {\n\t\t\t/**\n\t\t\t * Position's parent container cannot be found.\n\t\t\t *\n\t\t\t * @error view-writer-invalid-position-container\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-invalid-position-container', this.document );\n\t\t}\n\n\t\tconst insertionPosition = this._breakAttributes( position, true );\n\t\tconst length = container._insertChild( insertionPosition.offset, nodes );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tthis._addToClonedElementsGroup( node );\n\t\t}\n\n\t\tconst endPosition = insertionPosition.getShiftedBy( length );\n\t\tconst start = this.mergeAttributes( insertionPosition );\n\n\t\t// When no nodes were inserted - return collapsed range.\n\t\tif ( length === 0 ) {\n\t\t\treturn new Range( start, start );\n\t\t} else {\n\t\t\t// If start position was merged - move end position.\n\t\t\tif ( !start.isEqual( insertionPosition ) ) {\n\t\t\t\tendPosition.offset--;\n\t\t\t}\n\n\t\t\tconst end = this.mergeAttributes( endPosition );\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\t}\n\n\t/**\n\t * Removes provided range from the container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n\t * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n\t * to a collapsed range showing the new position.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n\t */\n\tremove( rangeOrItem ) {\n\t\tconst range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn( rangeOrItem );\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to remove.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn new DocumentFragment( this.document );\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\tconst count = breakEnd.offset - breakStart.offset;\n\n\t\t// Remove nodes in range.\n\t\tconst removed = parentContainer._removeChildren( breakStart.offset, count );\n\n\t\tfor ( const node of removed ) {\n\t\t\tthis._removeFromClonedElementsGroup( node );\n\t\t}\n\n\t\t// Merge after removing.\n\t\tconst mergePosition = this.mergeAttributes( breakStart );\n\t\trange.start = mergePosition;\n\t\trange.end = mergePosition.clone();\n\n\t\t// Return removed nodes.\n\t\treturn new DocumentFragment( this.document, removed );\n\t}\n\n\t/**\n\t * Removes matching elements from given range.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to clear.\n\t * @param {module:engine/view/element~Element} element Element to remove.\n\t */\n\tclear( range, element ) {\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Create walker on given range.\n\t\t// We walk backward because when we remove element during walk it modifies range end position.\n\t\tconst walker = range.getWalker( {\n\t\t\tdirection: 'backward',\n\t\t\tignoreElementEnd: true\n\t\t} );\n\n\t\t// Let's walk.\n\t\tfor ( const current of walker ) {\n\t\t\tconst item = current.item;\n\t\t\tlet rangeToRemove;\n\n\t\t\t// When current item matches to the given element.\n\t\t\tif ( item.is( 'element' ) && element.isSimilar( item ) ) {\n\t\t\t\t// Create range on this element.\n\t\t\t\trangeToRemove = Range._createOn( item );\n\t\t\t\t// When range starts inside Text or TextProxy element.\n\t\t\t} else if ( !current.nextPosition.isAfter( range.start ) && item.is( 'textProxy' ) ) {\n\t\t\t\t// We need to check if parent of this text matches to given element.\n\t\t\t\tconst parentElement = item.getAncestors().find( ancestor => {\n\t\t\t\t\treturn ancestor.is( 'element' ) && element.isSimilar( ancestor );\n\t\t\t\t} );\n\n\t\t\t\t// If it is then create range inside this element.\n\t\t\t\tif ( parentElement ) {\n\t\t\t\t\trangeToRemove = Range._createIn( parentElement );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have found element to remove.\n\t\t\tif ( rangeToRemove ) {\n\t\t\t\t// We need to check if element range stick out of the given range and truncate if it is.\n\t\t\t\tif ( rangeToRemove.end.isAfter( range.end ) ) {\n\t\t\t\t\trangeToRemove.end = range.end;\n\t\t\t\t}\n\n\t\t\t\tif ( rangeToRemove.start.isBefore( range.start ) ) {\n\t\t\t\t\trangeToRemove.start = range.start;\n\t\t\t\t}\n\n\t\t\t\t// At the end we remove range with found element.\n\t\t\t\tthis.remove( rangeToRemove );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves nodes from provided range to target position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n\t * @param {module:engine/view/position~Position} targetPosition Position to insert.\n\t * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n\t */\n\tmove( sourceRange, targetPosition ) {\n\t\tlet nodes;\n\n\t\tif ( targetPosition.isAfter( sourceRange.end ) ) {\n\t\t\ttargetPosition = this._breakAttributes( targetPosition, true );\n\n\t\t\tconst parent = targetPosition.parent;\n\t\t\tconst countBefore = parent.childCount;\n\n\t\t\tsourceRange = this._breakAttributesRange( sourceRange, true );\n\n\t\t\tnodes = this.remove( sourceRange );\n\n\t\t\ttargetPosition.offset += ( parent.childCount - countBefore );\n\t\t} else {\n\t\t\tnodes = this.remove( sourceRange );\n\t\t}\n\n\t\treturn this.insert( targetPosition, nodes );\n\t}\n\n\t/**\n\t * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n\t *\n\t * If a collapsed range was passed and is same as selection, the selection\n\t * will be moved to the inside of the wrapped attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start}\n\t * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n\t * is collapsed and different than view selection.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to wrap.\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n\t * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n\t*/\n\twrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\tthrow new CKEditorError( 'view-writer-wrap-invalid-attribute', this.document );\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\tif ( !range.isCollapsed ) {\n\t\t\t// Non-collapsed range. Wrap it with the attribute element.\n\t\t\treturn this._wrapRange( range, attribute );\n\t\t} else {\n\t\t\t// Collapsed range. Wrap position.\n\t\t\tlet position = range.start;\n\n\t\t\tif ( position.parent.is( 'element' ) && !_hasNonUiChildren( position.parent ) ) {\n\t\t\t\tposition = position.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );\n\t\t\t}\n\n\t\t\tposition = this._wrapPosition( position, attribute );\n\t\t\tconst viewSelection = this.document.selection;\n\n\t\t\t// If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\t\t\tif ( viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual( range.start ) ) {\n\t\t\t\tthis.setSelection( position );\n\t\t\t}\n\n\t\t\treturn new Range( position );\n\t\t}\n\t}\n\n\t/**\n\t * Unwraps nodes within provided range from attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t */\n\tunwrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\t/**\n\t\t\t * Attribute element need to be instance of attribute element.\n\t\t\t *\n\t\t\t * @error view-writer-unwrap-invalid-attribute\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-unwrap-invalid-attribute', this.document );\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to unwrap.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn range;\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Unwrap children located between break points.\n\t\tconst newRange = this._unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n\t * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n\t * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n\t *\n\t * New element has to be created because `Element#tagName` property in DOM is readonly.\n\t *\n\t * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n\t *\n\t * @param {String} newName New name for element.\n\t * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n\t */\n\trename( newName, viewElement ) {\n\t\tconst newElement = new ContainerElement( this.document, newName, viewElement.getAttributes() );\n\n\t\tthis.insert( Position._createAfter( viewElement ), newElement );\n\t\tthis.move( Range._createIn( viewElement ), Position._createAt( newElement, 0 ) );\n\t\tthis.remove( Range._createOn( viewElement ) );\n\n\t\treturn newElement;\n\t}\n\n\t/**\n\t * Cleans up memory by removing obsolete cloned elements group from the writer.\n\t *\n\t * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n\t * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n\t * the group will no longer be needed.\n\t *\n\t * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n\t * were removed from the view.\n\t *\n\t * Keep in mind that group names are equal to the `id` property of the attribute element.\n\t *\n\t * @param {String} groupName Name of the group to clear.\n\t */\n\tclearClonedElementsGroup( groupName ) {\n\t\tthis._cloneGroups.delete( groupName );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/view/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n\t *\n\t * This method is a shortcut to other constructors such as:\n\t *\n\t * * {@link #createPositionBefore},\n\t * * {@link #createPositionAfter},\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn Position._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item after which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn Position._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item before which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn Position._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn Range._createOn( item );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn Range._createIn( element );\n\t}\n\n\t/**\n\t Creates new {@link module:engine/view/selection~Selection} instance.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the document selection.\n\t *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} [selectable=null]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t * @returns {module:engine/view/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new Selection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be wrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} wrapElement\n\t */\n\t_wrapChildren( parent, startOffset, endOffset, wrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst wrapPositions = [];\n\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\t\t\tconst isText = child.is( 'text' );\n\t\t\tconst isAttribute = child.is( 'attributeElement' );\n\t\t\tconst isEmpty = child.is( 'emptyElement' );\n\t\t\tconst isUI = child.is( 'uiElement' );\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n\t\t\t// If possible, join elements.\n\t\t\t//\n\t\t\t// <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n\t\t\t//\n\t\t\tif ( isAttribute && this._wrapAttributeElement( wrapElement, child ) ) {\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n\t\t\t// `wrapElement` (due to priority).\n\t\t\t//\n\t\t\t// <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n\t\t\t// <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n\t\t\t//\n\t\t\telse if ( isText || isEmpty || isUI || ( isAttribute && shouldABeOutsideB( wrapElement, child ) ) ) {\n\t\t\t\t// Clone attribute.\n\t\t\t\tconst newAttribute = wrapElement._clone();\n\n\t\t\t\t// Wrap current node with new attribute.\n\t\t\t\tchild._remove();\n\t\t\t\tnewAttribute._appendChild( child );\n\n\t\t\t\tparent._insertChild( i, newAttribute );\n\t\t\t\tthis._addToClonedElementsGroup( newAttribute );\n\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n\t\t\t//\n\t\t\t// <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n\t\t\t//\n\t\t\telse if ( isAttribute ) {\n\t\t\t\tthis._wrapChildren( child, 0, child.childCount, wrapElement );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each wrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of wrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} unwrapElement\n\t */\n\t_unwrapChildren( parent, startOffset, endOffset, unwrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst unwrapPositions = [];\n\n\t\t// Iterate over each element between provided offsets inside parent.\n\t\t// We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n\t\t// so it could get messy. It is safer to it manually in this case.\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\n\t\t\t// Skip all text nodes. There should be no container element's here either.\n\t\t\tif ( !child.is( 'attributeElement' ) ) {\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n\t\t\t//\n\t\t\t// <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n\t\t\t//\n\t\t\tif ( child.isSimilar( unwrapElement ) ) {\n\t\t\t\tconst unwrapped = child.getChildren();\n\t\t\t\tconst count = child.childCount;\n\n\t\t\t\t// Replace wrapper element with its children\n\t\t\t\tchild._remove();\n\t\t\t\tparent._insertChild( i, unwrapped );\n\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\n\t\t\t\t// Save start and end position of moved items.\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + count )\n\t\t\t\t);\n\n\t\t\t\t// Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n\t\t\t\ti += count;\n\t\t\t\tendOffset += count - 1;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n\t\t\t// Partial unwrapping will happen only if the elements have the same name.\n\t\t\t//\n\t\t\t// <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n\t\t\t// <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n\t\t\t//\n\t\t\tif ( this._unwrapAttributeElement( unwrapElement, child ) ) {\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + 1 )\n\t\t\t\t);\n\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If other nested attribute is found, look through it's children for elements to unwrap.\n\t\t\t//\n\t\t\t// <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n\t\t\t//\n\t\t\tthis._unwrapChildren( child, 0, child.childCount, unwrapElement );\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each unwrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of unwrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset || position.offset == endOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n\t */\n\t_wrapRange( range, attribute ) {\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Wrap all children with attribute.\n\t\tconst newRange = this._wrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/position~Position} New position after wrapping.\n\t */\n\t_wrapPosition( position, attribute ) {\n\t\t// Return same position when trying to wrap with attribute similar to position parent.\n\t\tif ( attribute.isSimilar( position.parent ) ) {\n\t\t\treturn movePositionToTextNode( position.clone() );\n\t\t}\n\n\t\t// When position is inside text node - break it and place new position between two text nodes.\n\t\tif ( position.parent.is( 'text' ) ) {\n\t\t\tposition = breakTextNode( position );\n\t\t}\n\n\t\t// Create fake element that will represent position, and will not be merged with other attributes.\n\t\tconst fakePosition = this.createAttributeElement();\n\t\tfakePosition._priority = Number.POSITIVE_INFINITY;\n\t\tfakePosition.isSimilar = () => false;\n\n\t\t// Insert fake element in position location.\n\t\tposition.parent._insertChild( position.offset, fakePosition );\n\n\t\t// Range around inserted fake attribute element.\n\t\tconst wrapRange = new Range( position, position.getShiftedBy( 1 ) );\n\n\t\t// Wrap fake element with attribute (it will also merge if possible).\n\t\tthis.wrap( wrapRange, attribute );\n\n\t\t// Remove fake element and place new position there.\n\t\tconst newPosition = new Position( fakePosition.parent, fakePosition.index );\n\t\tfakePosition._remove();\n\n\t\t// If position is placed between text nodes - merge them and return position inside.\n\t\tconst nodeBefore = newPosition.nodeBefore;\n\t\tconst nodeAfter = newPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof Text && nodeAfter instanceof Text ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\n\t\t// If position is next to text node - move position inside.\n\t\treturn movePositionToTextNode( newPosition );\n\t}\n\n\t/**\n\t * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n\t * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n\t * \telement to element being wrapped.\n\t *\n\t * \t@private\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n\t * \t@returns {Boolean} Returns `true` if elements are merged.\n\t */\n\t_wrapAttributeElement( wrapper, toWrap ) {\n\t\tif ( !canBeJoined( wrapper, toWrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't merge if name or priority differs.\n\t\tif ( wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if attributes can be merged.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are different we cannot wrap.\n\t\t\tif ( toWrap.hasAttribute( key ) && toWrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if styles can be merged.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( toWrap.hasStyle( key ) && toWrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Move only these attributes that are not present - other are similar.\n\t\t\tif ( !toWrap.hasAttribute( key ) ) {\n\t\t\t\tthis.setAttribute( key, wrapper.getAttribute( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( !toWrap.hasStyle( key ) ) {\n\t\t\t\tthis.setStyle( key, wrapper.getStyle( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getClassNames() ) {\n\t\t\tif ( !toWrap.hasClass( key ) ) {\n\t\t\t\tthis.addClass( key, toWrap );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n\t * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n\t * inside element being unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n\t * @returns {Boolean} Returns `true` if elements are unwrapped.\n\t **/\n\t_unwrapAttributeElement( wrapper, toUnwrap ) {\n\t\tif ( !canBeJoined( wrapper, toUnwrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't unwrap if name or priority differs.\n\t\tif ( wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper attributes.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasAttribute( key ) || toUnwrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper classes.\n\t\tif ( !toUnwrap.hasClass( ...wrapper.getClassNames() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper styles.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\t// If some styles are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasStyle( key ) || toUnwrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Remove all wrapper's attributes from unwrapped element.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.removeAttribute( key, toUnwrap );\n\t\t}\n\n\t\t// Remove all wrapper's classes from unwrapped element.\n\t\tthis.removeClass( Array.from( wrapper.getClassNames() ), toUnwrap );\n\n\t\t// Remove all wrapper's styles from unwrapped element.\n\t\tthis.removeStyle( Array.from( wrapper.getStyleNames() ), toUnwrap );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/range~Range} New range with located at break positions.\n\t */\n\t_breakAttributesRange( range, forceSplitText = false ) {\n\t\tconst rangeStart = range.start;\n\t\tconst rangeEnd = range.end;\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Break at the collapsed position. Return new collapsed range.\n\t\tif ( range.isCollapsed ) {\n\t\t\tconst position = this._breakAttributes( range.start, forceSplitText );\n\n\t\t\treturn new Range( position, position );\n\t\t}\n\n\t\tconst breakEnd = this._breakAttributes( rangeEnd, forceSplitText );\n\t\tconst count = breakEnd.parent.childCount;\n\t\tconst breakStart = this._breakAttributes( rangeStart, forceSplitText );\n\n\t\t// Calculate new break end offset.\n\t\tbreakEnd.offset += breakEnd.parent.childCount - count;\n\n\t\treturn new Range( breakStart, breakEnd );\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n\t * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n\t * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position Position where to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n\t */\n\t_breakAttributes( position, forceSplitText = false ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'emptyElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break inside EmptyElement instance.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-empty-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-empty-element', this.document );\n\t\t}\n\n\t\t// If position is placed inside UIElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'uiElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break inside UIElement instance.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-ui-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-ui-element', this.document );\n\t\t}\n\n\t\t// There are no attributes to break and text nodes breaking is not forced.\n\t\tif ( !forceSplitText && positionParent.is( 'text' ) && isContainerOrFragment( positionParent.parent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Position's parent is container, so no attributes to break.\n\t\tif ( isContainerOrFragment( positionParent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Break text and start again in new position.\n\t\tif ( positionParent.is( 'text' ) ) {\n\t\t\treturn this._breakAttributes( breakTextNode( position ), forceSplitText );\n\t\t}\n\n\t\tconst length = positionParent.childCount;\n\n\t\t// <p>foo<b><u>bar{}</u></b></p>\n\t\t// <p>foo<b><u>bar</u>[]</b></p>\n\t\t// <p>foo<b><u>bar</u></b>[]</p>\n\t\tif ( positionOffset == length ) {\n\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index + 1 );\n\n\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t} else {\n\t\t\t// <p>foo<b><u>{}bar</u></b></p>\n\t\t\t// <p>foo<b>[]<u>bar</u></b></p>\n\t\t\t// <p>foo{}<b><u>bar</u></b></p>\n\t\t\tif ( positionOffset === 0 ) {\n\t\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t\t// <p>foo<b><u>b{}ar</u></b></p>\n\t\t\t// <p>foo<b><u>b[]ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t\t\telse {\n\t\t\t\tconst offsetAfter = positionParent.index + 1;\n\n\t\t\t\t// Break element.\n\t\t\t\tconst clonedNode = positionParent._clone();\n\n\t\t\t\t// Insert cloned node to position's parent node.\n\t\t\t\tpositionParent.parent._insertChild( offsetAfter, clonedNode );\n\t\t\t\tthis._addToClonedElementsGroup( clonedNode );\n\n\t\t\t\t// Get nodes to move.\n\t\t\t\tconst count = positionParent.childCount - positionOffset;\n\t\t\t\tconst nodesToMove = positionParent._removeChildren( positionOffset, count );\n\n\t\t\t\t// Move nodes to cloned node.\n\t\t\t\tclonedNode._appendChild( nodesToMove );\n\n\t\t\t\t// Create new position to work on.\n\t\t\t\tconst newPosition = new Position( positionParent.parent, offsetAfter );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n\t * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n\t * from the group now keep a reference to the given attribute element.\n\t *\n\t * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n\t *\n\t * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n\t */\n\t_addToClonedElementsGroup( element ) {\n\t\t// Add only if the element is in document tree.\n\t\tif ( !element.root.is( 'rootElement' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Traverse the element's children recursively to find other attribute elements that also might got inserted.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._addToClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\tgroup = new Set();\n\t\t\tthis._cloneGroups.set( id, group );\n\t\t}\n\n\t\tgroup.add( element );\n\t\telement._clonesGroup = group;\n\t}\n\n\t/**\n\t * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n\t * from its clones group.\n\t *\n\t * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n\t * This allows to reference the whole group even if the element was already removed from the tree.\n\t *\n\t * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n\t */\n\t_removeFromClonedElementsGroup( element ) {\n\t\t// Traverse the element's children recursively to find other attribute elements that also got removed.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\treturn;\n\t\t}\n\n\t\tgroup.delete( element );\n\t\t// Not removing group from element on purpose!\n\t\t// If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n\t}\n}\n\n// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\nfunction _hasNonUiChildren( parent ) {\n\treturn Array.from( parent.getChildren() ).some( child => !child.is( 'uiElement' ) );\n}\n\n/**\n * Attribute element need to be instance of attribute element.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\nfunction getParentContainer( position ) {\n\tlet parent = position.parent;\n\n\twhile ( !isContainerOrFragment( parent ) ) {\n\t\tif ( !parent ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\n\treturn parent;\n}\n\n// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped otuside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\nfunction shouldABeOutsideB( a, b ) {\n\tif ( a.priority < b.priority ) {\n\t\treturn true;\n\t} else if ( a.priority > b.priority ) {\n\t\treturn false;\n\t}\n\n\t// When priorities are equal and names are different - use identities.\n\treturn a.getIdentity() < b.getIdentity();\n}\n\n// Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\nfunction movePositionToTextNode( position ) {\n\tconst nodeBefore = position.nodeBefore;\n\n\tif ( nodeBefore && nodeBefore.is( 'text' ) ) {\n\t\treturn new Position( nodeBefore, nodeBefore.data.length );\n\t}\n\n\tconst nodeAfter = position.nodeAfter;\n\n\tif ( nodeAfter && nodeAfter.is( 'text' ) ) {\n\t\treturn new Position( nodeAfter, 0 );\n\t}\n\n\treturn position;\n}\n\n// Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\nfunction breakTextNode( position ) {\n\tif ( position.offset == position.parent.data.length ) {\n\t\treturn new Position( position.parent.parent, position.parent.index + 1 );\n\t}\n\n\tif ( position.offset === 0 ) {\n\t\treturn new Position( position.parent.parent, position.parent.index );\n\t}\n\n\t// Get part of the text that need to be moved.\n\tconst textToMove = position.parent.data.slice( position.offset );\n\n\t// Leave rest of the text in position's parent.\n\tposition.parent._data = position.parent.data.slice( 0, position.offset );\n\n\t// Insert new text node after position's parent text node.\n\tposition.parent.parent._insertChild( position.parent.index + 1, new Text( position.root.document, textToMove ) );\n\n\t// Return new position between two newly created text nodes.\n\treturn new Position( position.parent.parent, position.parent.index + 1 );\n}\n\n// Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\nfunction mergeTextNodes( t1, t2 ) {\n\t// Merge text data into first text node and remove second one.\n\tconst nodeBeforeLength = t1.data.length;\n\tt1._data += t2.data;\n\tt2._remove();\n\n\treturn new Position( t1, nodeBeforeLength );\n}\n\n// Checks if provided nodes are valid to insert. Checks if each node is an instance of\n// {@link module:engine/view/text~Text Text} or {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n// {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElement} or\n// {@link module:engine/view/uielement~UIElement UIElement}.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not {@link module:engine/view/text~Text Texts},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n// {@link module:engine/view/uielement~UIElement UIElements},\n// {@link module:engine/view/attributeelement~AttributeElement AttributeElements} or\n// {@link module:engine/view/containerelement~ContainerElement ContainerElements}.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement\n// |module:engine/view/containerelement~ContainerElement> nodes\n// @param {Object} errorContext\nfunction validateNodesToInsert( nodes, errorContext ) {\n\tfor ( const node of nodes ) {\n\t\tif ( !validNodesToInsert.some( ( validNode => node instanceof validNode ) ) ) { // eslint-disable-line no-use-before-define\n\t\t\t/**\n\t\t\t * Inserted nodes should be valid to insert. of {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n\t\t\t * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n\t\t\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n\t\t\t * {@link module:engine/view/uielement~UIElement UIElement}, {@link module:engine/view/text~Text Text}.\n\t\t\t *\n\t\t\t * @error view-writer-insert-invalid-node\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-insert-invalid-node', errorContext );\n\t\t}\n\n\t\tif ( !node.is( 'text' ) ) {\n\t\t\tvalidateNodesToInsert( node.getChildren(), errorContext );\n\t\t}\n\t}\n}\n\nconst validNodesToInsert = [ Text, AttributeElement, ContainerElement, EmptyElement, UIElement ];\n\n// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\nfunction isContainerOrFragment( node ) {\n\treturn node && ( node.is( 'containerElement' ) || node.is( 'documentFragment' ) );\n}\n\n// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\nfunction validateRangeContainer( range, errorContext ) {\n\tconst startContainer = getParentContainer( range.start );\n\tconst endContainer = getParentContainer( range.end );\n\n\tif ( !startContainer || !endContainer || startContainer !== endContainer ) {\n\t\t/**\n\t\t * Range container is invalid. This can happen if {@link module:engine/view/range~Range#start range start} and\n\t\t * {@link module:engine/view/range~Range#end range end} positions are not placed inside same container or\n\t\t * parent container for these positions cannot be found.\n\t\t *\n\t\t * @error view-writer-invalid-range-container\n\t\t */\n\n\t\tthrow new CKEditorError( 'view-writer-invalid-range-container', errorContext );\n\t}\n}\n\n// Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\nfunction canBeJoined( a, b ) {\n\treturn a.id === null && b.id === null;\n}\n"]},"metadata":{},"sourceType":"module"}