{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module undo/basecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { transformSets } from '@ckeditor/ckeditor5-engine/src/model/operation/transform';\n/**\n * Base class for undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.\n *\n * @protected\n * @extends module:core/command~Command\n */\n\nexport default class BaseCommand extends Command {\n  constructor(editor) {\n    super(editor);\n    /**\n     * Stack of items stored by the command. These are pairs of:\n     *\n     * * {@link module:engine/model/batch~Batch batch} saved by the command,\n     * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.\n     *\n     * @protected\n     * @member {Array} #_stack\n     */\n\n    this._stack = [];\n    /**\n     * Stores all batches that were created by this command.\n     *\n     * @protected\n     * @member {WeakSet.<module:engine/model/batch~Batch>} #_createdBatches\n     */\n\n    this._createdBatches = new WeakSet(); // Refresh state, so the command is inactive right after initialization.\n\n    this.refresh();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  refresh() {\n    this.isEnabled = this._stack.length > 0;\n  }\n  /**\n   * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}\n   * created by the editor which this command is registered to.\n   *\n   * @param {module:engine/model/batch~Batch} batch The batch to add.\n   */\n\n\n  addBatch(batch) {\n    const docSelection = this.editor.model.document.selection;\n    const selection = {\n      ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],\n      isBackward: docSelection.isBackward\n    };\n\n    this._stack.push({\n      batch,\n      selection\n    });\n\n    this.refresh();\n  }\n  /**\n   * Removes all items from the stack.\n   */\n\n\n  clearStack() {\n    this._stack = [];\n    this.refresh();\n  }\n  /**\n   * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.\n   *\n   * @protected\n   * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be restored.\n   * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.\n   * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations which has been applied\n   * since selection has been stored.\n   */\n\n\n  _restoreSelection(ranges, isBackward, operations) {\n    const model = this.editor.model;\n    const document = model.document; // This will keep the transformed selection ranges.\n\n    const selectionRanges = []; // Transform all ranges from the restored selection.\n\n    for (const range of ranges) {\n      const transformed = transformSelectionRange(range, operations); // For each `range` from `ranges`, we take only one transformed range.\n      // This is because we want to prevent situation where single-range selection\n      // got transformed to multi-range selection. We will take the first range that\n      // is not in the graveyard.\n\n      const newRange = transformed.find(range => range.start.root != document.graveyard); // `transformedRange` might be `undefined` if transformed range ended up in graveyard.\n\n      if (newRange) {\n        selectionRanges.push(newRange);\n      }\n    } // `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.\n\n\n    if (selectionRanges.length) {\n      model.change(writer => {\n        writer.setSelection(selectionRanges, {\n          backward: isBackward\n        });\n      });\n    }\n  }\n  /**\n   * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.\n   * This is a helper method for {@link #execute}.\n   *\n   * @protected\n   * @param {module:engine/model/batch~Batch} batchToUndo The batch to be undone.\n   * @param {module:engine/model/batch~Batch} undoingBatch The batch that will contain undoing changes.\n   */\n\n\n  _undo(batchToUndo, undoingBatch) {\n    const model = this.editor.model;\n    const document = model.document; // All changes done by the command execution will be saved as one batch.\n\n    this._createdBatches.add(undoingBatch);\n\n    const operationsToUndo = batchToUndo.operations.slice().filter(operation => operation.isDocumentOperation);\n    operationsToUndo.reverse(); // We will process each operation from `batchToUndo`, in reverse order. If there were operations A, B and C in undone batch,\n    // we need to revert them in reverse order, so first C' (reversed C), then B', then A'.\n\n    for (const operationToUndo of operationsToUndo) {\n      const nextBaseVersion = operationToUndo.baseVersion + 1;\n      const historyOperations = Array.from(document.history.getOperations(nextBaseVersion));\n      const transformedSets = transformSets([operationToUndo.getReversed()], historyOperations, {\n        useRelations: true,\n        document: this.editor.model.document,\n        padWithNoOps: false,\n        forceWeakRemove: true\n      });\n      const reversedOperations = transformedSets.operationsA; // After reversed operation has been transformed by all history operations, apply it.\n\n      for (const operation of reversedOperations) {\n        // Before applying, add the operation to the `undoingBatch`.\n        undoingBatch.addOperation(operation);\n        model.applyOperation(operation);\n        document.history.setOperationAsUndone(operationToUndo, operation);\n      }\n    }\n  }\n\n} // Transforms given range `range` by given `operations`.\n// Returns an array containing one or more ranges, which are result of the transformation.\n\nfunction transformSelectionRange(range, operations) {\n  const transformed = range.getTransformedByOperations(operations); // After `range` got transformed, we have an array of ranges. Some of those\n  // ranges may be \"touching\" -- they can be next to each other and could be merged.\n  // First, we have to sort those ranges to assure that they are in order.\n\n  transformed.sort((a, b) => a.start.isBefore(b.start) ? -1 : 1); // Then, we check if two consecutive ranges are touching.\n\n  for (let i = 1; i < transformed.length; i++) {\n    const a = transformed[i - 1];\n    const b = transformed[i];\n\n    if (a.end.isTouching(b.start)) {\n      // And join them together if they are.\n      a.end = b.end;\n      transformed.splice(i, 1);\n      i--;\n    }\n  }\n\n  return transformed;\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-undo/src/basecommand.js"],"names":["Command","transformSets","BaseCommand","constructor","editor","_stack","_createdBatches","WeakSet","refresh","isEnabled","length","addBatch","batch","docSelection","model","document","selection","ranges","hasOwnRange","Array","from","getRanges","isBackward","push","clearStack","_restoreSelection","operations","selectionRanges","range","transformed","transformSelectionRange","newRange","find","start","root","graveyard","change","writer","setSelection","backward","_undo","batchToUndo","undoingBatch","add","operationsToUndo","slice","filter","operation","isDocumentOperation","reverse","operationToUndo","nextBaseVersion","baseVersion","historyOperations","history","getOperations","transformedSets","getReversed","useRelations","padWithNoOps","forceWeakRemove","reversedOperations","operationsA","addOperation","applyOperation","setOperationAsUndone","getTransformedByOperations","sort","a","b","isBefore","i","end","isTouching","splice"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module undo/basecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { transformSets } from '@ckeditor/ckeditor5-engine/src/model/operation/transform';\n\n/**\n * Base class for undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.\n *\n * @protected\n * @extends module:core/command~Command\n */\nexport default class BaseCommand extends Command {\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * Stack of items stored by the command. These are pairs of:\n\t\t *\n\t\t * * {@link module:engine/model/batch~Batch batch} saved by the command,\n\t\t * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array} #_stack\n\t\t */\n\t\tthis._stack = [];\n\n\t\t/**\n\t\t * Stores all batches that were created by this command.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakSet.<module:engine/model/batch~Batch>} #_createdBatches\n\t\t */\n\t\tthis._createdBatches = new WeakSet();\n\n\t\t// Refresh state, so the command is inactive right after initialization.\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tthis.isEnabled = this._stack.length > 0;\n\t}\n\n\t/**\n\t * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}\n\t * created by the editor which this command is registered to.\n\t *\n\t * @param {module:engine/model/batch~Batch} batch The batch to add.\n\t */\n\taddBatch( batch ) {\n\t\tconst docSelection = this.editor.model.document.selection;\n\n\t\tconst selection = {\n\t\t\tranges: docSelection.hasOwnRange ? Array.from( docSelection.getRanges() ) : [],\n\t\t\tisBackward: docSelection.isBackward\n\t\t};\n\n\t\tthis._stack.push( { batch, selection } );\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * Removes all items from the stack.\n\t */\n\tclearStack() {\n\t\tthis._stack = [];\n\t\tthis.refresh();\n\t}\n\n\t/**\n\t * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.\n\t *\n\t * @protected\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be restored.\n\t * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.\n\t * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations which has been applied\n\t * since selection has been stored.\n\t */\n\t_restoreSelection( ranges, isBackward, operations ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\n\t\t// This will keep the transformed selection ranges.\n\t\tconst selectionRanges = [];\n\n\t\t// Transform all ranges from the restored selection.\n\t\tfor ( const range of ranges ) {\n\t\t\tconst transformed = transformSelectionRange( range, operations );\n\n\t\t\t// For each `range` from `ranges`, we take only one transformed range.\n\t\t\t// This is because we want to prevent situation where single-range selection\n\t\t\t// got transformed to multi-range selection. We will take the first range that\n\t\t\t// is not in the graveyard.\n\t\t\tconst newRange = transformed.find(\n\t\t\t\trange => range.start.root != document.graveyard\n\t\t\t);\n\n\t\t\t// `transformedRange` might be `undefined` if transformed range ended up in graveyard.\n\t\t\tif ( newRange ) {\n\t\t\t\tselectionRanges.push( newRange );\n\t\t\t}\n\t\t}\n\n\t\t// `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.\n\t\tif ( selectionRanges.length ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( selectionRanges, { backward: isBackward } );\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.\n\t * This is a helper method for {@link #execute}.\n\t *\n\t * @protected\n\t * @param {module:engine/model/batch~Batch} batchToUndo The batch to be undone.\n\t * @param {module:engine/model/batch~Batch} undoingBatch The batch that will contain undoing changes.\n\t */\n\t_undo( batchToUndo, undoingBatch ) {\n\t\tconst model = this.editor.model;\n\t\tconst document = model.document;\n\n\t\t// All changes done by the command execution will be saved as one batch.\n\t\tthis._createdBatches.add( undoingBatch );\n\n\t\tconst operationsToUndo = batchToUndo.operations.slice().filter( operation => operation.isDocumentOperation );\n\t\toperationsToUndo.reverse();\n\n\t\t// We will process each operation from `batchToUndo`, in reverse order. If there were operations A, B and C in undone batch,\n\t\t// we need to revert them in reverse order, so first C' (reversed C), then B', then A'.\n\t\tfor ( const operationToUndo of operationsToUndo ) {\n\t\t\tconst nextBaseVersion = operationToUndo.baseVersion + 1;\n\t\t\tconst historyOperations = Array.from( document.history.getOperations( nextBaseVersion ) );\n\n\t\t\tconst transformedSets = transformSets(\n\t\t\t\t[ operationToUndo.getReversed() ],\n\t\t\t\thistoryOperations,\n\t\t\t\t{\n\t\t\t\t\tuseRelations: true,\n\t\t\t\t\tdocument: this.editor.model.document,\n\t\t\t\t\tpadWithNoOps: false,\n\t\t\t\t\tforceWeakRemove: true\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tconst reversedOperations = transformedSets.operationsA;\n\n\t\t\t// After reversed operation has been transformed by all history operations, apply it.\n\t\t\tfor ( const operation of reversedOperations ) {\n\t\t\t\t// Before applying, add the operation to the `undoingBatch`.\n\t\t\t\tundoingBatch.addOperation( operation );\n\t\t\t\tmodel.applyOperation( operation );\n\n\t\t\t\tdocument.history.setOperationAsUndone( operationToUndo, operation );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Transforms given range `range` by given `operations`.\n// Returns an array containing one or more ranges, which are result of the transformation.\nfunction transformSelectionRange( range, operations ) {\n\tconst transformed = range.getTransformedByOperations( operations );\n\n\t// After `range` got transformed, we have an array of ranges. Some of those\n\t// ranges may be \"touching\" -- they can be next to each other and could be merged.\n\t// First, we have to sort those ranges to assure that they are in order.\n\ttransformed.sort( ( a, b ) => a.start.isBefore( b.start ) ? -1 : 1 );\n\n\t// Then, we check if two consecutive ranges are touching.\n\tfor ( let i = 1; i < transformed.length; i++ ) {\n\t\tconst a = transformed[ i - 1 ];\n\t\tconst b = transformed[ i ];\n\n\t\tif ( a.end.isTouching( b.start ) ) {\n\t\t\t// And join them together if they are.\n\t\t\ta.end = b.end;\n\t\t\ttransformed.splice( i, 1 );\n\t\t\ti--;\n\t\t}\n\t}\n\n\treturn transformed;\n}\n"]},"metadata":{},"sourceType":"module"}