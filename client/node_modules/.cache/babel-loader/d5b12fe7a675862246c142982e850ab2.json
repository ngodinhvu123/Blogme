{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\n/**\n * Set of utils related to block and inline fillers handling.\n *\n * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all\n * empty elements which should be selectable with elements or characters called \"fillers\". Unfortunately there is no one\n * universal filler, this is why two types are uses:\n *\n * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,\n * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that\n * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be\n * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it can not be used\n * in the middle of a line of text. The {@link module:engine/view/filler~BR_FILLER `<br>` filler} can be replaced with any other\n * character in the data output, for instance {@link module:engine/view/filler~NBSP_FILLER non-breaking space}.\n *\n * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty\n * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width\n * spaces as an {@link module:engine/view/filler~INLINE_FILLER inline filler} having the predetermined\n * {@link module:engine/view/filler~INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to\n * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not\n * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional\n * code is needed to handle the caret.\n *\n * Both inline and block fillers are handled by the {@link module:engine/view/renderer~Renderer renderer} and are not present in the\n * view.\n *\n * @module engine/view/filler\n */\n\n/**\n * Non-breaking space filler creator. This is a function which creates `&nbsp;` text node.\n * It defines how the filler is created.\n *\n * @see module:engine/view/filler~BR_FILLER\n * @function\n */\n\nexport const NBSP_FILLER = domDocument => domDocument.createTextNode('\\u00A0');\n/**\n * `<br>` filler creator. This is a function which creates `<br data-cke-filler=\"true\">` element.\n * It defines how the filler is created.\n *\n * @see module:engine/view/filler~NBSP_FILLER\n * @function\n */\n\nexport const BR_FILLER = domDocument => {\n  const fillerBr = domDocument.createElement('br');\n  fillerBr.dataset.ckeFiller = true;\n  return fillerBr;\n};\n/**\n * Length of the {@link module:engine/view/filler~INLINE_FILLER INLINE_FILLER}.\n */\n\nexport const INLINE_FILLER_LENGTH = 7;\n/**\n * Inline filler which is a sequence of the zero width spaces.\n */\n\nexport const INLINE_FILLER = (() => {\n  let inlineFiller = '';\n\n  for (let i = 0; i < INLINE_FILLER_LENGTH; i++) {\n    inlineFiller += '\\u200b';\n  }\n\n  return inlineFiller;\n})(); // Usu IIF so the INLINE_FILLER appears as a constant in the docs.\n\n/**\n * Checks if the node is a text node which starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n *\n *\t\tstartsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true\n *\t\tstartsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true\n *\t\tstartsWithFiller( document.createTextNode( 'foo' ) ); // false\n *\t\tstartsWithFiller( document.createElement( 'p' ) ); // false\n *\n * @param {Node} domNode DOM node.\n * @returns {Boolean} True if the text node starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\n\nexport function startsWithFiller(domNode) {\n  return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;\n}\n/**\n * Checks if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n *\n *\t\tisInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true\n *\t\tisInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false\n *\n * @param {Text} domText DOM text node.\n * @returns {Boolean} True if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\n\nexport function isInlineFiller(domText) {\n  return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);\n}\n/**\n * Get string data from the text node, removing an {@link module:engine/view/filler~INLINE_FILLER inline filler} from it,\n * if text node contains it.\n *\n *\t\tgetDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true\n *\t\tgetDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true\n *\n * @param {Text} domText DOM text node, possible with inline filler.\n * @returns {String} Data without filler.\n */\n\nexport function getDataWithoutFiller(domText) {\n  if (startsWithFiller(domText)) {\n    return domText.data.slice(INLINE_FILLER_LENGTH);\n  } else {\n    return domText.data;\n  }\n}\n/**\n * Assign key observer which move cursor from the end of the inline filler to the beginning of it when\n * the left arrow is pressed, so the filler does not break navigation.\n *\n * @param {module:engine/view/view~View} view View controller instance we should inject quirks handling on.\n */\n\nexport function injectQuirksHandling(view) {\n  view.document.on('keydown', jumpOverInlineFiller);\n} // Move cursor from the end of the inline filler to the beginning of it when, so the filler does not break navigation.\n\nfunction jumpOverInlineFiller(evt, data) {\n  if (data.keyCode == keyCodes.arrowleft) {\n    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n\n    if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {\n      const domParent = domSelection.getRangeAt(0).startContainer;\n      const domOffset = domSelection.getRangeAt(0).startOffset;\n\n      if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {\n        domSelection.collapse(domParent, 0);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/view/filler.js"],"names":["keyCodes","isText","NBSP_FILLER","domDocument","createTextNode","BR_FILLER","fillerBr","createElement","dataset","ckeFiller","INLINE_FILLER_LENGTH","INLINE_FILLER","inlineFiller","i","startsWithFiller","domNode","data","substr","isInlineFiller","domText","length","getDataWithoutFiller","slice","injectQuirksHandling","view","document","on","jumpOverInlineFiller","evt","keyCode","arrowleft","domSelection","domTarget","ownerDocument","defaultView","getSelection","rangeCount","getRangeAt","collapsed","domParent","startContainer","domOffset","startOffset","collapse"],"mappings":"AAAA;;;;AAKA,SAASA,QAAT,QAAyB,wCAAzB;AACA,OAAOC,MAAP,MAAmB,0CAAnB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;;;;;;;;AAOA,OAAO,MAAMC,WAAW,GAAGC,WAAW,IAAIA,WAAW,CAACC,cAAZ,CAA4B,QAA5B,CAAnC;AAEP;;;;;;;;AAOA,OAAO,MAAMC,SAAS,GAAGF,WAAW,IAAI;AACvC,QAAMG,QAAQ,GAAGH,WAAW,CAACI,aAAZ,CAA2B,IAA3B,CAAjB;AACAD,EAAAA,QAAQ,CAACE,OAAT,CAAiBC,SAAjB,GAA6B,IAA7B;AAEA,SAAOH,QAAP;AACA,CALM;AAOP;;;;AAGA,OAAO,MAAMI,oBAAoB,GAAG,CAA7B;AAEP;;;;AAGA,OAAO,MAAMC,aAAa,GAAG,CAAE,MAAM;AACpC,MAAIC,YAAY,GAAG,EAAnB;;AAEA,OAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGH,oBAArB,EAA2CG,CAAC,EAA5C,EAAiD;AAChDD,IAAAA,YAAY,IAAI,QAAhB;AACA;;AAED,SAAOA,YAAP;AACA,CAR4B,GAAtB,C,CAQA;;AAEP;;;;;;;;;;;;AAWA,OAAO,SAASE,gBAAT,CAA2BC,OAA3B,EAAqC;AAC3C,SAAOd,MAAM,CAAEc,OAAF,CAAN,IAAuBA,OAAO,CAACC,IAAR,CAAaC,MAAb,CAAqB,CAArB,EAAwBP,oBAAxB,MAAmDC,aAAjF;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASO,cAAT,CAAyBC,OAAzB,EAAmC;AACzC,SAAOA,OAAO,CAACH,IAAR,CAAaI,MAAb,IAAuBV,oBAAvB,IAA+CI,gBAAgB,CAAEK,OAAF,CAAtE;AACA;AAED;;;;;;;;;;;AAUA,OAAO,SAASE,oBAAT,CAA+BF,OAA/B,EAAyC;AAC/C,MAAKL,gBAAgB,CAAEK,OAAF,CAArB,EAAmC;AAClC,WAAOA,OAAO,CAACH,IAAR,CAAaM,KAAb,CAAoBZ,oBAApB,CAAP;AACA,GAFD,MAEO;AACN,WAAOS,OAAO,CAACH,IAAf;AACA;AACD;AAED;;;;;;;AAMA,OAAO,SAASO,oBAAT,CAA+BC,IAA/B,EAAsC;AAC5CA,EAAAA,IAAI,CAACC,QAAL,CAAcC,EAAd,CAAkB,SAAlB,EAA6BC,oBAA7B;AACA,C,CAED;;AACA,SAASA,oBAAT,CAA+BC,GAA/B,EAAoCZ,IAApC,EAA2C;AAC1C,MAAKA,IAAI,CAACa,OAAL,IAAgB7B,QAAQ,CAAC8B,SAA9B,EAA0C;AACzC,UAAMC,YAAY,GAAGf,IAAI,CAACgB,SAAL,CAAeC,aAAf,CAA6BC,WAA7B,CAAyCC,YAAzC,EAArB;;AAEA,QAAKJ,YAAY,CAACK,UAAb,IAA2B,CAA3B,IAAgCL,YAAY,CAACM,UAAb,CAAyB,CAAzB,EAA6BC,SAAlE,EAA8E;AAC7E,YAAMC,SAAS,GAAGR,YAAY,CAACM,UAAb,CAAyB,CAAzB,EAA6BG,cAA/C;AACA,YAAMC,SAAS,GAAGV,YAAY,CAACM,UAAb,CAAyB,CAAzB,EAA6BK,WAA/C;;AAEA,UAAK5B,gBAAgB,CAAEyB,SAAF,CAAhB,IAAiCE,SAAS,IAAI/B,oBAAnD,EAA0E;AACzEqB,QAAAA,YAAY,CAACY,QAAb,CAAuBJ,SAAvB,EAAkC,CAAlC;AACA;AACD;AACD;AACD","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\n\n/**\n * Set of utils related to block and inline fillers handling.\n *\n * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all\n * empty elements which should be selectable with elements or characters called \"fillers\". Unfortunately there is no one\n * universal filler, this is why two types are uses:\n *\n * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,\n * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that\n * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be\n * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it can not be used\n * in the middle of a line of text. The {@link module:engine/view/filler~BR_FILLER `<br>` filler} can be replaced with any other\n * character in the data output, for instance {@link module:engine/view/filler~NBSP_FILLER non-breaking space}.\n *\n * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty\n * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width\n * spaces as an {@link module:engine/view/filler~INLINE_FILLER inline filler} having the predetermined\n * {@link module:engine/view/filler~INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to\n * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not\n * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional\n * code is needed to handle the caret.\n *\n * Both inline and block fillers are handled by the {@link module:engine/view/renderer~Renderer renderer} and are not present in the\n * view.\n *\n * @module engine/view/filler\n */\n\n/**\n * Non-breaking space filler creator. This is a function which creates `&nbsp;` text node.\n * It defines how the filler is created.\n *\n * @see module:engine/view/filler~BR_FILLER\n * @function\n */\nexport const NBSP_FILLER = domDocument => domDocument.createTextNode( '\\u00A0' );\n\n/**\n * `<br>` filler creator. This is a function which creates `<br data-cke-filler=\"true\">` element.\n * It defines how the filler is created.\n *\n * @see module:engine/view/filler~NBSP_FILLER\n * @function\n */\nexport const BR_FILLER = domDocument => {\n\tconst fillerBr = domDocument.createElement( 'br' );\n\tfillerBr.dataset.ckeFiller = true;\n\n\treturn fillerBr;\n};\n\n/**\n * Length of the {@link module:engine/view/filler~INLINE_FILLER INLINE_FILLER}.\n */\nexport const INLINE_FILLER_LENGTH = 7;\n\n/**\n * Inline filler which is a sequence of the zero width spaces.\n */\nexport const INLINE_FILLER = ( () => {\n\tlet inlineFiller = '';\n\n\tfor ( let i = 0; i < INLINE_FILLER_LENGTH; i++ ) {\n\t\tinlineFiller += '\\u200b';\n\t}\n\n\treturn inlineFiller;\n} )(); // Usu IIF so the INLINE_FILLER appears as a constant in the docs.\n\n/**\n * Checks if the node is a text node which starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n *\n *\t\tstartsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true\n *\t\tstartsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true\n *\t\tstartsWithFiller( document.createTextNode( 'foo' ) ); // false\n *\t\tstartsWithFiller( document.createElement( 'p' ) ); // false\n *\n * @param {Node} domNode DOM node.\n * @returns {Boolean} True if the text node starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\nexport function startsWithFiller( domNode ) {\n\treturn isText( domNode ) && ( domNode.data.substr( 0, INLINE_FILLER_LENGTH ) === INLINE_FILLER );\n}\n\n/**\n * Checks if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n *\n *\t\tisInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true\n *\t\tisInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false\n *\n * @param {Text} domText DOM text node.\n * @returns {Boolean} True if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.\n */\nexport function isInlineFiller( domText ) {\n\treturn domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller( domText );\n}\n\n/**\n * Get string data from the text node, removing an {@link module:engine/view/filler~INLINE_FILLER inline filler} from it,\n * if text node contains it.\n *\n *\t\tgetDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true\n *\t\tgetDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true\n *\n * @param {Text} domText DOM text node, possible with inline filler.\n * @returns {String} Data without filler.\n */\nexport function getDataWithoutFiller( domText ) {\n\tif ( startsWithFiller( domText ) ) {\n\t\treturn domText.data.slice( INLINE_FILLER_LENGTH );\n\t} else {\n\t\treturn domText.data;\n\t}\n}\n\n/**\n * Assign key observer which move cursor from the end of the inline filler to the beginning of it when\n * the left arrow is pressed, so the filler does not break navigation.\n *\n * @param {module:engine/view/view~View} view View controller instance we should inject quirks handling on.\n */\nexport function injectQuirksHandling( view ) {\n\tview.document.on( 'keydown', jumpOverInlineFiller );\n}\n\n// Move cursor from the end of the inline filler to the beginning of it when, so the filler does not break navigation.\nfunction jumpOverInlineFiller( evt, data ) {\n\tif ( data.keyCode == keyCodes.arrowleft ) {\n\t\tconst domSelection = data.domTarget.ownerDocument.defaultView.getSelection();\n\n\t\tif ( domSelection.rangeCount == 1 && domSelection.getRangeAt( 0 ).collapsed ) {\n\t\t\tconst domParent = domSelection.getRangeAt( 0 ).startContainer;\n\t\t\tconst domOffset = domSelection.getRangeAt( 0 ).startOffset;\n\n\t\t\tif ( startsWithFiller( domParent ) && domOffset <= INLINE_FILLER_LENGTH ) {\n\t\t\t\tdomSelection.collapse( domParent, 0 );\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}