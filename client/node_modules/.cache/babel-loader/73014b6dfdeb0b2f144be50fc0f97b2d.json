{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/matcher\n */\n\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\nexport default class Matcher {\n  /**\n   * Creates new instance of Matcher.\n   *\n   * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n   * more information.\n   */\n  constructor(...pattern) {\n    /**\n     * @private\n     * @type {Array<String|RegExp|Object>}\n     */\n    this._patterns = [];\n    this.add(...pattern);\n  }\n  /**\n   * Adds pattern or patterns to matcher instance.\n   *\n   *\t\t// String.\n   *\t\tmatcher.add( 'div' );\n   *\n   *\t\t// Regular expression.\n   *\t\tmatcher.add( /^\\w/ );\n   *\n   *\t\t// Single class.\n   *\t\tmatcher.add( {\n   *\t\t\tclasses: 'foobar'\n   *\t\t} );\n   *\n   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n   *\n   * Multiple patterns can be added in one call:\n   *\n   * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n   *\n   * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n   * is provided it will be used to match element's name. Pattern can be also provided in a form\n   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n   * Function's return value will be stored under `match` key of the object returned from\n   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n   * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n   * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n   * represents attribute name. Value under that key can be either:\n   * * `true` - then attribute is just required (can be empty),\n   * * a string - then attribute has to be equal, or\n   * * a regular expression - then attribute has to match the expression.\n   * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n   * provided in a form of string or regular expression.\n   * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n   * represents style name. Value under that key can be either a string or a regular expression and it will be used\n   * to match style value.\n   */\n\n\n  add(...pattern) {\n    for (let item of pattern) {\n      // String or RegExp pattern is used as element's name.\n      if (typeof item == 'string' || item instanceof RegExp) {\n        item = {\n          name: item\n        };\n      } // Single class name/RegExp can be provided.\n\n\n      if (item.classes && (typeof item.classes == 'string' || item.classes instanceof RegExp)) {\n        item.classes = [item.classes];\n      }\n\n      this._patterns.push(item);\n    }\n  }\n  /**\n   * Matches elements for currently stored patterns. Returns match information about first found\n   * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n   *\n   * Example of returned object:\n   *\n   *\t\t{\n   *\t\t\telement: <instance of found element>,\n   *\t\t\tpattern: <pattern used to match found element>,\n   *\t\t\tmatch: {\n   *\t\t\t\tname: true,\n   *\t\t\t\tattributes: [ 'title', 'href' ],\n   *\t\t\t\tclasses: [ 'foo' ],\n   *\t\t\t\tstyles: [ 'color', 'position' ]\n   *\t\t\t}\n   *\t\t}\n   *\n   * @see module:engine/view/matcher~Matcher#add\n   * @see module:engine/view/matcher~Matcher#matchAll\n   * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n   * @returns {Object|null} result\n   * @returns {module:engine/view/element~Element} result.element Matched view element.\n   * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n   * @returns {Object} result.match Object representing matched element parts.\n   * @returns {Boolean} [result.match.name] True if name of the element was matched.\n   * @returns {Array} [result.match.attributes] Array with matched attribute names.\n   * @returns {Array} [result.match.classes] Array with matched class names.\n   * @returns {Array} [result.match.styles] Array with matched style names.\n   */\n\n\n  match(...element) {\n    for (const singleElement of element) {\n      for (const pattern of this._patterns) {\n        const match = isElementMatching(singleElement, pattern);\n\n        if (match) {\n          return {\n            element: singleElement,\n            pattern,\n            match\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Matches elements for currently stored patterns. Returns array of match information with all found\n   * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n   *\n   * @see module:engine/view/matcher~Matcher#add\n   * @see module:engine/view/matcher~Matcher#match\n   * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n   * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n   * see {@link module:engine/view/matcher~Matcher#match match method} description.\n   */\n\n\n  matchAll(...element) {\n    const results = [];\n\n    for (const singleElement of element) {\n      for (const pattern of this._patterns) {\n        const match = isElementMatching(singleElement, pattern);\n\n        if (match) {\n          results.push({\n            element: singleElement,\n            pattern,\n            match\n          });\n        }\n      }\n    }\n\n    return results.length > 0 ? results : null;\n  }\n  /**\n   * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n   * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n   *\n   * @returns {String|null} Element name trying to match.\n   */\n\n\n  getElementName() {\n    if (this._patterns.length !== 1) {\n      return null;\n    }\n\n    const pattern = this._patterns[0];\n    const name = pattern.name;\n    return typeof pattern != 'function' && name && !(name instanceof RegExp) ? name : null;\n  }\n\n} // Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\n\nfunction isElementMatching(element, pattern) {\n  // If pattern is provided as function - return result of that function;\n  if (typeof pattern == 'function') {\n    return pattern(element);\n  }\n\n  const match = {}; // Check element's name.\n\n  if (pattern.name) {\n    match.name = matchName(pattern.name, element.name);\n\n    if (!match.name) {\n      return null;\n    }\n  } // Check element's attributes.\n\n\n  if (pattern.attributes) {\n    match.attributes = matchAttributes(pattern.attributes, element);\n\n    if (!match.attributes) {\n      return null;\n    }\n  } // Check element's classes.\n\n\n  if (pattern.classes) {\n    match.classes = matchClasses(pattern.classes, element);\n\n    if (!match.classes) {\n      return false;\n    }\n  } // Check element's styles.\n\n\n  if (pattern.styles) {\n    match.styles = matchStyles(pattern.styles, element);\n\n    if (!match.styles) {\n      return false;\n    }\n  }\n\n  return match;\n} // Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\n\n\nfunction matchName(pattern, name) {\n  // If pattern is provided as RegExp - test against this regexp.\n  if (pattern instanceof RegExp) {\n    return pattern.test(name);\n  }\n\n  return pattern === name;\n} // Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\n\n\nfunction matchAttributes(patterns, element) {\n  const match = [];\n\n  for (const name in patterns) {\n    const pattern = patterns[name];\n\n    if (element.hasAttribute(name)) {\n      const attribute = element.getAttribute(name);\n\n      if (pattern === true) {\n        match.push(name);\n      } else if (pattern instanceof RegExp) {\n        if (pattern.test(attribute)) {\n          match.push(name);\n        } else {\n          return null;\n        }\n      } else if (attribute === pattern) {\n        match.push(name);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  return match;\n} // Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\n\n\nfunction matchClasses(patterns, element) {\n  const match = [];\n\n  for (const pattern of patterns) {\n    if (pattern instanceof RegExp) {\n      const classes = element.getClassNames();\n\n      for (const name of classes) {\n        if (pattern.test(name)) {\n          match.push(name);\n        }\n      }\n\n      if (match.length === 0) {\n        return null;\n      }\n    } else if (element.hasClass(pattern)) {\n      match.push(pattern);\n    } else {\n      return null;\n    }\n  }\n\n  return match;\n} // Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\n\n\nfunction matchStyles(patterns, element) {\n  const match = [];\n\n  for (const name in patterns) {\n    const pattern = patterns[name];\n\n    if (element.hasStyle(name)) {\n      const style = element.getStyle(name);\n\n      if (pattern instanceof RegExp) {\n        if (pattern.test(style)) {\n          match.push(name);\n        } else {\n          return null;\n        }\n      } else if (style === pattern) {\n        match.push(name);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  return match;\n}\n/**\n * An entity that is a valid pattern recognized by a matcher. `MatcherPattern` is used by {@link ~Matcher} to recognize\n * if a view element fits in a group of view elements described by the pattern.\n *\n * `MatcherPattern` can be given as a `String`, a `RegExp`, an `Object` or a `Function`.\n *\n * If `MatcherPattern` is given as a `String` or `RegExp`, it will match any view element that has a matching name:\n *\n *\t\t// Match any element with name equal to 'div'.\n *\t\tconst pattern = 'div';\n *\n *\t\t// Match any element which name starts on 'p'.\n *\t\tconst pattern = /^p/;\n *\n * If `MatcherPattern` is given as an `Object`, all the object's properties will be matched with view element properties.\n *\n *\t\t// Match view element's name.\n *\t\tconst pattern = { name: /^p/ };\n *\n *\t\t// Match view element which has matching attributes.\n *\t\tconst pattern = {\n *\t\t\tattributes: {\n *\t\t\t\ttitle: 'foobar',\t// Attribute title should equal 'foobar'.\n *\t\t\t\tfoo: /^\\w+/,\t\t// Attribute foo should match /^\\w+/ regexp.\n *\t\t\t\tbar: true\t\t\t// Attribute bar should be set (can be empty).\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has given class.\n *\t\tconst pattern = {\n *\t\t\tclasses: 'foobar'\n *\t\t};\n *\n *\t\t// Match view element class using regular expression.\n *\t\tconst pattern = {\n *\t\t\tclasses: /foo.../\n *\t\t};\n *\n *\t\t// Multiple classes to match.\n *\t\tconst pattern = {\n *\t\t\tclasses: [ 'baz', 'bar', /foo.../ ]\n *\t\t};\n *\n *\t\t// Match view element which has given styles.\n *\t\tconst pattern = {\n *\t\t\tstyles: {\n *\t\t\t\tposition: 'absolute',\n *\t\t\t\tcolor: /^\\w*blue$/\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Pattern with multiple properties.\n *\t\tconst pattern = {\n *\t\t\tname: 'span',\n *\t\t\tstyles: {\n *\t\t\t\t'font-weight': 'bold'\n *\t\t\t},\n *\t\t\tclasses: 'highlighted'\n *\t\t};\n *\n * If `MatcherPattern` is given as a `Function`, the function takes a view element as a first and only parameter and\n * the function should decide whether that element matches. If so, it should return what part of the view element has been matched.\n * Otherwise, the function should return `null`. The returned result will be included in `match` property of the object\n * returned by {@link ~Matcher#match} call.\n *\n *\t\t// Match an empty <div> element.\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'div' && element.childCount > 0 ) {\n *\t\t\t\t// Return which part of the element was matched.\n *\t\t\t\treturn { name: true };\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n *\t\t// Match a <p> element with big font (\"heading-like\" element).\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'p' ) {\n *\t\t\t\tconst fontSize = element.getStyle( 'font-size' );\n *\t\t\t\tconst size = fontSize.match( /(\\d+)/px );\n *\n *\t\t\t\tif ( size && Number( size[ 1 ] ) > 26 ) {\n *\t\t\t\t\treturn { name: true, attribute: [ 'font-size' ] };\n *\t\t\t\t}\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n * `MatcherPattern` is defined in a way that it is a superset of {@link module:engine/view/elementdefinition~ElementDefinition},\n * that is, every `ElementDefinition` also can be used as a `MatcherPattern`.\n *\n * @typedef {String|RegExp|Object|Function} module:engine/view/matcher~MatcherPattern\n *\n * @property {String|RegExp} [name] View element name to match.\n * @property {String|RegExp|Array.<String|RegExp>} [classes] View element's class name(s) to match.\n * @property {Object} [styles] Object with key-value pairs representing styles to match.\n * Each object key represents style name. Value can be given as `String` or `RegExp`.\n * @property {Object} [attributes] Object with key-value pairs representing attributes to match.\n * Each object key represents attribute name. Value can be given as `String` or `RegExp`.\n */","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/view/matcher.js"],"names":["Matcher","constructor","pattern","_patterns","add","item","RegExp","name","classes","push","match","element","singleElement","isElementMatching","matchAll","results","length","getElementName","matchName","attributes","matchAttributes","matchClasses","styles","matchStyles","test","patterns","hasAttribute","attribute","getAttribute","getClassNames","hasClass","hasStyle","style","getStyle"],"mappings":"AAAA;;;;;AAKA;;;;AAIA;;;;AAIA,eAAe,MAAMA,OAAN,CAAc;AAC5B;;;;;;AAMAC,EAAAA,WAAW,CAAE,GAAGC,OAAL,EAAe;AACzB;;;;AAIA,SAAKC,SAAL,GAAiB,EAAjB;AAEA,SAAKC,GAAL,CAAU,GAAGF,OAAb;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCAE,EAAAA,GAAG,CAAE,GAAGF,OAAL,EAAe;AACjB,SAAM,IAAIG,IAAV,IAAkBH,OAAlB,EAA4B;AAC3B;AACA,UAAK,OAAOG,IAAP,IAAe,QAAf,IAA2BA,IAAI,YAAYC,MAAhD,EAAyD;AACxDD,QAAAA,IAAI,GAAG;AAAEE,UAAAA,IAAI,EAAEF;AAAR,SAAP;AACA,OAJ0B,CAM3B;;;AACA,UAAKA,IAAI,CAACG,OAAL,KAAkB,OAAOH,IAAI,CAACG,OAAZ,IAAuB,QAAvB,IAAmCH,IAAI,CAACG,OAAL,YAAwBF,MAA7E,CAAL,EAA6F;AAC5FD,QAAAA,IAAI,CAACG,OAAL,GAAe,CAAEH,IAAI,CAACG,OAAP,CAAf;AACA;;AAED,WAAKL,SAAL,CAAeM,IAAf,CAAqBJ,IAArB;AACA;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BAK,EAAAA,KAAK,CAAE,GAAGC,OAAL,EAAe;AACnB,SAAM,MAAMC,aAAZ,IAA6BD,OAA7B,EAAuC;AACtC,WAAM,MAAMT,OAAZ,IAAuB,KAAKC,SAA5B,EAAwC;AACvC,cAAMO,KAAK,GAAGG,iBAAiB,CAAED,aAAF,EAAiBV,OAAjB,CAA/B;;AAEA,YAAKQ,KAAL,EAAa;AACZ,iBAAO;AACNC,YAAAA,OAAO,EAAEC,aADH;AAENV,YAAAA,OAFM;AAGNQ,YAAAA;AAHM,WAAP;AAKA;AACD;AACD;;AAED,WAAO,IAAP;AACA;AAED;;;;;;;;;;;;AAUAI,EAAAA,QAAQ,CAAE,GAAGH,OAAL,EAAe;AACtB,UAAMI,OAAO,GAAG,EAAhB;;AAEA,SAAM,MAAMH,aAAZ,IAA6BD,OAA7B,EAAuC;AACtC,WAAM,MAAMT,OAAZ,IAAuB,KAAKC,SAA5B,EAAwC;AACvC,cAAMO,KAAK,GAAGG,iBAAiB,CAAED,aAAF,EAAiBV,OAAjB,CAA/B;;AAEA,YAAKQ,KAAL,EAAa;AACZK,UAAAA,OAAO,CAACN,IAAR,CAAc;AACbE,YAAAA,OAAO,EAAEC,aADI;AAEbV,YAAAA,OAFa;AAGbQ,YAAAA;AAHa,WAAd;AAKA;AACD;AACD;;AAED,WAAOK,OAAO,CAACC,MAAR,GAAiB,CAAjB,GAAqBD,OAArB,GAA+B,IAAtC;AACA;AAED;;;;;;;;AAMAE,EAAAA,cAAc,GAAG;AAChB,QAAK,KAAKd,SAAL,CAAea,MAAf,KAA0B,CAA/B,EAAmC;AAClC,aAAO,IAAP;AACA;;AAED,UAAMd,OAAO,GAAG,KAAKC,SAAL,CAAgB,CAAhB,CAAhB;AACA,UAAMI,IAAI,GAAGL,OAAO,CAACK,IAArB;AAEA,WAAS,OAAOL,OAAP,IAAkB,UAAlB,IAAgCK,IAAhC,IAAwC,EAAGA,IAAI,YAAYD,MAAnB,CAA1C,GAA0EC,IAA1E,GAAiF,IAAxF;AACA;;AAlK2B,C,CAqK7B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASM,iBAAT,CAA4BF,OAA5B,EAAqCT,OAArC,EAA+C;AAC9C;AACA,MAAK,OAAOA,OAAP,IAAkB,UAAvB,EAAoC;AACnC,WAAOA,OAAO,CAAES,OAAF,CAAd;AACA;;AAED,QAAMD,KAAK,GAAG,EAAd,CAN8C,CAO9C;;AACA,MAAKR,OAAO,CAACK,IAAb,EAAoB;AACnBG,IAAAA,KAAK,CAACH,IAAN,GAAaW,SAAS,CAAEhB,OAAO,CAACK,IAAV,EAAgBI,OAAO,CAACJ,IAAxB,CAAtB;;AAEA,QAAK,CAACG,KAAK,CAACH,IAAZ,EAAmB;AAClB,aAAO,IAAP;AACA;AACD,GAd6C,CAgB9C;;;AACA,MAAKL,OAAO,CAACiB,UAAb,EAA0B;AACzBT,IAAAA,KAAK,CAACS,UAAN,GAAmBC,eAAe,CAAElB,OAAO,CAACiB,UAAV,EAAsBR,OAAtB,CAAlC;;AAEA,QAAK,CAACD,KAAK,CAACS,UAAZ,EAAyB;AACxB,aAAO,IAAP;AACA;AACD,GAvB6C,CAyB9C;;;AACA,MAAKjB,OAAO,CAACM,OAAb,EAAuB;AACtBE,IAAAA,KAAK,CAACF,OAAN,GAAgBa,YAAY,CAAEnB,OAAO,CAACM,OAAV,EAAmBG,OAAnB,CAA5B;;AAEA,QAAK,CAACD,KAAK,CAACF,OAAZ,EAAsB;AACrB,aAAO,KAAP;AACA;AACD,GAhC6C,CAkC9C;;;AACA,MAAKN,OAAO,CAACoB,MAAb,EAAsB;AACrBZ,IAAAA,KAAK,CAACY,MAAN,GAAeC,WAAW,CAAErB,OAAO,CAACoB,MAAV,EAAkBX,OAAlB,CAA1B;;AAEA,QAAK,CAACD,KAAK,CAACY,MAAZ,EAAqB;AACpB,aAAO,KAAP;AACA;AACD;;AAED,SAAOZ,KAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASQ,SAAT,CAAoBhB,OAApB,EAA6BK,IAA7B,EAAoC;AACnC;AACA,MAAKL,OAAO,YAAYI,MAAxB,EAAiC;AAChC,WAAOJ,OAAO,CAACsB,IAAR,CAAcjB,IAAd,CAAP;AACA;;AAED,SAAOL,OAAO,KAAKK,IAAnB;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASa,eAAT,CAA0BK,QAA1B,EAAoCd,OAApC,EAA8C;AAC7C,QAAMD,KAAK,GAAG,EAAd;;AAEA,OAAM,MAAMH,IAAZ,IAAoBkB,QAApB,EAA+B;AAC9B,UAAMvB,OAAO,GAAGuB,QAAQ,CAAElB,IAAF,CAAxB;;AAEA,QAAKI,OAAO,CAACe,YAAR,CAAsBnB,IAAtB,CAAL,EAAoC;AACnC,YAAMoB,SAAS,GAAGhB,OAAO,CAACiB,YAAR,CAAsBrB,IAAtB,CAAlB;;AAEA,UAAKL,OAAO,KAAK,IAAjB,EAAwB;AACvBQ,QAAAA,KAAK,CAACD,IAAN,CAAYF,IAAZ;AACA,OAFD,MAEO,IAAKL,OAAO,YAAYI,MAAxB,EAAiC;AACvC,YAAKJ,OAAO,CAACsB,IAAR,CAAcG,SAAd,CAAL,EAAiC;AAChCjB,UAAAA,KAAK,CAACD,IAAN,CAAYF,IAAZ;AACA,SAFD,MAEO;AACN,iBAAO,IAAP;AACA;AACD,OANM,MAMA,IAAKoB,SAAS,KAAKzB,OAAnB,EAA6B;AACnCQ,QAAAA,KAAK,CAACD,IAAN,CAAYF,IAAZ;AACA,OAFM,MAEA;AACN,eAAO,IAAP;AACA;AACD,KAhBD,MAgBO;AACN,aAAO,IAAP;AACA;AACD;;AAED,SAAOG,KAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASW,YAAT,CAAuBI,QAAvB,EAAiCd,OAAjC,EAA2C;AAC1C,QAAMD,KAAK,GAAG,EAAd;;AAEA,OAAM,MAAMR,OAAZ,IAAuBuB,QAAvB,EAAkC;AACjC,QAAKvB,OAAO,YAAYI,MAAxB,EAAiC;AAChC,YAAME,OAAO,GAAGG,OAAO,CAACkB,aAAR,EAAhB;;AAEA,WAAM,MAAMtB,IAAZ,IAAoBC,OAApB,EAA8B;AAC7B,YAAKN,OAAO,CAACsB,IAAR,CAAcjB,IAAd,CAAL,EAA4B;AAC3BG,UAAAA,KAAK,CAACD,IAAN,CAAYF,IAAZ;AACA;AACD;;AAED,UAAKG,KAAK,CAACM,MAAN,KAAiB,CAAtB,EAA0B;AACzB,eAAO,IAAP;AACA;AACD,KAZD,MAYO,IAAKL,OAAO,CAACmB,QAAR,CAAkB5B,OAAlB,CAAL,EAAmC;AACzCQ,MAAAA,KAAK,CAACD,IAAN,CAAYP,OAAZ;AACA,KAFM,MAEA;AACN,aAAO,IAAP;AACA;AACD;;AAED,SAAOQ,KAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASa,WAAT,CAAsBE,QAAtB,EAAgCd,OAAhC,EAA0C;AACzC,QAAMD,KAAK,GAAG,EAAd;;AAEA,OAAM,MAAMH,IAAZ,IAAoBkB,QAApB,EAA+B;AAC9B,UAAMvB,OAAO,GAAGuB,QAAQ,CAAElB,IAAF,CAAxB;;AAEA,QAAKI,OAAO,CAACoB,QAAR,CAAkBxB,IAAlB,CAAL,EAAgC;AAC/B,YAAMyB,KAAK,GAAGrB,OAAO,CAACsB,QAAR,CAAkB1B,IAAlB,CAAd;;AAEA,UAAKL,OAAO,YAAYI,MAAxB,EAAiC;AAChC,YAAKJ,OAAO,CAACsB,IAAR,CAAcQ,KAAd,CAAL,EAA6B;AAC5BtB,UAAAA,KAAK,CAACD,IAAN,CAAYF,IAAZ;AACA,SAFD,MAEO;AACN,iBAAO,IAAP;AACA;AACD,OAND,MAMO,IAAKyB,KAAK,KAAK9B,OAAf,EAAyB;AAC/BQ,QAAAA,KAAK,CAACD,IAAN,CAAYF,IAAZ;AACA,OAFM,MAEA;AACN,eAAO,IAAP;AACA;AACD,KAdD,MAcO;AACN,aAAO,IAAP;AACA;AACD;;AAED,SAAOG,KAAP;AACA;AAED","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/matcher\n */\n\n/**\n * View matcher class.\n * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.\n */\nexport default class Matcher {\n\t/**\n\t * Creates new instance of Matcher.\n\t *\n\t * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for\n\t * more information.\n\t */\n\tconstructor( ...pattern ) {\n\t\t/**\n\t\t * @private\n\t\t * @type {Array<String|RegExp|Object>}\n\t\t */\n\t\tthis._patterns = [];\n\n\t\tthis.add( ...pattern );\n\t}\n\n\t/**\n\t * Adds pattern or patterns to matcher instance.\n\t *\n\t *\t\t// String.\n\t *\t\tmatcher.add( 'div' );\n\t *\n\t *\t\t// Regular expression.\n\t *\t\tmatcher.add( /^\\w/ );\n\t *\n\t *\t\t// Single class.\n\t *\t\tmatcher.add( {\n\t *\t\t\tclasses: 'foobar'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/view/matcher~MatcherPattern} for more examples.\n\t *\n\t * Multiple patterns can be added in one call:\n\t *\n\t * \t\tmatcher.add( 'div', { classes: 'foobar' } );\n\t *\n\t * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression\n\t * is provided it will be used to match element's name. Pattern can be also provided in a form\n\t * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.\n\t * Function's return value will be stored under `match` key of the object returned from\n\t * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.\n\t * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.\n\t * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key\n\t * represents attribute name. Value under that key can be either:\n\t * * `true` - then attribute is just required (can be empty),\n\t * * a string - then attribute has to be equal, or\n\t * * a regular expression - then attribute has to match the expression.\n\t * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be\n\t * provided in a form of string or regular expression.\n\t * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key\n\t * represents style name. Value under that key can be either a string or a regular expression and it will be used\n\t * to match style value.\n\t */\n\tadd( ...pattern ) {\n\t\tfor ( let item of pattern ) {\n\t\t\t// String or RegExp pattern is used as element's name.\n\t\t\tif ( typeof item == 'string' || item instanceof RegExp ) {\n\t\t\t\titem = { name: item };\n\t\t\t}\n\n\t\t\t// Single class name/RegExp can be provided.\n\t\t\tif ( item.classes && ( typeof item.classes == 'string' || item.classes instanceof RegExp ) ) {\n\t\t\t\titem.classes = [ item.classes ];\n\t\t\t}\n\n\t\t\tthis._patterns.push( item );\n\t\t}\n\t}\n\n\t/**\n\t * Matches elements for currently stored patterns. Returns match information about first found\n\t * {@link module:engine/view/element~Element element}, otherwise returns `null`.\n\t *\n\t * Example of returned object:\n\t *\n\t *\t\t{\n\t *\t\t\telement: <instance of found element>,\n\t *\t\t\tpattern: <pattern used to match found element>,\n\t *\t\t\tmatch: {\n\t *\t\t\t\tname: true,\n\t *\t\t\t\tattributes: [ 'title', 'href' ],\n\t *\t\t\t\tclasses: [ 'foo' ],\n\t *\t\t\t\tstyles: [ 'color', 'position' ]\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * @see module:engine/view/matcher~Matcher#add\n\t * @see module:engine/view/matcher~Matcher#matchAll\n\t * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n\t * @returns {Object|null} result\n\t * @returns {module:engine/view/element~Element} result.element Matched view element.\n\t * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.\n\t * @returns {Object} result.match Object representing matched element parts.\n\t * @returns {Boolean} [result.match.name] True if name of the element was matched.\n\t * @returns {Array} [result.match.attributes] Array with matched attribute names.\n\t * @returns {Array} [result.match.classes] Array with matched class names.\n\t * @returns {Array} [result.match.styles] Array with matched style names.\n\t */\n\tmatch( ...element ) {\n\t\tfor ( const singleElement of element ) {\n\t\t\tfor ( const pattern of this._patterns ) {\n\t\t\t\tconst match = isElementMatching( singleElement, pattern );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: singleElement,\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\tmatch\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Matches elements for currently stored patterns. Returns array of match information with all found\n\t * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.\n\t *\n\t * @see module:engine/view/matcher~Matcher#add\n\t * @see module:engine/view/matcher~Matcher#match\n\t * @param {...module:engine/view/element~Element} element View element to match against stored patterns.\n\t * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information\n\t * see {@link module:engine/view/matcher~Matcher#match match method} description.\n\t */\n\tmatchAll( ...element ) {\n\t\tconst results = [];\n\n\t\tfor ( const singleElement of element ) {\n\t\t\tfor ( const pattern of this._patterns ) {\n\t\t\t\tconst match = isElementMatching( singleElement, pattern );\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tresults.push( {\n\t\t\t\t\t\telement: singleElement,\n\t\t\t\t\t\tpattern,\n\t\t\t\t\t\tmatch\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn results.length > 0 ? results : null;\n\t}\n\n\t/**\n\t * Returns the name of the element to match if there is exactly one pattern added to the matcher instance\n\t * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.\n\t *\n\t * @returns {String|null} Element name trying to match.\n\t */\n\tgetElementName() {\n\t\tif ( this._patterns.length !== 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst pattern = this._patterns[ 0 ];\n\t\tconst name = pattern.name;\n\n\t\treturn ( typeof pattern != 'function' && name && !( name instanceof RegExp ) ) ? name : null;\n\t}\n}\n\n// Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.\n// If element cannot be matched to provided pattern - returns `null`.\n//\n// @param {module:engine/view/element~Element} element\n// @param {Object|String|RegExp|Function} pattern\n// @returns {Object|null} Returns object with match information or null if element is not matching.\nfunction isElementMatching( element, pattern ) {\n\t// If pattern is provided as function - return result of that function;\n\tif ( typeof pattern == 'function' ) {\n\t\treturn pattern( element );\n\t}\n\n\tconst match = {};\n\t// Check element's name.\n\tif ( pattern.name ) {\n\t\tmatch.name = matchName( pattern.name, element.name );\n\n\t\tif ( !match.name ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Check element's attributes.\n\tif ( pattern.attributes ) {\n\t\tmatch.attributes = matchAttributes( pattern.attributes, element );\n\n\t\tif ( !match.attributes ) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Check element's classes.\n\tif ( pattern.classes ) {\n\t\tmatch.classes = matchClasses( pattern.classes, element );\n\n\t\tif ( !match.classes ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Check element's styles.\n\tif ( pattern.styles ) {\n\t\tmatch.styles = matchStyles( pattern.styles, element );\n\n\t\tif ( !match.styles ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n// Checks if name can be matched by provided pattern.\n//\n// @param {String|RegExp} pattern\n// @param {String} name\n// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.\nfunction matchName( pattern, name ) {\n\t// If pattern is provided as RegExp - test against this regexp.\n\tif ( pattern instanceof RegExp ) {\n\t\treturn pattern.test( name );\n\t}\n\n\treturn pattern === name;\n}\n\n// Checks if attributes of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about attributes to match. Each key of the object will be\n// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.\n// @param {module:engine/view/element~Element} element Element which attributes will be tested.\n// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.\nfunction matchAttributes( patterns, element ) {\n\tconst match = [];\n\n\tfor ( const name in patterns ) {\n\t\tconst pattern = patterns[ name ];\n\n\t\tif ( element.hasAttribute( name ) ) {\n\t\t\tconst attribute = element.getAttribute( name );\n\n\t\t\tif ( pattern === true ) {\n\t\t\t\tmatch.push( name );\n\t\t\t} else if ( pattern instanceof RegExp ) {\n\t\t\t\tif ( pattern.test( attribute ) ) {\n\t\t\t\t\tmatch.push( name );\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else if ( attribute === pattern ) {\n\t\t\t\tmatch.push( name );\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n// Checks if classes of provided element can be matched against provided patterns.\n//\n// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.\n// @param {module:engine/view/element~Element} element Element which classes will be tested.\n// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.\nfunction matchClasses( patterns, element ) {\n\tconst match = [];\n\n\tfor ( const pattern of patterns ) {\n\t\tif ( pattern instanceof RegExp ) {\n\t\t\tconst classes = element.getClassNames();\n\n\t\t\tfor ( const name of classes ) {\n\t\t\t\tif ( pattern.test( name ) ) {\n\t\t\t\t\tmatch.push( name );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( match.length === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if ( element.hasClass( pattern ) ) {\n\t\t\tmatch.push( pattern );\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n// Checks if styles of provided element can be matched against provided patterns.\n//\n// @param {Object} patterns Object with information about styles to match. Each key of the object will be\n// used as style name. Value of each key can be a string or regular expression to match against style value.\n// @param {module:engine/view/element~Element} element Element which styles will be tested.\n// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.\nfunction matchStyles( patterns, element ) {\n\tconst match = [];\n\n\tfor ( const name in patterns ) {\n\t\tconst pattern = patterns[ name ];\n\n\t\tif ( element.hasStyle( name ) ) {\n\t\t\tconst style = element.getStyle( name );\n\n\t\t\tif ( pattern instanceof RegExp ) {\n\t\t\t\tif ( pattern.test( style ) ) {\n\t\t\t\t\tmatch.push( name );\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else if ( style === pattern ) {\n\t\t\t\tmatch.push( name );\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn match;\n}\n\n/**\n * An entity that is a valid pattern recognized by a matcher. `MatcherPattern` is used by {@link ~Matcher} to recognize\n * if a view element fits in a group of view elements described by the pattern.\n *\n * `MatcherPattern` can be given as a `String`, a `RegExp`, an `Object` or a `Function`.\n *\n * If `MatcherPattern` is given as a `String` or `RegExp`, it will match any view element that has a matching name:\n *\n *\t\t// Match any element with name equal to 'div'.\n *\t\tconst pattern = 'div';\n *\n *\t\t// Match any element which name starts on 'p'.\n *\t\tconst pattern = /^p/;\n *\n * If `MatcherPattern` is given as an `Object`, all the object's properties will be matched with view element properties.\n *\n *\t\t// Match view element's name.\n *\t\tconst pattern = { name: /^p/ };\n *\n *\t\t// Match view element which has matching attributes.\n *\t\tconst pattern = {\n *\t\t\tattributes: {\n *\t\t\t\ttitle: 'foobar',\t// Attribute title should equal 'foobar'.\n *\t\t\t\tfoo: /^\\w+/,\t\t// Attribute foo should match /^\\w+/ regexp.\n *\t\t\t\tbar: true\t\t\t// Attribute bar should be set (can be empty).\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Match view element which has given class.\n *\t\tconst pattern = {\n *\t\t\tclasses: 'foobar'\n *\t\t};\n *\n *\t\t// Match view element class using regular expression.\n *\t\tconst pattern = {\n *\t\t\tclasses: /foo.../\n *\t\t};\n *\n *\t\t// Multiple classes to match.\n *\t\tconst pattern = {\n *\t\t\tclasses: [ 'baz', 'bar', /foo.../ ]\n *\t\t};\n *\n *\t\t// Match view element which has given styles.\n *\t\tconst pattern = {\n *\t\t\tstyles: {\n *\t\t\t\tposition: 'absolute',\n *\t\t\t\tcolor: /^\\w*blue$/\n *\t\t\t}\n *\t\t};\n *\n *\t\t// Pattern with multiple properties.\n *\t\tconst pattern = {\n *\t\t\tname: 'span',\n *\t\t\tstyles: {\n *\t\t\t\t'font-weight': 'bold'\n *\t\t\t},\n *\t\t\tclasses: 'highlighted'\n *\t\t};\n *\n * If `MatcherPattern` is given as a `Function`, the function takes a view element as a first and only parameter and\n * the function should decide whether that element matches. If so, it should return what part of the view element has been matched.\n * Otherwise, the function should return `null`. The returned result will be included in `match` property of the object\n * returned by {@link ~Matcher#match} call.\n *\n *\t\t// Match an empty <div> element.\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'div' && element.childCount > 0 ) {\n *\t\t\t\t// Return which part of the element was matched.\n *\t\t\t\treturn { name: true };\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n *\t\t// Match a <p> element with big font (\"heading-like\" element).\n *\t\tconst pattern = element => {\n *\t\t\tif ( element.name == 'p' ) {\n *\t\t\t\tconst fontSize = element.getStyle( 'font-size' );\n *\t\t\t\tconst size = fontSize.match( /(\\d+)/px );\n *\n *\t\t\t\tif ( size && Number( size[ 1 ] ) > 26 ) {\n *\t\t\t\t\treturn { name: true, attribute: [ 'font-size' ] };\n *\t\t\t\t}\n *\t\t\t}\n *\n *\t\t\treturn null;\n *\t\t};\n *\n * `MatcherPattern` is defined in a way that it is a superset of {@link module:engine/view/elementdefinition~ElementDefinition},\n * that is, every `ElementDefinition` also can be used as a `MatcherPattern`.\n *\n * @typedef {String|RegExp|Object|Function} module:engine/view/matcher~MatcherPattern\n *\n * @property {String|RegExp} [name] View element name to match.\n * @property {String|RegExp|Array.<String|RegExp>} [classes] View element's class name(s) to match.\n * @property {Object} [styles] Object with key-value pairs representing styles to match.\n * Each object key represents style name. Value can be given as `String` or `RegExp`.\n * @property {Object} [attributes] Object with key-value pairs representing attributes to match.\n * Each object key represents attribute name. Value can be given as `String` or `RegExp`.\n */\n"]},"metadata":{},"sourceType":"module"}