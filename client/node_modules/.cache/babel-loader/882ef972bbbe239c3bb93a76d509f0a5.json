{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelElement from '../model/element';\nimport ViewAttributeElement from '../view/attributeelement';\nimport DocumentSelection from '../model/documentselection';\nimport ConversionHelpers from './conversionhelpers';\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Downcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\n\nexport default class DowncastHelpers extends ConversionHelpers {\n  /**\n   * Model element to view element conversion helper.\n   *\n   * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'paragraph',\n   *\t\t\tview: 'p'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'paragraph',\n   *\t\t\tview: 'div',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'fancyParagraph',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'p',\n   *\t\t\t\tclasses: 'fancy'\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n   *\t\t\tmodel: 'heading',\n   *\t\t\tview: ( modelElement, viewWriter ) => {\n   *\t\t\t\treturn viewWriter.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) )\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model element to convert.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n   * that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n   * as parameters and returns a view container element.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n  elementToElement(config) {\n    return this.add(downcastElementToElement(config));\n  }\n  /**\n   * Model attribute to view element conversion helper.\n   *\n   * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n   * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: 'strong'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: 'b',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'invert',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'fontSize',\n   *\t\t\t\tvalues: [ 'big', 'small' ]\n   *\t\t\t},\n   *\t\t\tview: {\n   *\t\t\t\tbig: {\n   *\t\t\t\t\tname: 'span',\n   *\t\t\t\t\tstyles: {\n   *\t\t\t\t\t\t'font-size': '1.2em'\n   *\t\t\t\t\t}\n   *\t\t\t\t},\n   *\t\t\t\tsmall: {\n   *\t\t\t\t\tname: 'span',\n   *\t\t\t\t\tstyles: {\n   *\t\t\t\t\t\t'font-size': '0.8em'\n   *\t\t\t\t\t}\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: 'bold',\n   *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n   *\t\t\t\treturn viewWriter.createAttributeElement( 'span', {\n   *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'color',\n   *\t\t\t\tname: '$text'\n   *\t\t\t},\n   *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n   *\t\t\t\treturn viewWriter.createAttributeElement( 'span', {\n   *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #attributeToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n   * of `String`s with possible values if the model attribute is an enumerable.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n   * that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n   * as parameters and returns a view attribute element. If `config.model.values` is\n   * given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  attributeToElement(config) {\n    return this.add(downcastAttributeToElement(config));\n  }\n  /**\n   * Model attribute to view attribute conversion helper.\n   *\n   * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n   * `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>`.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'source',\n   *\t\t\tview: 'src'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'source',\n   *\t\t\tview: 'href',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: {\n   *\t\t\t\tname: 'image',\n   *\t\t\t\tkey: 'source'\n   *\t\t\t},\n   *\t\t\tview: 'src'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: {\n   *\t\t\t\tname: 'styled',\n   *\t\t\t\tvalues: [ 'dark', 'light' ]\n   *\t\t\t},\n   *\t\t\tview: {\n   *\t\t\t\tdark: {\n   *\t\t\t\t\tkey: 'class',\n   *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n   *\t\t\t\t},\n   *\t\t\t\tlight: {\n   *\t\t\t\t\tkey: 'class',\n   *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'styled',\n   *\t\t\tview: modelAttributeValue => ( { key: 'class', value: 'styled-' + modelAttributeValue } )\n   *\t\t} );\n   *\n   * **Note**: Downcasting to a style property requires providing `value` as an object:\n   *\n   *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n   *\t\t\tmodel: 'lineHeight',\n   *\t\t\tview: modelAttributeValue => ( {\n   *\t\t\t\tkey: 'style',\n   *\t\t\t\tvalue: {\n   *\t\t\t\t\t'line-height': modelAttributeValue,\n   *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n   *\t\t\t\t}\n   *\t\t\t} )\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #attributeToAttribute\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n   * the attribute key, possible values and, optionally, an element name to convert from.\n   * @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n   * the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n   * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n   * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n   * `{ key, value }` objects or a functions.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  attributeToAttribute(config) {\n    return this.add(downcastAttributeToAttribute(config));\n  }\n  /**\n   * Model marker to view element conversion helper.\n   *\n   * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n   * is collapsed, only one element is created. For example, model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n   * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: 'marker-search'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: 'search-result',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tattributes: {\n   *\t\t\t\t\t'data-marker': 'search'\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n   *\t\t\tmodel: 'search',\n   *\t\t\tview: ( markerData, viewWriter ) => {\n   *\t\t\t\treturn viewWriter.createUIElement( 'span', {\n   *\t\t\t\t\t'data-marker': 'search',\n   *\t\t\t\t\t'data-start': markerData.isOpening\n   *\t\t\t\t} );\n   *\t\t\t}\n   *\t\t} );\n   *\n   * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n   * receives the `data` object as a parameter and should return an instance of the\n   * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n   * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n   * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` to\n   * the marker end boundary element.\n   *\n   * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #markerToElement\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model marker (or model marker group) to convert.\n   * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n   * that takes the model marker data as a parameter and returns a view UI element.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  markerToElement(config) {\n    return this.add(downcastMarkerToElement(config));\n  }\n  /**\n   * Model marker to highlight conversion helper.\n   *\n   * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n   * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n   *\n   * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n   * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n   * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n   *\n   * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n   * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n   * For example, a model marker set like this: `[<image src=\"foo.jpg\"></image>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>`\n   * in the view.\n   *\n   * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n   * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n   * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n   *\t\t\tmodel: 'comment',\n   *\t\t\tview: { classes: 'new-comment' },\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n   *\t\t\tmodel: 'comment',\n   *\t\t\tview: data => {\n   *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType.\n   *\t\t\t\tconst commentType = data.markerName.split( ':' )[ 1 ];\n   *\n   *\t\t\t\treturn {\n   *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ]\n   *\t\t\t\t};\n   *\t\t\t}\n   *\t\t} );\n   *\n   * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n   * receives the `data` object as a parameter and should return a\n   * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n   * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #markerToHighlight\n   * @param {Object} config Conversion configuration.\n   * @param {String} config.model The name of the model marker (or model marker group) to convert.\n   * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n   * that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n   */\n\n\n  markerToHighlight(config) {\n    return this.add(downcastMarkerToHighlight(config));\n  }\n\n}\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\n\nexport function insertText() {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.consume(data.item, 'insert')) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    const viewText = viewWriter.createText(data.item.data);\n    viewWriter.insert(viewPosition, viewText);\n  };\n}\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\n\nexport function remove() {\n  return (evt, data, conversionApi) => {\n    // Find view range start position by mapping model position at which the remove happened.\n    const viewStart = conversionApi.mapper.toViewPosition(data.position);\n    const modelEnd = data.position.getShiftedBy(data.length);\n    const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {\n      isPhantom: true\n    });\n    const viewRange = conversionApi.writer.createRange(viewStart, viewEnd); // Trim the range to remove in case some UI elements are on the view range boundaries.\n\n    const removed = conversionApi.writer.remove(viewRange.getTrimmed()); // After the range is removed, unbind all view elements from the model.\n    // Range inside view document fragment is used to unbind deeply.\n\n    for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {\n      conversionApi.mapper.unbindViewElement(child);\n    }\n  };\n}\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If a priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\n\nexport function createViewElementFromHighlightDescriptor(writer, descriptor) {\n  const viewElement = writer.createAttributeElement('span', descriptor.attributes);\n\n  if (descriptor.classes) {\n    viewElement._addClass(descriptor.classes);\n  }\n\n  if (descriptor.priority) {\n    viewElement._priority = descriptor.priority;\n  }\n\n  viewElement._id = descriptor.id;\n  return viewElement;\n}\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\n\nexport function convertRangeSelection() {\n  return (evt, data, conversionApi) => {\n    const selection = data.selection;\n\n    if (selection.isCollapsed) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n\n    const viewRanges = [];\n\n    for (const range of selection.getRanges()) {\n      const viewRange = conversionApi.mapper.toViewRange(range);\n      viewRanges.push(viewRange);\n    }\n\n    conversionApi.writer.setSelection(viewRanges, {\n      backward: selection.isBackward\n    });\n  };\n}\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\n\nexport function convertCollapsedSelection() {\n  return (evt, data, conversionApi) => {\n    const selection = data.selection;\n\n    if (!selection.isCollapsed) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(selection, 'selection')) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const modelPosition = selection.getFirstPosition();\n    const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);\n    const brokenPosition = viewWriter.breakAttributes(viewPosition);\n    viewWriter.setSelection(brokenPosition);\n  };\n}\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\n\nexport function clearAttributes() {\n  return (evt, data, conversionApi) => {\n    const viewWriter = conversionApi.writer;\n    const viewSelection = viewWriter.document.selection;\n\n    for (const range of viewSelection.getRanges()) {\n      // Not collapsed selection should not have artifacts.\n      if (range.isCollapsed) {\n        // Position might be in the node removed by the view writer.\n        if (range.end.parent.isAttached()) {\n          conversionApi.writer.mergeAttributes(range.start);\n        }\n      }\n    }\n\n    viewWriter.setSelection(null);\n  };\n}\n/**\n * Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, viewWriter ) => {\n *\t\t\treturn viewWriter.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\n\nexport function wrap(elementCreator) {\n  return (evt, data, conversionApi) => {\n    // Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n    // or the attribute was removed.\n    const oldViewElement = elementCreator(data.attributeOldValue, conversionApi.writer); // Create node to wrap with.\n\n    const newViewElement = elementCreator(data.attributeNewValue, conversionApi.writer);\n\n    if (!oldViewElement && !newViewElement) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const viewSelection = viewWriter.document.selection;\n\n    if (data.item instanceof ModelSelection || data.item instanceof DocumentSelection) {\n      // Selection attribute conversion.\n      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);\n    } else {\n      // Node attribute conversion.\n      let viewRange = conversionApi.mapper.toViewRange(data.range); // First, unwrap the range from current wrapper.\n\n      if (data.attributeOldValue !== null && oldViewElement) {\n        viewRange = viewWriter.unwrap(viewRange, oldViewElement);\n      }\n\n      if (data.attributeNewValue !== null && newViewElement) {\n        viewWriter.wrap(viewRange, newViewElement);\n      }\n    }\n  };\n}\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list, stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}) and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, viewWriter ) => {\n *\t\t\t\tconst text = viewWriter.createText( 'myText' );\n *\t\t\t\tconst myElem = viewWriter.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @returns {Function} Insert element event converter.\n */\n\nexport function insertElement(elementCreator) {\n  return (evt, data, conversionApi) => {\n    const viewElement = elementCreator(data.item, conversionApi.writer);\n\n    if (!viewElement) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, 'insert')) {\n      return;\n    }\n\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(data.item, viewElement);\n    conversionApi.writer.insert(viewPosition, viewElement);\n  };\n}\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\n\nexport function insertUIElement(elementCreator) {\n  return (evt, data, conversionApi) => {\n    // Create two view elements. One will be inserted at the beginning of marker, one at the end.\n    // If marker is collapsed, only \"opening\" element will be inserted.\n    data.isOpening = true;\n    const viewStartElement = elementCreator(data, conversionApi.writer);\n    data.isOpening = false;\n    const viewEndElement = elementCreator(data, conversionApi.writer);\n\n    if (!viewStartElement || !viewEndElement) {\n      return;\n    }\n\n    const markerRange = data.markerRange; // Marker that is collapsed has consumable build differently that non-collapsed one.\n    // For more information see `addMarker` event description.\n    // If marker's range is collapsed - check if it can be consumed.\n\n    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {\n      return;\n    } // If marker's range is not collapsed - consume all items inside.\n\n\n    for (const value of markerRange) {\n      if (!conversionApi.consumable.consume(value.item, evt.name)) {\n        return;\n      }\n    }\n\n    const mapper = conversionApi.mapper;\n    const viewWriter = conversionApi.writer; // Add \"opening\" element.\n\n    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);\n    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName); // Add \"closing\" element only if range is not collapsed.\n\n    if (!markerRange.isCollapsed) {\n      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);\n      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);\n    }\n\n    evt.stop();\n  };\n} // Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// basing on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\n\nfunction removeUIElement() {\n  return (evt, data, conversionApi) => {\n    const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    for (const element of elements) {\n      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n      conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n} // Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\n\n\nfunction changeAttribute(attributeCreator) {\n  return (evt, data, conversionApi) => {\n    const oldAttribute = attributeCreator(data.attributeOldValue, data);\n    const newAttribute = attributeCreator(data.attributeNewValue, data);\n\n    if (!oldAttribute && !newAttribute) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const viewElement = conversionApi.mapper.toViewElement(data.item);\n    const viewWriter = conversionApi.writer; // If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n    // Only elements can have attributes in a view so do not proceed for anything else (#1587).\n\n    if (!viewElement) {\n      /**\n       * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n       * by {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n       * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n       *\t\t\tmodel: 'attribute-name',\n       *\t\t\tview: 'attribute-name'\n       *\t\t} ) );\n       *\n       * and given attribute is used on text node, for example:\n       *\n       *\t\tmodel.change( writer => {\n       *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n       *\t\t} );\n       *\n       * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n       * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n       * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n       * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n       *\n       *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n       *\t\t\tmodel: {\n       *\t\t\t\tkey: 'attribute-name',\n       *\t\t\t\tname: '$text'\n       *\t\t\t},\n       *\t\t\tview: ( value, writer ) => {\n       *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n       *\t\t\t},\n       *\t\t\tconverterPriority: 'high'\n       *\t\t} ) );\n       *\n       * @error conversion-attribute-to-attribute-on-text\n       */\n      throw new CKEditorError('conversion-attribute-to-attribute-on-text: ' + 'Trying to convert text node\\'s attribute with attribute-to-attribute converter.', [data, conversionApi]);\n    } // First remove the old attribute if there was one.\n\n\n    if (data.attributeOldValue !== null && oldAttribute) {\n      if (oldAttribute.key == 'class') {\n        const classes = Array.isArray(oldAttribute.value) ? oldAttribute.value : [oldAttribute.value];\n\n        for (const className of classes) {\n          viewWriter.removeClass(className, viewElement);\n        }\n      } else if (oldAttribute.key == 'style') {\n        const keys = Object.keys(oldAttribute.value);\n\n        for (const key of keys) {\n          viewWriter.removeStyle(key, viewElement);\n        }\n      } else {\n        viewWriter.removeAttribute(oldAttribute.key, viewElement);\n      }\n    } // Then set the new attribute.\n\n\n    if (data.attributeNewValue !== null && newAttribute) {\n      if (newAttribute.key == 'class') {\n        const classes = Array.isArray(newAttribute.value) ? newAttribute.value : [newAttribute.value];\n\n        for (const className of classes) {\n          viewWriter.addClass(className, viewElement);\n        }\n      } else if (newAttribute.key == 'style') {\n        const keys = Object.keys(newAttribute.value);\n\n        for (const key of keys) {\n          viewWriter.setStyle(key, newAttribute.value[key], viewElement);\n        }\n      } else {\n        viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);\n      }\n    }\n  };\n} // Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction highlightText(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    if (!data.item) {\n      return;\n    }\n\n    if (!(data.item instanceof ModelSelection || data.item instanceof DocumentSelection) && !data.item.is('textProxy')) {\n      return;\n    }\n\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    }\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const viewWriter = conversionApi.writer;\n    const viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);\n    const viewSelection = viewWriter.document.selection;\n\n    if (data.item instanceof ModelSelection || data.item instanceof DocumentSelection) {\n      viewWriter.wrap(viewSelection.getFirstRange(), viewElement, viewSelection);\n    } else {\n      const viewRange = conversionApi.mapper.toViewRange(data.range);\n      const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);\n\n      for (const element of rangeAfterWrap.getItems()) {\n        if (element.is('attributeElement') && element.isSimilar(viewElement)) {\n          conversionApi.mapper.bindElementToMarker(element, data.markerName); // One attribute element is enough, because all of them are bound together by the view writer.\n          // Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\n          break;\n        }\n      }\n    }\n  };\n} // Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction highlightElement(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    if (!data.item) {\n      return;\n    }\n\n    if (!(data.item instanceof ModelElement)) {\n      return;\n    }\n\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    }\n\n    if (!conversionApi.consumable.test(data.item, evt.name)) {\n      return;\n    }\n\n    const viewElement = conversionApi.mapper.toViewElement(data.item);\n\n    if (viewElement && viewElement.getCustomProperty('addHighlight')) {\n      // Consume element itself.\n      conversionApi.consumable.consume(data.item, evt.name); // Consume all children nodes.\n\n      for (const value of ModelRange._createIn(data.item)) {\n        conversionApi.consumable.consume(value.item, evt.name);\n      }\n\n      viewElement.getCustomProperty('addHighlight')(viewElement, descriptor, conversionApi.writer);\n      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);\n    }\n  };\n} // Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\n\n\nfunction removeHighlight(highlightDescriptor) {\n  return (evt, data, conversionApi) => {\n    // This conversion makes sense only for non-collapsed range.\n    if (data.markerRange.isCollapsed) {\n      return;\n    }\n\n    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);\n\n    if (!descriptor) {\n      return;\n    } // View element that will be used to unwrap `AttributeElement`s.\n\n\n    const viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor); // Get all elements bound with given marker name.\n\n    const elements = conversionApi.mapper.markerNameToElements(data.markerName);\n\n    if (!elements) {\n      return;\n    }\n\n    for (const element of elements) {\n      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);\n\n      if (element.is('attributeElement')) {\n        conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);\n      } else {\n        // if element.is( 'containerElement' ).\n        element.getCustomProperty('removeHighlight')(element, descriptor.id, conversionApi.writer);\n      }\n    }\n\n    conversionApi.writer.clearClonedElementsGroup(data.markerName);\n    evt.stop();\n  };\n} // Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model element to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view container element.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastElementToElement(config) {\n  config = cloneDeep(config);\n  config.view = normalizeToElementConfig(config.view, 'container');\n  return dispatcher => {\n    dispatcher.on('insert:' + config.model, insertElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n// that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view attribute element. If `config.model.values` is\n// given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastAttributeToElement(config) {\n  config = cloneDeep(config);\n  const modelKey = config.model.key ? config.model.key : config.model;\n  let eventName = 'attribute:' + modelKey;\n\n  if (config.model.name) {\n    eventName += ':' + config.model.name;\n  }\n\n  if (config.model.values) {\n    for (const modelValue of config.model.values) {\n      config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], 'attribute');\n    }\n  } else {\n    config.view = normalizeToElementConfig(config.view, 'attribute');\n  }\n\n  const elementCreator = getFromAttributeCreator(config);\n  return dispatcher => {\n    dispatcher.on(eventName, wrap(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n// the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n// array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  const modelKey = config.model.key ? config.model.key : config.model;\n  let eventName = 'attribute:' + modelKey;\n\n  if (config.model.name) {\n    eventName += ':' + config.model.name;\n  }\n\n  if (config.model.values) {\n    for (const modelValue of config.model.values) {\n      config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);\n    }\n  } else {\n    config.view = normalizeToAttributeConfig(config.view);\n  }\n\n  const elementCreator = getFromAttributeCreator(config);\n  return dispatcher => {\n    dispatcher.on(eventName, changeAttribute(elementCreator), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToElement(config) {\n  config = cloneDeep(config);\n  config.view = normalizeToElementConfig(config.view, 'ui');\n  return dispatcher => {\n    dispatcher.on('addMarker:' + config.model, insertUIElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + config.model, removeUIElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction downcastMarkerToHighlight(config) {\n  return dispatcher => {\n    dispatcher.on('addMarker:' + config.model, highlightText(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('addMarker:' + config.model, highlightElement(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n    dispatcher.on('removeMarker:' + config.model, removeHighlight(config.view), {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\n\n\nfunction normalizeToElementConfig(view, viewElementType) {\n  if (typeof view == 'function') {\n    // If `view` is already a function, don't do anything.\n    return view;\n  }\n\n  return (modelData, viewWriter) => createViewElementFromDefinition(view, viewWriter, viewElementType);\n} // Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\n\n\nfunction createViewElementFromDefinition(viewElementDefinition, viewWriter, viewElementType) {\n  if (typeof viewElementDefinition == 'string') {\n    // If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n    viewElementDefinition = {\n      name: viewElementDefinition\n    };\n  }\n\n  let element;\n  const attributes = Object.assign({}, viewElementDefinition.attributes);\n\n  if (viewElementType == 'container') {\n    element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);\n  } else if (viewElementType == 'attribute') {\n    const options = {\n      priority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n    };\n    element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);\n  } else {\n    // 'ui'.\n    element = viewWriter.createUIElement(viewElementDefinition.name, attributes);\n  }\n\n  if (viewElementDefinition.styles) {\n    const keys = Object.keys(viewElementDefinition.styles);\n\n    for (const key of keys) {\n      viewWriter.setStyle(key, viewElementDefinition.styles[key], element);\n    }\n  }\n\n  if (viewElementDefinition.classes) {\n    const classes = viewElementDefinition.classes;\n\n    if (typeof classes == 'string') {\n      viewWriter.addClass(classes, element);\n    } else {\n      for (const className of classes) {\n        viewWriter.addClass(className, element);\n      }\n    }\n  }\n\n  return element;\n}\n\nfunction getFromAttributeCreator(config) {\n  if (config.model.values) {\n    return (modelAttributeValue, viewWriter) => {\n      const view = config.view[modelAttributeValue];\n\n      if (view) {\n        return view(modelAttributeValue, viewWriter);\n      }\n\n      return null;\n    };\n  } else {\n    return config.view;\n  }\n} // Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\n\n\nfunction normalizeToAttributeConfig(view) {\n  if (typeof view == 'string') {\n    return modelAttributeValue => ({\n      key: view,\n      value: modelAttributeValue\n    });\n  } else if (typeof view == 'object') {\n    // { key, value, ... }\n    if (view.value) {\n      return () => view;\n    } // { key, ... }\n    else {\n        return modelAttributeValue => ({\n          key: view.key,\n          value: modelAttributeValue\n        });\n      }\n  } else {\n    // function.\n    return view;\n  }\n} // Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\n\n\nfunction prepareDescriptor(highlightDescriptor, data, conversionApi) {\n  // If passed descriptor is a creator function, call it. If not, just use passed value.\n  const descriptor = typeof highlightDescriptor == 'function' ? highlightDescriptor(data, conversionApi) : highlightDescriptor;\n\n  if (!descriptor) {\n    return null;\n  } // Apply default descriptor priority.\n\n\n  if (!descriptor.priority) {\n    descriptor.priority = 10;\n  } // Default descriptor id is marker name.\n\n\n  if (!descriptor.id) {\n    descriptor.id = data.markerName;\n  }\n\n  return descriptor;\n}\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js"],"names":["ModelRange","ModelSelection","ModelElement","ViewAttributeElement","DocumentSelection","ConversionHelpers","cloneDeep","CKEditorError","DowncastHelpers","elementToElement","config","add","downcastElementToElement","attributeToElement","downcastAttributeToElement","attributeToAttribute","downcastAttributeToAttribute","markerToElement","downcastMarkerToElement","markerToHighlight","downcastMarkerToHighlight","insertText","evt","data","conversionApi","consumable","consume","item","viewWriter","writer","viewPosition","mapper","toViewPosition","range","start","viewText","createText","insert","remove","viewStart","position","modelEnd","getShiftedBy","length","viewEnd","isPhantom","viewRange","createRange","removed","getTrimmed","child","createRangeIn","getItems","unbindViewElement","createViewElementFromHighlightDescriptor","descriptor","viewElement","createAttributeElement","attributes","classes","_addClass","priority","_priority","_id","id","convertRangeSelection","selection","isCollapsed","viewRanges","getRanges","toViewRange","push","setSelection","backward","isBackward","convertCollapsedSelection","modelPosition","getFirstPosition","brokenPosition","breakAttributes","clearAttributes","viewSelection","document","end","parent","isAttached","mergeAttributes","wrap","elementCreator","oldViewElement","attributeOldValue","newViewElement","attributeNewValue","name","getFirstRange","unwrap","insertElement","bindElements","insertUIElement","isOpening","viewStartElement","viewEndElement","markerRange","value","bindElementToMarker","markerName","stop","removeUIElement","elements","markerNameToElements","element","unbindElementFromMarkerName","clear","createRangeOn","clearClonedElementsGroup","changeAttribute","attributeCreator","oldAttribute","newAttribute","toViewElement","key","Array","isArray","className","removeClass","keys","Object","removeStyle","removeAttribute","addClass","setStyle","setAttribute","highlightText","highlightDescriptor","is","prepareDescriptor","rangeAfterWrap","isSimilar","highlightElement","test","getCustomProperty","_createIn","removeHighlight","viewHighlightElement","view","normalizeToElementConfig","dispatcher","on","model","converterPriority","modelKey","eventName","values","modelValue","getFromAttributeCreator","normalizeToAttributeConfig","viewElementType","modelData","createViewElementFromDefinition","viewElementDefinition","assign","createContainerElement","options","DEFAULT_PRIORITY","createUIElement","styles","modelAttributeValue"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\n\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelElement from '../model/element';\n\nimport ViewAttributeElement from '../view/attributeelement';\nimport DocumentSelection from '../model/documentselection';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Downcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class DowncastHelpers extends ConversionHelpers {\n\t/**\n\t * Model element to view element conversion helper.\n\t *\n\t * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'p'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'div',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'fancyParagraph',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'heading',\n\t *\t\t\tview: ( modelElement, viewWriter ) => {\n\t *\t\t\t\treturn viewWriter.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) )\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model element to convert.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n\t * that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n\t * as parameters and returns a view container element.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( downcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * Model attribute to view element conversion helper.\n\t *\n\t * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n\t * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'strong'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'b',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'invert',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalues: [ 'big', 'small' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tbig: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '1.2em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '0.8em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n\t *\t\t\t\treturn viewWriter.createAttributeElement( 'span', {\n\t *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'color',\n\t *\t\t\t\tname: '$text'\n\t *\t\t\t},\n\t *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n\t *\t\t\t\treturn viewWriter.createAttributeElement( 'span', {\n\t *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n\t * of `String`s with possible values if the model attribute is an enumerable.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n\t * that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n\t * as parameters and returns a view attribute element. If `config.model.values` is\n\t * given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tattributeToElement( config ) {\n\t\treturn this.add( downcastAttributeToElement( config ) );\n\t}\n\n\t/**\n\t * Model attribute to view attribute conversion helper.\n\t *\n\t * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n\t * `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>`.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tview: 'src'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tview: 'href',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'source'\n\t *\t\t\t},\n\t *\t\t\tview: 'src'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'styled',\n\t *\t\t\t\tvalues: [ 'dark', 'light' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tdark: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n\t *\t\t\t\t},\n\t *\t\t\t\tlight: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'styled',\n\t *\t\t\tview: modelAttributeValue => ( { key: 'class', value: 'styled-' + modelAttributeValue } )\n\t *\t\t} );\n\t *\n\t * **Note**: Downcasting to a style property requires providing `value` as an object:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'lineHeight',\n\t *\t\t\tview: modelAttributeValue => ( {\n\t *\t\t\t\tkey: 'style',\n\t *\t\t\t\tvalue: {\n\t *\t\t\t\t\t'line-height': modelAttributeValue,\n\t *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n\t *\t\t\t\t}\n\t *\t\t\t} )\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n\t * the attribute key, possible values and, optionally, an element name to convert from.\n\t * @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n\t * the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n\t * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n\t * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n\t * `{ key, value }` objects or a functions.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( downcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * Model marker to view element conversion helper.\n\t *\n\t * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n\t * is collapsed, only one element is created. For example, model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n\t * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: 'marker-search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: 'search-result',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: ( markerData, viewWriter ) => {\n\t *\t\t\t\treturn viewWriter.createUIElement( 'span', {\n\t *\t\t\t\t\t'data-marker': 'search',\n\t *\t\t\t\t\t'data-start': markerData.isOpening\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n\t * receives the `data` object as a parameter and should return an instance of the\n\t * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n\t * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` to\n\t * the marker end boundary element.\n\t *\n\t * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n\t * that takes the model marker data as a parameter and returns a view UI element.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToElement( config ) {\n\t\treturn this.add( downcastMarkerToElement( config ) );\n\t}\n\n\t/**\n\t * Model marker to highlight conversion helper.\n\t *\n\t * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n\t * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n\t *\n\t * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n\t * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n\t * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n\t *\n\t * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n\t * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n\t * For example, a model marker set like this: `[<image src=\"foo.jpg\"></image>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>`\n\t * in the view.\n\t *\n\t * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n\t * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n\t * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n\t *\t\t\tmodel: 'comment',\n\t *\t\t\tview: { classes: 'new-comment' },\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n\t *\t\t\tmodel: 'comment',\n\t *\t\t\tview: data => {\n\t *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType.\n\t *\t\t\t\tconst commentType = data.markerName.split( ':' )[ 1 ];\n\t *\n\t *\t\t\t\treturn {\n\t *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ]\n\t *\t\t\t\t};\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n\t * receives the `data` object as a parameter and should return a\n\t * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n\t * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToHighlight\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n\t * that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToHighlight( config ) {\n\t\treturn this.add( downcastMarkerToHighlight( config ) );\n\t}\n}\n\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\nexport function insertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\t\tconst viewText = viewWriter.createText( data.item.data );\n\n\t\tviewWriter.insert( viewPosition, viewText );\n\t};\n}\n\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\nexport function remove() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Find view range start position by mapping model position at which the remove happened.\n\t\tconst viewStart = conversionApi.mapper.toViewPosition( data.position );\n\n\t\tconst modelEnd = data.position.getShiftedBy( data.length );\n\t\tconst viewEnd = conversionApi.mapper.toViewPosition( modelEnd, { isPhantom: true } );\n\n\t\tconst viewRange = conversionApi.writer.createRange( viewStart, viewEnd );\n\n\t\t// Trim the range to remove in case some UI elements are on the view range boundaries.\n\t\tconst removed = conversionApi.writer.remove( viewRange.getTrimmed() );\n\n\t\t// After the range is removed, unbind all view elements from the model.\n\t\t// Range inside view document fragment is used to unbind deeply.\n\t\tfor ( const child of conversionApi.writer.createRangeIn( removed ).getItems() ) {\n\t\t\tconversionApi.mapper.unbindViewElement( child );\n\t\t}\n\t};\n}\n\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If a priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\nexport function createViewElementFromHighlightDescriptor( writer, descriptor ) {\n\tconst viewElement = writer.createAttributeElement( 'span', descriptor.attributes );\n\n\tif ( descriptor.classes ) {\n\t\tviewElement._addClass( descriptor.classes );\n\t}\n\n\tif ( descriptor.priority ) {\n\t\tviewElement._priority = descriptor.priority;\n\t}\n\n\tviewElement._id = descriptor.id;\n\n\treturn viewElement;\n}\n\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\nexport function convertRangeSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( const range of selection.getRanges() ) {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( range );\n\t\t\tviewRanges.push( viewRange );\n\t\t}\n\n\t\tconversionApi.writer.setSelection( viewRanges, { backward: selection.isBackward } );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\nexport function convertCollapsedSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst modelPosition = selection.getFirstPosition();\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( modelPosition );\n\t\tconst brokenPosition = viewWriter.breakAttributes( viewPosition );\n\n\t\tviewWriter.setSelection( brokenPosition );\n\t};\n}\n\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\nexport function clearAttributes() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t// Not collapsed selection should not have artifacts.\n\t\t\tif ( range.isCollapsed ) {\n\t\t\t\t// Position might be in the node removed by the view writer.\n\t\t\t\tif ( range.end.parent.isAttached() ) {\n\t\t\t\t\tconversionApi.writer.mergeAttributes( range.start );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tviewWriter.setSelection( null );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, viewWriter ) => {\n *\t\t\treturn viewWriter.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\nexport function wrap( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n\t\t// or the attribute was removed.\n\t\tconst oldViewElement = elementCreator( data.attributeOldValue, conversionApi.writer );\n\n\t\t// Create node to wrap with.\n\t\tconst newViewElement = elementCreator( data.attributeNewValue, conversionApi.writer );\n\n\t\tif ( !oldViewElement && !newViewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\t// Selection attribute conversion.\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), newViewElement );\n\t\t} else {\n\t\t\t// Node attribute conversion.\n\t\t\tlet viewRange = conversionApi.mapper.toViewRange( data.range );\n\n\t\t\t// First, unwrap the range from current wrapper.\n\t\t\tif ( data.attributeOldValue !== null && oldViewElement ) {\n\t\t\t\tviewRange = viewWriter.unwrap( viewRange, oldViewElement );\n\t\t\t}\n\n\t\t\tif ( data.attributeNewValue !== null && newViewElement ) {\n\t\t\t\tviewWriter.wrap( viewRange, newViewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list, stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}) and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, viewWriter ) => {\n *\t\t\t\tconst text = viewWriter.createText( 'myText' );\n *\t\t\t\tconst myElem = viewWriter.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewElement = elementCreator( data.item, conversionApi.writer );\n\n\t\tif ( !viewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n\t\tconversionApi.writer.insert( viewPosition, viewElement );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertUIElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Create two view elements. One will be inserted at the beginning of marker, one at the end.\n\t\t// If marker is collapsed, only \"opening\" element will be inserted.\n\t\tdata.isOpening = true;\n\t\tconst viewStartElement = elementCreator( data, conversionApi.writer );\n\n\t\tdata.isOpening = false;\n\t\tconst viewEndElement = elementCreator( data, conversionApi.writer );\n\n\t\tif ( !viewStartElement || !viewEndElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst markerRange = data.markerRange;\n\n\t\t// Marker that is collapsed has consumable build differently that non-collapsed one.\n\t\t// For more information see `addMarker` event description.\n\t\t// If marker's range is collapsed - check if it can be consumed.\n\t\tif ( markerRange.isCollapsed && !conversionApi.consumable.consume( markerRange, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If marker's range is not collapsed - consume all items inside.\n\t\tfor ( const value of markerRange ) {\n\t\t\tif ( !conversionApi.consumable.consume( value.item, evt.name ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst mapper = conversionApi.mapper;\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// Add \"opening\" element.\n\t\tviewWriter.insert( mapper.toViewPosition( markerRange.start ), viewStartElement );\n\t\tconversionApi.mapper.bindElementToMarker( viewStartElement, data.markerName );\n\n\t\t// Add \"closing\" element only if range is not collapsed.\n\t\tif ( !markerRange.isCollapsed ) {\n\t\t\tviewWriter.insert( mapper.toViewPosition( markerRange.end ), viewEndElement );\n\t\t\tconversionApi.mapper.bindElementToMarker( viewEndElement, data.markerName );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n// Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// basing on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\nfunction removeUIElement() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\t\t\tconversionApi.writer.clear( conversionApi.writer.createRangeOn( element ), element );\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\t};\n}\n\n// Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\nfunction changeAttribute( attributeCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst oldAttribute = attributeCreator( data.attributeOldValue, data );\n\t\tconst newAttribute = attributeCreator( data.attributeNewValue, data );\n\n\t\tif ( !oldAttribute && !newAttribute ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n\t\t// Only elements can have attributes in a view so do not proceed for anything else (#1587).\n\t\tif ( !viewElement ) {\n\t\t\t/**\n\t\t\t * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n\t\t\t * by {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n\t\t\t * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t\t\t *\t\t\tmodel: 'attribute-name',\n\t\t\t *\t\t\tview: 'attribute-name'\n\t\t\t *\t\t} ) );\n\t\t\t *\n\t\t\t * and given attribute is used on text node, for example:\n\t\t\t *\n\t\t\t *\t\tmodel.change( writer => {\n\t\t\t *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n\t\t\t * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n\t\t\t * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n\t\t\t * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t\t\t *\t\t\tmodel: {\n\t\t\t *\t\t\t\tkey: 'attribute-name',\n\t\t\t *\t\t\t\tname: '$text'\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tview: ( value, writer ) => {\n\t\t\t *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tconverterPriority: 'high'\n\t\t\t *\t\t} ) );\n\t\t\t *\n\t\t\t * @error conversion-attribute-to-attribute-on-text\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'conversion-attribute-to-attribute-on-text: ' +\n\t\t\t\t'Trying to convert text node\\'s attribute with attribute-to-attribute converter.',\n\t\t\t\t[ data, conversionApi ]\n\t\t\t);\n\t\t}\n\n\t\t// First remove the old attribute if there was one.\n\t\tif ( data.attributeOldValue !== null && oldAttribute ) {\n\t\t\tif ( oldAttribute.key == 'class' ) {\n\t\t\t\tconst classes = Array.isArray( oldAttribute.value ) ? oldAttribute.value : [ oldAttribute.value ];\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.removeClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( oldAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( oldAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.removeStyle( key, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.removeAttribute( oldAttribute.key, viewElement );\n\t\t\t}\n\t\t}\n\n\t\t// Then set the new attribute.\n\t\tif ( data.attributeNewValue !== null && newAttribute ) {\n\t\t\tif ( newAttribute.key == 'class' ) {\n\t\t\t\tconst classes = Array.isArray( newAttribute.value ) ? newAttribute.value : [ newAttribute.value ];\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.addClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( newAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( newAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.setStyle( key, newAttribute.value[ key ], viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.setAttribute( newAttribute.key, newAttribute.value, viewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightText( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !data.item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) && !data.item.is( 'textProxy' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewElement = createViewElementFromHighlightDescriptor( viewWriter, descriptor );\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), viewElement, viewSelection );\n\t\t} else {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( data.range );\n\t\t\tconst rangeAfterWrap = viewWriter.wrap( viewRange, viewElement );\n\n\t\t\tfor ( const element of rangeAfterWrap.getItems() ) {\n\t\t\t\tif ( element.is( 'attributeElement' ) && element.isSimilar( viewElement ) ) {\n\t\t\t\t\tconversionApi.mapper.bindElementToMarker( element, data.markerName );\n\n\t\t\t\t\t// One attribute element is enough, because all of them are bound together by the view writer.\n\t\t\t\t\t// Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightElement( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !data.item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelElement ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.test( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\n\t\tif ( viewElement && viewElement.getCustomProperty( 'addHighlight' ) ) {\n\t\t\t// Consume element itself.\n\t\t\tconversionApi.consumable.consume( data.item, evt.name );\n\n\t\t\t// Consume all children nodes.\n\t\t\tfor ( const value of ModelRange._createIn( data.item ) ) {\n\t\t\t\tconversionApi.consumable.consume( value.item, evt.name );\n\t\t\t}\n\n\t\t\tviewElement.getCustomProperty( 'addHighlight' )( viewElement, descriptor, conversionApi.writer );\n\n\t\t\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction removeHighlight( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// This conversion makes sense only for non-collapsed range.\n\t\tif ( data.markerRange.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// View element that will be used to unwrap `AttributeElement`s.\n\t\tconst viewHighlightElement = createViewElementFromHighlightDescriptor( conversionApi.writer, descriptor );\n\n\t\t// Get all elements bound with given marker name.\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tconversionApi.writer.unwrap( conversionApi.writer.createRangeOn( element ), viewHighlightElement );\n\t\t\t} else {\n\t\t\t\t// if element.is( 'containerElement' ).\n\t\t\t\telement.getCustomProperty( 'removeHighlight' )( element, descriptor.id, conversionApi.writer );\n\t\t\t}\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\t};\n}\n\n// Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model element to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view container element.\n// @returns {Function} Conversion helper.\nfunction downcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = normalizeToElementConfig( config.view, 'container' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'insert:' + config.model, insertElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n// that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view attribute element. If `config.model.values` is\n// given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = normalizeToElementConfig( config.view[ modelValue ], 'attribute' );\n\t\t}\n\t} else {\n\t\tconfig.view = normalizeToElementConfig( config.view, 'attribute' );\n\t}\n\n\tconst elementCreator = getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, wrap( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n// the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n// array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = normalizeToAttributeConfig( config.view[ modelValue ] );\n\t\t}\n\t} else {\n\t\tconfig.view = normalizeToAttributeConfig( config.view );\n\t}\n\n\tconst elementCreator = getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, changeAttribute( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = normalizeToElementConfig( config.view, 'ui' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, insertUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToHighlight( config ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightText( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeHighlight( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\nfunction normalizeToElementConfig( view, viewElementType ) {\n\tif ( typeof view == 'function' ) {\n\t\t// If `view` is already a function, don't do anything.\n\t\treturn view;\n\t}\n\n\treturn ( modelData, viewWriter ) => createViewElementFromDefinition( view, viewWriter, viewElementType );\n}\n\n// Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\nfunction createViewElementFromDefinition( viewElementDefinition, viewWriter, viewElementType ) {\n\tif ( typeof viewElementDefinition == 'string' ) {\n\t\t// If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n\t\tviewElementDefinition = { name: viewElementDefinition };\n\t}\n\n\tlet element;\n\tconst attributes = Object.assign( {}, viewElementDefinition.attributes );\n\n\tif ( viewElementType == 'container' ) {\n\t\telement = viewWriter.createContainerElement( viewElementDefinition.name, attributes );\n\t} else if ( viewElementType == 'attribute' ) {\n\t\tconst options = {\n\t\t\tpriority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n\t\t};\n\n\t\telement = viewWriter.createAttributeElement( viewElementDefinition.name, attributes, options );\n\t} else {\n\t\t// 'ui'.\n\t\telement = viewWriter.createUIElement( viewElementDefinition.name, attributes );\n\t}\n\n\tif ( viewElementDefinition.styles ) {\n\t\tconst keys = Object.keys( viewElementDefinition.styles );\n\n\t\tfor ( const key of keys ) {\n\t\t\tviewWriter.setStyle( key, viewElementDefinition.styles[ key ], element );\n\t\t}\n\t}\n\n\tif ( viewElementDefinition.classes ) {\n\t\tconst classes = viewElementDefinition.classes;\n\n\t\tif ( typeof classes == 'string' ) {\n\t\t\tviewWriter.addClass( classes, element );\n\t\t} else {\n\t\t\tfor ( const className of classes ) {\n\t\t\t\tviewWriter.addClass( className, element );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn element;\n}\n\nfunction getFromAttributeCreator( config ) {\n\tif ( config.model.values ) {\n\t\treturn ( modelAttributeValue, viewWriter ) => {\n\t\t\tconst view = config.view[ modelAttributeValue ];\n\n\t\t\tif ( view ) {\n\t\t\t\treturn view( modelAttributeValue, viewWriter );\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\t} else {\n\t\treturn config.view;\n\t}\n}\n\n// Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\nfunction normalizeToAttributeConfig( view ) {\n\tif ( typeof view == 'string' ) {\n\t\treturn modelAttributeValue => ( { key: view, value: modelAttributeValue } );\n\t} else if ( typeof view == 'object' ) {\n\t\t// { key, value, ... }\n\t\tif ( view.value ) {\n\t\t\treturn () => view;\n\t\t}\n\t\t// { key, ... }\n\t\telse {\n\t\t\treturn modelAttributeValue => ( { key: view.key, value: modelAttributeValue } );\n\t\t}\n\t} else {\n\t\t// function.\n\t\treturn view;\n\t}\n}\n\n// Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\nfunction prepareDescriptor( highlightDescriptor, data, conversionApi ) {\n\t// If passed descriptor is a creator function, call it. If not, just use passed value.\n\tconst descriptor = typeof highlightDescriptor == 'function' ?\n\t\thighlightDescriptor( data, conversionApi ) :\n\t\thighlightDescriptor;\n\n\tif ( !descriptor ) {\n\t\treturn null;\n\t}\n\n\t// Apply default descriptor priority.\n\tif ( !descriptor.priority ) {\n\t\tdescriptor.priority = 10;\n\t}\n\n\t// Default descriptor id is marker name.\n\tif ( !descriptor.id ) {\n\t\tdescriptor.id = data.markerName;\n\t}\n\n\treturn descriptor;\n}\n\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */\n"]},"metadata":{},"sourceType":"module"}