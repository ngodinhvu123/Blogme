{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paragraph/paragraph\n */\nimport ParagraphCommand from './paragraphcommand';\nimport InsertParagraphCommand from './insertparagraphcommand';\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n/**\n * The paragraph feature for the editor.\n *\n * It introduces the `<paragraph>` element in the model which renders as a `<p>` element in the DOM and data.\n *\n * It also brings two editors commands:\n *\n * * The {@link module:paragraph/paragraphcommand~ParagraphCommand `'paragraph'`} command that converts all\n * blocks in the model selection into paragraphs.\n * * The {@link module:paragraph/insertparagraphcommand~InsertParagraphCommand `'insertParagraph'`} command\n * that inserts a new paragraph at a specified location in the model.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class Paragraph extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'Paragraph';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const model = editor.model;\n    const data = editor.data;\n    editor.commands.add('paragraph', new ParagraphCommand(editor));\n    editor.commands.add('insertParagraph', new InsertParagraphCommand(editor)); // Schema.\n\n    model.schema.register('paragraph', {\n      inheritAllFrom: '$block'\n    });\n    editor.conversion.elementToElement({\n      model: 'paragraph',\n      view: 'p'\n    }); // Content autoparagraphing. --------------------------------------------------\n    // Handles element which has not been converted by any plugin and checks if it would be converted if\n    // we wrap it in a paragraph or change it to a paragraph.\n\n    editor.conversion.for('upcast').elementToElement({\n      model: (viewElement, modelWriter) => {\n        if (!Paragraph.paragraphLikeElements.has(viewElement.name)) {\n          return null;\n        } // Do not auto-paragraph empty elements.\n\n\n        if (viewElement.isEmpty) {\n          return null;\n        }\n\n        return modelWriter.createElement('paragraph');\n      },\n      converterPriority: 'low'\n    });\n    data.upcastDispatcher.on('element', (evt, data, conversionApi) => {\n      // Do not try auto-paragraphing if the element was already converted.\n      if (!conversionApi.consumable.test(data.viewItem, {\n        name: data.viewItem.name\n      })) {\n        return;\n      } // If the element is not paragraph-like try wrapping it in a paragraph.\n\n\n      if (isParagraphable(data.viewItem, data.modelCursor, conversionApi.schema)) {\n        Object.assign(data, wrapInParagraph(data.viewItem, data.modelCursor, conversionApi));\n      }\n    }, {\n      priority: 'low'\n    }); // Handles not converted text nodes and checks if would be converted if we wraps then by a paragraph.\n\n    data.upcastDispatcher.on('text', (evt, data, conversionApi) => {\n      // When node is already converted then do nothing.\n      if (data.modelRange) {\n        return;\n      }\n\n      if (isParagraphable(data.viewItem, data.modelCursor, conversionApi.schema)) {\n        Object.assign(data, wrapInParagraph(data.viewItem, data.modelCursor, conversionApi));\n      }\n    }, {\n      priority: 'lowest'\n    }); // Empty roots autoparagraphing. -----------------------------------------------\n    // Post-fixer which takes care of adding empty paragraph elements to empty roots.\n    // Besides fixing content on #changesDone we also need to handle editor.data#ready event because\n    // if initial data is empty or setData() wasn't even called there will be no #change fired.\n\n    model.document.registerPostFixer(writer => this._autoparagraphEmptyRoots(writer));\n    editor.data.on('ready', () => {\n      model.enqueueChange('transparent', writer => this._autoparagraphEmptyRoots(writer));\n    }, {\n      priority: 'lowest'\n    });\n  }\n  /**\n   * Fixes all empty roots.\n   *\n   * @private\n   * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n   */\n\n\n  _autoparagraphEmptyRoots(writer) {\n    const model = this.editor.model;\n\n    for (const rootName of model.document.getRootNames()) {\n      const root = model.document.getRoot(rootName);\n\n      if (root.isEmpty && root.rootName != '$graveyard') {\n        // If paragraph element is allowed in the root, create paragraph element.\n        if (model.schema.checkChild(root, 'paragraph')) {\n          writer.insertElement('paragraph', root);\n          return true;\n        }\n      }\n    }\n  }\n\n}\n/**\n * A list of element names which should be treated by the autoparagraphing algorithms as\n * paragraph-like. This means that e.g. the following content:\n *\n *\t\t<h1>Foo</h1>\n *\t\t<table>\n *\t\t\t<tr>\n *\t\t\t\t<td>X</td>\n *\t\t\t\t<td>\n *\t\t\t\t\t<ul>\n *\t\t\t\t\t\t<li>Y</li>\n *\t\t\t\t\t\t<li>Z</li>\n *\t\t\t\t\t</ul>\n *\t\t\t\t</td>\n *\t\t\t</tr>\n *\t\t</table>\n *\n * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.\n * Hence, if none of the features is going to convert those elements the above content will be automatically handled\n * by the paragraph feature and converted to:\n *\n *\t\t<p>Foo</p>\n *\t\t<p>X</p>\n *\t\t<p>Y</p>\n *\t\t<p>Z</p>\n *\n * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements\n * have a priority upon conversion.\n *\n * @member {Set.<String>} module:paragraph/paragraph~Paragraph.paragraphLikeElements\n */\n\nParagraph.paragraphLikeElements = new Set(['blockquote', 'dd', 'div', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'p', 'td']);\n\nfunction wrapInParagraph(input, position, conversionApi) {\n  const paragraph = conversionApi.writer.createElement('paragraph');\n  conversionApi.writer.insert(paragraph, position);\n  return conversionApi.convertItem(input, conversionApi.writer.createPositionAt(paragraph, 0));\n}\n\nfunction isParagraphable(node, position, schema) {\n  const context = schema.createContext(position); // When paragraph is allowed in this context...\n\n  if (!schema.checkChild(context, 'paragraph')) {\n    return false;\n  } // And a node would be allowed in this paragraph...\n\n\n  if (!schema.checkChild(context.push('paragraph'), node)) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-paragraph/src/paragraph.js"],"names":["ParagraphCommand","InsertParagraphCommand","Plugin","Paragraph","pluginName","init","editor","model","data","commands","add","schema","register","inheritAllFrom","conversion","elementToElement","view","for","viewElement","modelWriter","paragraphLikeElements","has","name","isEmpty","createElement","converterPriority","upcastDispatcher","on","evt","conversionApi","consumable","test","viewItem","isParagraphable","modelCursor","Object","assign","wrapInParagraph","priority","modelRange","document","registerPostFixer","writer","_autoparagraphEmptyRoots","enqueueChange","rootName","getRootNames","root","getRoot","checkChild","insertElement","Set","input","position","paragraph","insert","convertItem","createPositionAt","node","context","createContext","push"],"mappings":"AAAA;;;;;AAKA;;;AAIA,OAAOA,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,sBAAP,MAAmC,0BAAnC;AAEA,OAAOC,MAAP,MAAmB,qCAAnB;AAEA;;;;;;;;;;;;;;;AAcA,eAAe,MAAMC,SAAN,SAAwBD,MAAxB,CAA+B;AAC7C;;;AAGA,aAAWE,UAAX,GAAwB;AACvB,WAAO,WAAP;AACA;AAED;;;;;AAGAC,EAAAA,IAAI,GAAG;AACN,UAAMC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMC,KAAK,GAAGD,MAAM,CAACC,KAArB;AACA,UAAMC,IAAI,GAAGF,MAAM,CAACE,IAApB;AAEAF,IAAAA,MAAM,CAACG,QAAP,CAAgBC,GAAhB,CAAqB,WAArB,EAAkC,IAAIV,gBAAJ,CAAsBM,MAAtB,CAAlC;AACAA,IAAAA,MAAM,CAACG,QAAP,CAAgBC,GAAhB,CAAqB,iBAArB,EAAwC,IAAIT,sBAAJ,CAA4BK,MAA5B,CAAxC,EANM,CAQN;;AACAC,IAAAA,KAAK,CAACI,MAAN,CAAaC,QAAb,CAAuB,WAAvB,EAAoC;AAAEC,MAAAA,cAAc,EAAE;AAAlB,KAApC;AAEAP,IAAAA,MAAM,CAACQ,UAAP,CAAkBC,gBAAlB,CAAoC;AAAER,MAAAA,KAAK,EAAE,WAAT;AAAsBS,MAAAA,IAAI,EAAE;AAA5B,KAApC,EAXM,CAaN;AAEA;AACA;;AACAV,IAAAA,MAAM,CAACQ,UAAP,CAAkBG,GAAlB,CAAuB,QAAvB,EAAkCF,gBAAlC,CAAoD;AACnDR,MAAAA,KAAK,EAAE,CAAEW,WAAF,EAAeC,WAAf,KAAgC;AACtC,YAAK,CAAChB,SAAS,CAACiB,qBAAV,CAAgCC,GAAhC,CAAqCH,WAAW,CAACI,IAAjD,CAAN,EAAgE;AAC/D,iBAAO,IAAP;AACA,SAHqC,CAKtC;;;AACA,YAAKJ,WAAW,CAACK,OAAjB,EAA2B;AAC1B,iBAAO,IAAP;AACA;;AAED,eAAOJ,WAAW,CAACK,aAAZ,CAA2B,WAA3B,CAAP;AACA,OAZkD;AAanDC,MAAAA,iBAAiB,EAAE;AAbgC,KAApD;AAgBAjB,IAAAA,IAAI,CAACkB,gBAAL,CAAsBC,EAAtB,CAA0B,SAA1B,EAAqC,CAAEC,GAAF,EAAOpB,IAAP,EAAaqB,aAAb,KAAgC;AACpE;AACA,UAAK,CAACA,aAAa,CAACC,UAAd,CAAyBC,IAAzB,CAA+BvB,IAAI,CAACwB,QAApC,EAA8C;AAAEV,QAAAA,IAAI,EAAEd,IAAI,CAACwB,QAAL,CAAcV;AAAtB,OAA9C,CAAN,EAAqF;AACpF;AACA,OAJmE,CAMpE;;;AACA,UAAKW,eAAe,CAAEzB,IAAI,CAACwB,QAAP,EAAiBxB,IAAI,CAAC0B,WAAtB,EAAmCL,aAAa,CAAClB,MAAjD,CAApB,EAAgF;AAC/EwB,QAAAA,MAAM,CAACC,MAAP,CAAe5B,IAAf,EAAqB6B,eAAe,CAAE7B,IAAI,CAACwB,QAAP,EAAiBxB,IAAI,CAAC0B,WAAtB,EAAmCL,aAAnC,CAApC;AACA;AACD,KAVD,EAUG;AAAES,MAAAA,QAAQ,EAAE;AAAZ,KAVH,EAjCM,CA6CN;;AACA9B,IAAAA,IAAI,CAACkB,gBAAL,CAAsBC,EAAtB,CAA0B,MAA1B,EAAkC,CAAEC,GAAF,EAAOpB,IAAP,EAAaqB,aAAb,KAAgC;AACjE;AACA,UAAKrB,IAAI,CAAC+B,UAAV,EAAuB;AACtB;AACA;;AAED,UAAKN,eAAe,CAAEzB,IAAI,CAACwB,QAAP,EAAiBxB,IAAI,CAAC0B,WAAtB,EAAmCL,aAAa,CAAClB,MAAjD,CAApB,EAAgF;AAC/EwB,QAAAA,MAAM,CAACC,MAAP,CAAe5B,IAAf,EAAqB6B,eAAe,CAAE7B,IAAI,CAACwB,QAAP,EAAiBxB,IAAI,CAAC0B,WAAtB,EAAmCL,aAAnC,CAApC;AACA;AACD,KATD,EASG;AAAES,MAAAA,QAAQ,EAAE;AAAZ,KATH,EA9CM,CAyDN;AAEA;AACA;AACA;;AACA/B,IAAAA,KAAK,CAACiC,QAAN,CAAeC,iBAAf,CAAkCC,MAAM,IAAI,KAAKC,wBAAL,CAA+BD,MAA/B,CAA5C;AAEApC,IAAAA,MAAM,CAACE,IAAP,CAAYmB,EAAZ,CAAgB,OAAhB,EAAyB,MAAM;AAC9BpB,MAAAA,KAAK,CAACqC,aAAN,CAAqB,aAArB,EAAoCF,MAAM,IAAI,KAAKC,wBAAL,CAA+BD,MAA/B,CAA9C;AACA,KAFD,EAEG;AAAEJ,MAAAA,QAAQ,EAAE;AAAZ,KAFH;AAGA;AAED;;;;;;;;AAMAK,EAAAA,wBAAwB,CAAED,MAAF,EAAW;AAClC,UAAMnC,KAAK,GAAG,KAAKD,MAAL,CAAYC,KAA1B;;AAEA,SAAM,MAAMsC,QAAZ,IAAwBtC,KAAK,CAACiC,QAAN,CAAeM,YAAf,EAAxB,EAAwD;AACvD,YAAMC,IAAI,GAAGxC,KAAK,CAACiC,QAAN,CAAeQ,OAAf,CAAwBH,QAAxB,CAAb;;AAEA,UAAKE,IAAI,CAACxB,OAAL,IAAgBwB,IAAI,CAACF,QAAL,IAAiB,YAAtC,EAAqD;AACpD;AACA,YAAKtC,KAAK,CAACI,MAAN,CAAasC,UAAb,CAAyBF,IAAzB,EAA+B,WAA/B,CAAL,EAAoD;AACnDL,UAAAA,MAAM,CAACQ,aAAP,CAAsB,WAAtB,EAAmCH,IAAnC;AAEA,iBAAO,IAAP;AACA;AACD;AACD;AACD;;AArG4C;AAwG9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA5C,SAAS,CAACiB,qBAAV,GAAkC,IAAI+B,GAAJ,CAAS,CAC1C,YAD0C,EAE1C,IAF0C,EAG1C,KAH0C,EAI1C,IAJ0C,EAK1C,IAL0C,EAM1C,IAN0C,EAO1C,IAP0C,EAQ1C,IAR0C,EAS1C,IAT0C,EAU1C,IAV0C,EAW1C,IAX0C,EAY1C,GAZ0C,EAa1C,IAb0C,CAAT,CAAlC;;AAgBA,SAASd,eAAT,CAA0Be,KAA1B,EAAiCC,QAAjC,EAA2CxB,aAA3C,EAA2D;AAC1D,QAAMyB,SAAS,GAAGzB,aAAa,CAACa,MAAd,CAAqBlB,aAArB,CAAoC,WAApC,CAAlB;AAEAK,EAAAA,aAAa,CAACa,MAAd,CAAqBa,MAArB,CAA6BD,SAA7B,EAAwCD,QAAxC;AACA,SAAOxB,aAAa,CAAC2B,WAAd,CAA2BJ,KAA3B,EAAkCvB,aAAa,CAACa,MAAd,CAAqBe,gBAArB,CAAuCH,SAAvC,EAAkD,CAAlD,CAAlC,CAAP;AACA;;AAED,SAASrB,eAAT,CAA0ByB,IAA1B,EAAgCL,QAAhC,EAA0C1C,MAA1C,EAAmD;AAClD,QAAMgD,OAAO,GAAGhD,MAAM,CAACiD,aAAP,CAAsBP,QAAtB,CAAhB,CADkD,CAGlD;;AACA,MAAK,CAAC1C,MAAM,CAACsC,UAAP,CAAmBU,OAAnB,EAA4B,WAA5B,CAAN,EAAkD;AACjD,WAAO,KAAP;AACA,GANiD,CAQlD;;;AACA,MAAK,CAAChD,MAAM,CAACsC,UAAP,CAAmBU,OAAO,CAACE,IAAR,CAAc,WAAd,CAAnB,EAAgDH,IAAhD,CAAN,EAA+D;AAC9D,WAAO,KAAP;AACA;;AAED,SAAO,IAAP;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module paragraph/paragraph\n */\n\nimport ParagraphCommand from './paragraphcommand';\nimport InsertParagraphCommand from './insertparagraphcommand';\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n\n/**\n * The paragraph feature for the editor.\n *\n * It introduces the `<paragraph>` element in the model which renders as a `<p>` element in the DOM and data.\n *\n * It also brings two editors commands:\n *\n * * The {@link module:paragraph/paragraphcommand~ParagraphCommand `'paragraph'`} command that converts all\n * blocks in the model selection into paragraphs.\n * * The {@link module:paragraph/insertparagraphcommand~InsertParagraphCommand `'insertParagraph'`} command\n * that inserts a new paragraph at a specified location in the model.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Paragraph extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Paragraph';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst data = editor.data;\n\n\t\teditor.commands.add( 'paragraph', new ParagraphCommand( editor ) );\n\t\teditor.commands.add( 'insertParagraph', new InsertParagraphCommand( editor ) );\n\n\t\t// Schema.\n\t\tmodel.schema.register( 'paragraph', { inheritAllFrom: '$block' } );\n\n\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );\n\n\t\t// Content autoparagraphing. --------------------------------------------------\n\n\t\t// Handles element which has not been converted by any plugin and checks if it would be converted if\n\t\t// we wrap it in a paragraph or change it to a paragraph.\n\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t\t\tmodel: ( viewElement, modelWriter ) => {\n\t\t\t\tif ( !Paragraph.paragraphLikeElements.has( viewElement.name ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Do not auto-paragraph empty elements.\n\t\t\t\tif ( viewElement.isEmpty ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\treturn modelWriter.createElement( 'paragraph' );\n\t\t\t},\n\t\t\tconverterPriority: 'low'\n\t\t} );\n\n\t\tdata.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n\t\t\t// Do not try auto-paragraphing if the element was already converted.\n\t\t\tif ( !conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If the element is not paragraph-like try wrapping it in a paragraph.\n\t\t\tif ( isParagraphable( data.viewItem, data.modelCursor, conversionApi.schema ) ) {\n\t\t\t\tObject.assign( data, wrapInParagraph( data.viewItem, data.modelCursor, conversionApi ) );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// Handles not converted text nodes and checks if would be converted if we wraps then by a paragraph.\n\t\tdata.upcastDispatcher.on( 'text', ( evt, data, conversionApi ) => {\n\t\t\t// When node is already converted then do nothing.\n\t\t\tif ( data.modelRange ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isParagraphable( data.viewItem, data.modelCursor, conversionApi.schema ) ) {\n\t\t\t\tObject.assign( data, wrapInParagraph( data.viewItem, data.modelCursor, conversionApi ) );\n\t\t\t}\n\t\t}, { priority: 'lowest' } );\n\n\t\t// Empty roots autoparagraphing. -----------------------------------------------\n\n\t\t// Post-fixer which takes care of adding empty paragraph elements to empty roots.\n\t\t// Besides fixing content on #changesDone we also need to handle editor.data#ready event because\n\t\t// if initial data is empty or setData() wasn't even called there will be no #change fired.\n\t\tmodel.document.registerPostFixer( writer => this._autoparagraphEmptyRoots( writer ) );\n\n\t\teditor.data.on( 'ready', () => {\n\t\t\tmodel.enqueueChange( 'transparent', writer => this._autoparagraphEmptyRoots( writer ) );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Fixes all empty roots.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n\t */\n\t_autoparagraphEmptyRoots( writer ) {\n\t\tconst model = this.editor.model;\n\n\t\tfor ( const rootName of model.document.getRootNames() ) {\n\t\t\tconst root = model.document.getRoot( rootName );\n\n\t\t\tif ( root.isEmpty && root.rootName != '$graveyard' ) {\n\t\t\t\t// If paragraph element is allowed in the root, create paragraph element.\n\t\t\t\tif ( model.schema.checkChild( root, 'paragraph' ) ) {\n\t\t\t\t\twriter.insertElement( 'paragraph', root );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A list of element names which should be treated by the autoparagraphing algorithms as\n * paragraph-like. This means that e.g. the following content:\n *\n *\t\t<h1>Foo</h1>\n *\t\t<table>\n *\t\t\t<tr>\n *\t\t\t\t<td>X</td>\n *\t\t\t\t<td>\n *\t\t\t\t\t<ul>\n *\t\t\t\t\t\t<li>Y</li>\n *\t\t\t\t\t\t<li>Z</li>\n *\t\t\t\t\t</ul>\n *\t\t\t\t</td>\n *\t\t\t</tr>\n *\t\t</table>\n *\n * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.\n * Hence, if none of the features is going to convert those elements the above content will be automatically handled\n * by the paragraph feature and converted to:\n *\n *\t\t<p>Foo</p>\n *\t\t<p>X</p>\n *\t\t<p>Y</p>\n *\t\t<p>Z</p>\n *\n * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements\n * have a priority upon conversion.\n *\n * @member {Set.<String>} module:paragraph/paragraph~Paragraph.paragraphLikeElements\n */\nParagraph.paragraphLikeElements = new Set( [\n\t'blockquote',\n\t'dd',\n\t'div',\n\t'dt',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'li',\n\t'p',\n\t'td'\n] );\n\nfunction wrapInParagraph( input, position, conversionApi ) {\n\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n\n\tconversionApi.writer.insert( paragraph, position );\n\treturn conversionApi.convertItem( input, conversionApi.writer.createPositionAt( paragraph, 0 ) );\n}\n\nfunction isParagraphable( node, position, schema ) {\n\tconst context = schema.createContext( position );\n\n\t// When paragraph is allowed in this context...\n\tif ( !schema.checkChild( context, 'paragraph' ) ) {\n\t\treturn false;\n\t}\n\n\t// And a node would be allowed in this paragraph...\n\tif ( !schema.checkChild( context.push( 'paragraph' ), node ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"]},"metadata":{},"sourceType":"module"}