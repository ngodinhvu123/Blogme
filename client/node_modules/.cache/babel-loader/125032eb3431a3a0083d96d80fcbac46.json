{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global DOMParser */\n\n/**\n * @module widget/widgettypearound\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Template from '@ckeditor/ckeditor5-ui/src/template';\nimport { isArrowKeyCode, isForwardArrowKeyCode, keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\nimport { isTypeAroundWidget, getClosestTypeAroundDomButton, getTypeAroundButtonPosition, getClosestWidgetViewElement, getTypeAroundFakeCaretPosition, TYPE_AROUND_SELECTION_ATTRIBUTE } from './utils';\nimport { isNonTypingKeystroke } from '@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling';\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\nconst POSSIBLE_INSERTION_POSITIONS = ['before', 'after']; // Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\n\nconst RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, 'image/svg+xml').firstChild;\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects a user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n *\n * @extends module:core/plugin~Plugin\n * @private\n */\n\nexport default class WidgetTypeAround extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'WidgetTypeAround';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  constructor(editor) {\n    super(editor);\n    /**\n     * A reference to the model widget element that has the \"fake caret\" active\n     * on either side of it. It is later used to remove CSS classes associated with the \"fake caret\"\n     * when the widget no longer needs it.\n     *\n     * @private\n     * @member {module:engine/model/element~Element|null}\n     */\n\n    this._currentFakeCaretModelElement = null;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    this._enableTypeAroundUIInjection();\n\n    this._enableInsertingParagraphsOnButtonClick();\n\n    this._enableInsertingParagraphsOnEnterKeypress();\n\n    this._enableInsertingParagraphsOnTypingKeystroke();\n\n    this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n\n    this._enableDeleteIntegration();\n\n    this._enableInsertContentIntegration();\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    this._currentFakeCaretModelElement = null;\n  }\n  /**\n   * Inserts a new paragraph next to a widget element with the selection anchored in it.\n   *\n   * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n   * the viewport to the selection in the inserted paragraph.\n   *\n   * @protected\n   * @param {module:engine/model/element~Element} widgetModelElement The model widget element next to which a paragraph is inserted.\n   * @param {'before'|'after'} position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n   */\n\n\n  _insertParagraph(widgetModelElement, position) {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    editor.execute('insertParagraph', {\n      position: editor.model.createPositionAt(widgetModelElement, position)\n    });\n    editingView.focus();\n    editingView.scrollToTheSelection();\n  }\n  /**\n   * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n   * does not expect a position but it performs the insertion next to a selected widget\n   * according to the \"widget-type-around\" model selection attribute value (\"fake caret\" position).\n   *\n   * Because this method requires the \"widget-type-around\" attribute to be set,\n   * the insertion can only happen when the widget \"fake caret\" is active (e.g. activated\n   * using the keyboard).\n   *\n   * @private\n   * @returns {Boolean} Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n   */\n\n\n  _insertParagraphAccordingToFakeCaretPosition() {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n\n    if (!typeAroundFakeCaretPosition) {\n      return false;\n    }\n\n    const selectedModelElement = modelSelection.getSelectedElement();\n\n    this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);\n\n    return true;\n  }\n  /**\n   * Creates a listener in the editing conversion pipeline that injects the type around\n   * UI into every single widget instance created in the editor.\n   *\n   * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n   * wrapper which renders DOM buttons that users can use to insert paragraphs.\n   *\n   * @private\n   */\n\n\n  _enableTypeAroundUIInjection() {\n    const editor = this.editor;\n    const schema = editor.model.schema;\n    const t = editor.locale.t;\n    const buttonTitles = {\n      before: t('Insert paragraph before block'),\n      after: t('Insert paragraph after block')\n    };\n    editor.editing.downcastDispatcher.on('insert', (evt, data, conversionApi) => {\n      const viewElement = conversionApi.mapper.toViewElement(data.item); // Filter out non-widgets and inline widgets.\n\n      if (isTypeAroundWidget(viewElement, data.item, schema)) {\n        injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);\n      }\n    }, {\n      priority: 'low'\n    });\n  }\n  /**\n   * Brings support for the \"fake caret\" that appears when either:\n   *\n   * * the selection moves from a position next to a widget (to a widget) using arrow keys,\n   * * the arrow key is pressed when the widget is already selected.\n   *\n   * The \"fake caret\" lets the user know that they can start typing or just press\n   * enter to insert a paragraph at the position next to a widget as suggested by the \"fake caret\".\n   *\n   * The \"fake caret\" disappears when the user changes the selection or the editor\n   * gets blurred.\n   *\n   * The whole idea is as follows:\n   *\n   * 1. A user does one of the 2 scenarios described at the beginning.\n   * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the \"fake caret\".\n   * 3. If it should show up, the \"widget-type-around\" model selection attribute is set indicating\n   *    on which side of the widget it should appear.\n   * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n   *    \"fake caret\" on the view widget.\n   * 5. If the \"fake caret\" should disappear, the selection attribute is removed and the dispatcher\n   *    does the CSS class clean-up in the view.\n   * 6. Additionally, \"change:range\" and FocusTracker#isFocused listeners also remove the selection\n   *    attribute (the former also removes widget CSS classes).\n   *\n   * @private\n   */\n\n\n  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const schema = model.schema;\n    const editingView = editor.editing.view; // This is the main listener responsible for the \"fake caret\".\n    // Note: The priority must precede the default Widget class keydown handler (\"high\") and the\n    // TableKeyboard keydown handler (\"high-10\").\n\n    editingView.document.on('keydown', (evt, domEventData) => {\n      if (isArrowKeyCode(domEventData.keyCode)) {\n        this._handleArrowKeyPress(evt, domEventData);\n      }\n    }, {\n      priority: priorities.get('high') + 10\n    }); // This listener makes sure the widget type around selection attribute will be gone from the model\n    // selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n    // (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n    // let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n\n    modelSelection.on('change:range', (evt, data) => {\n      // Do not reset the selection attribute when the change was indirect.\n      if (!data.directChange) {\n        return;\n      } // Get rid of the widget type around attribute of the selection on every change:range.\n      // If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n\n\n      editor.model.change(writer => {\n        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n      });\n    }); // Get rid of the widget type around attribute of the selection on every document change\n    // that makes widget not selected any more (i.e. widget was removed).\n\n    model.document.on('change:data', () => {\n      const selectedModelElement = modelSelection.getSelectedElement();\n\n      if (selectedModelElement) {\n        const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n\n        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n          return;\n        }\n      }\n\n      editor.model.change(writer => {\n        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n      });\n    }); // React to changes of the model selection attribute made by the arrow keys listener.\n    // If the block widget is selected and the attribute changes, downcast the attribute to special\n    // CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n\n    editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n      const writer = conversionApi.writer;\n\n      if (this._currentFakeCaretModelElement) {\n        const selectedViewElement = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);\n\n        if (selectedViewElement) {\n          // Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n          writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement);\n          this._currentFakeCaretModelElement = null;\n        }\n      }\n\n      const selectedModelElement = data.selection.getSelectedElement();\n\n      if (!selectedModelElement) {\n        return;\n      }\n\n      const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);\n\n      if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n        return;\n      }\n\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);\n\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n\n      writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement); // Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n      // selection changes\n\n      this._currentFakeCaretModelElement = selectedModelElement;\n    });\n    this.listenTo(editor.ui.focusTracker, 'change:isFocused', (evt, name, isFocused) => {\n      if (!isFocused) {\n        editor.model.change(writer => {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n        });\n      }\n    });\n\n    function positionToWidgetCssClass(position) {\n      return `ck-widget_type-around_show-fake-caret_${position}`;\n    }\n  }\n  /**\n   * A listener executed on each \"keydown\" in the view document, a part of\n   * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n   *\n   * It decides whether the arrow key press should activate the \"fake caret\" or not (also whether it should\n   * be deactivated).\n   *\n   * The \"fake caret\" activation is done by setting the \"widget-type-around\" model selection attribute\n   * in this listener and stopping&preventing the event that would normally be handled by the Widget\n   * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n   * includes inline widgets, which are ignored by the WidgetTypeAround plugin).\n   *\n   * @private\n   */\n\n\n  _handleArrowKeyPress(evt, domEventData) {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const schema = model.schema;\n    const editingView = editor.editing.view;\n    const keyCode = domEventData.keyCode;\n    const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);\n    const selectedViewElement = editingView.document.selection.getSelectedElement();\n    const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);\n    let shouldStopAndPreventDefault; // Handle keyboard navigation when a type-around-compatible widget is currently selected.\n\n    if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n      shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);\n    } // Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n    // and the widget is about to be selected.\n    else if (modelSelection.isCollapsed) {\n        shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);\n      }\n\n    if (shouldStopAndPreventDefault) {\n      domEventData.preventDefault();\n      evt.stop();\n    }\n  }\n  /**\n   * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n   * the \"fake caret\" for that widget, depending on the current value of the \"widget-type-around\" model\n   * selection attribute and the direction of the pressed arrow key.\n   *\n   * @private\n   * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n   * @returns {Boolean} `true` when the key press was handled and no other keydown listener of the editor should\n   * process the event any further. `false` otherwise.\n   */\n\n\n  _handleArrowKeyPressOnSelectedWidget(isForward) {\n    const editor = this.editor;\n    const model = editor.model;\n    const modelSelection = model.document.selection;\n    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n    return model.change(writer => {\n      // If the fake caret is displayed...\n      if (typeAroundFakeCaretPosition) {\n        const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? 'after' : 'before'); // If the keyboard arrow works against the value of the selection attribute...\n        // then remove the selection attribute but prevent default DOM actions\n        // and do not let the Widget plugin listener move the selection. This brings\n        // the widget back to the state, for instance, like if was selected using the mouse.\n        //\n        // **Note**: If leaving the widget when the \"fake caret\" is active, then the default\n        // Widget handler will change the selection and, in turn, this will automatically discard\n        // the selection attribute.\n\n        if (!isLeavingWidget) {\n          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n          return true;\n        }\n      } // If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n      // key press. This also means we cannot let the Widget plugin listener move the selection.\n      else {\n          writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n          return true;\n        }\n\n      return false;\n    });\n  }\n  /**\n   * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n   * to one and upon the \"fake caret\" should become active for this widget upon arrow key press\n   * (AKA entering/selecting the widget).\n   *\n   * **Note**: This code mirrors the implementation from the Widget plugin but also adds the selection attribute.\n   * Unfortunately, there's no safe way to let the Widget plugin do the selection part first and then just set the\n   * selection attribute here in the WidgetTypeAround plugin. This is why this code must duplicate some from the Widget plugin.\n   *\n   * @private\n   * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n   * @returns {Boolean} `true` when the key press was handled and no other keydown listener of the editor should\n   * process the event any further. `false` otherwise.\n   */\n\n\n  _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {\n    const editor = this.editor;\n    const model = editor.model;\n    const schema = model.schema;\n    const widgetPlugin = editor.plugins.get('Widget'); // This is the widget the selection is about to be set on.\n\n    const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);\n\n    const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);\n\n    if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {\n      model.change(writer => {\n        widgetPlugin._setSelectionOverElement(modelElementNextToSelection);\n\n        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after');\n      }); // The change() block above does the same job as the Widget plugin. The event can\n      // be safely canceled.\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Registers a `mousedown` listener for the view document which intercepts events\n   * coming from the type around UI, which happens when a user clicks one of the buttons\n   * that insert a paragraph next to a widget.\n   *\n   * @private\n   */\n\n\n  _enableInsertingParagraphsOnButtonClick() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    editingView.document.on('mousedown', (evt, domEventData) => {\n      const button = getClosestTypeAroundDomButton(domEventData.domTarget);\n\n      if (!button) {\n        return;\n      }\n\n      const buttonPosition = getTypeAroundButtonPosition(button);\n      const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);\n      const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);\n\n      this._insertParagraph(widgetModelElement, buttonPosition);\n\n      domEventData.preventDefault();\n      evt.stop();\n    });\n  }\n  /**\n   * Creates the \"enter\" key listener on the view document that allows the user to insert a paragraph\n   * near the widget when either:\n   *\n   * * The \"fake caret\" was first activated using the arrow keys,\n   * * The entire widget is selected in the model.\n   *\n   * In the first case, the new paragraph is inserted according to the \"widget-type-around\" selection\n   * attribute (see {@link #_handleArrowKeyPress}).\n   *\n   * It the second case, the new paragraph is inserted based on whether a soft (Shift+Enter) keystroke\n   * was pressed or not.\n   *\n   * @private\n   */\n\n\n  _enableInsertingParagraphsOnEnterKeypress() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    this.listenTo(editingView.document, 'enter', (evt, domEventData) => {\n      const selectedViewElement = editingView.document.selection.getSelectedElement();\n      const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);\n      const schema = editor.model.schema;\n      let wasHandled; // First check if the widget is selected and there's a type around selection attribute associated\n      // with the \"fake caret\" that would tell where to insert a new paragraph.\n\n      if (this._insertParagraphAccordingToFakeCaretPosition()) {\n        wasHandled = true;\n      } // Then, if there is no selection attribute associated with the \"fake caret\", check if the widget\n      // simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n      else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n          this._insertParagraph(selectedModelElement, domEventData.isSoft ? 'before' : 'after');\n\n          wasHandled = true;\n        }\n\n      if (wasHandled) {\n        domEventData.preventDefault();\n        evt.stop();\n      }\n    });\n  }\n  /**\n   * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n   * to insert a paragraph next to a widget when the \"fake caret\" was activated using arrow\n   * keys but it responds to \"typing keystrokes\" instead of \"enter\".\n   *\n   * \"Typing keystrokes\" are keystrokes that insert new content into the document\n   * like, for instance, letters (\"a\") or numbers (\"4\"). The \"keydown\" listener enabled by this method\n   * will insert a new paragraph according to the \"widget-type-around\" model selection attribute\n   * as the user simply starts typing, which creates the impression that the \"fake caret\"\n   * behaves like a \"real one\" rendered by the browser (AKA your text appears where the caret was).\n   *\n   * **Note**: ATM this listener creates 2 undo steps: one for the \"insertParagraph\" command\n   * and the second for the actual typing. It's not a disaster but this may need to be fixed\n   * sooner or later.\n   *\n   * Learn more in {@link module:typing/utils/injectunsafekeystrokeshandling}.\n   *\n   * @private\n   */\n\n\n  _enableInsertingParagraphsOnTypingKeystroke() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    const keyCodesHandledSomewhereElse = [keyCodes.enter, keyCodes.delete, keyCodes.backspace]; // Note: The priority must precede the default Widget class keydown handler (\"high\") and the\n    // TableKeyboard keydown handler (\"high + 1\").\n\n    editingView.document.on('keydown', (evt, domEventData) => {\n      // Don't handle enter/backspace/delete here. They are handled in dedicated listeners.\n      if (!keyCodesHandledSomewhereElse.includes(domEventData.keyCode) && !isNonTypingKeystroke(domEventData)) {\n        this._insertParagraphAccordingToFakeCaretPosition();\n      }\n    }, {\n      priority: priorities.get('high') + 1\n    });\n  }\n  /**\n   * It creates a \"delete\" event listener on the view document to handle cases when delete/backspace\n   * is pressed and the \"fake caret\" is currently active.\n   *\n   * The \"fake caret\" should create an illusion of a \"real browser caret\" so that when it appears\n   * before/after a widget, pressing delete/backspace should remove a widget or delete a content\n   * before/after a widget (depending on the content surrounding the widget).\n   *\n   * @private\n   */\n\n\n  _enableDeleteIntegration() {\n    const editor = this.editor;\n    const editingView = editor.editing.view;\n    const model = editor.model;\n    const schema = model.schema; // Note: The priority must precede the default Widget class delete handler.\n\n    this.listenTo(editingView.document, 'delete', (evt, domEventData) => {\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection); // This listener handles only these cases when the \"fake caret\" is active.\n\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n\n      const direction = domEventData.direction;\n      const selectedModelWidget = model.document.selection.getSelectedElement();\n      const isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n      const isForwardDelete = direction == 'forward';\n      const shouldDeleteEntireWidget = isFakeCaretBefore === isForwardDelete;\n\n      if (shouldDeleteEntireWidget) {\n        editor.execute('delete', {\n          selection: model.createSelection(selectedModelWidget, 'on')\n        });\n      } else {\n        const range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction); // If there is somewhere to move selection to, then there will be something to delete.\n\n        if (range) {\n          // If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n          if (!range.isCollapsed) {\n            model.change(writer => {\n              writer.setSelection(range);\n              editor.execute(isForwardDelete ? 'forwardDelete' : 'delete');\n            });\n          } else {\n            const probe = model.createSelection(range.start);\n            model.modifySelection(probe, {\n              direction\n            }); // If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n            // If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n\n            if (!probe.focus.isEqual(range.start)) {\n              model.change(writer => {\n                writer.setSelection(range);\n                editor.execute(isForwardDelete ? 'forwardDelete' : 'delete');\n              });\n            } // If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n            // next to a widget that should be removed. \"delete\" and \"forwardDelete\" commands cannot get rid of it\n            // so calling Model#deleteContent here manually.\n            else {\n                const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);\n                model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, 'on'), {\n                  doNotAutoparagraph: true\n                });\n              }\n          }\n        }\n      } // If some content was deleted, don't let the handler from the Widget plugin kick in.\n      // If nothing was deleted, then the default handler will have nothing to do anyway.\n\n\n      domEventData.preventDefault();\n      evt.stop();\n    }, {\n      priority: priorities.get('high') + 1\n    });\n  }\n  /**\n   * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n   * content near a widget when the \"fake caret\" was first activated using the arrow keys.\n   *\n   * The content is inserted according to the \"widget-type-around\" selection attribute (see {@link #_handleArrowKeyPress}).\n   *\n   * @private\n   */\n\n\n  _enableInsertContentIntegration() {\n    const editor = this.editor;\n    const model = this.editor.model;\n    const documentSelection = model.document.selection;\n    this.listenTo(editor.model, 'insertContent', (evt, [content, selectable]) => {\n      if (selectable && !selectable.is('documentSelection')) {\n        return;\n      }\n\n      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n\n      if (!typeAroundFakeCaretPosition) {\n        return;\n      }\n\n      evt.stop();\n      return model.change(writer => {\n        const selectedElement = documentSelection.getSelectedElement();\n        const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);\n        const selection = writer.createSelection(position);\n        const result = model.insertContent(content, selection);\n        writer.setSelection(selection);\n        return result;\n      });\n    }, {\n      priority: 'high'\n    });\n  }\n\n} // Injects the type around UI into a view widget instance.\n//\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {Object.<String,String>} buttonTitles\n// @param {module:engine/view/element~Element} widgetViewElement\n\nfunction injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {\n  const typeAroundWrapper = viewWriter.createUIElement('div', {\n    class: 'ck ck-reset_all ck-widget__type-around'\n  }, function (domDocument) {\n    const wrapperDomElement = this.toDomElement(domDocument);\n    injectButtons(wrapperDomElement, buttonTitles);\n    injectFakeCaret(wrapperDomElement);\n    return wrapperDomElement;\n  }); // Inject the type around wrapper into the widget's wrapper.\n\n  viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, 'end'), typeAroundWrapper);\n} // FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n// and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n// <svg> here.\n//\n// @param {HTMLElement} wrapperDomElement\n// @param {Object.<String,String>} buttonTitles\n\n\nfunction injectButtons(wrapperDomElement, buttonTitles) {\n  for (const position of POSSIBLE_INSERTION_POSITIONS) {\n    const buttonTemplate = new Template({\n      tag: 'div',\n      attributes: {\n        class: ['ck', 'ck-widget__type-around__button', `ck-widget__type-around__button_${position}`],\n        title: buttonTitles[position]\n      },\n      children: [wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)]\n    });\n    wrapperDomElement.appendChild(buttonTemplate.render());\n  }\n} // @param {HTMLElement} wrapperDomElement\n\n\nfunction injectFakeCaret(wrapperDomElement) {\n  const caretTemplate = new Template({\n    tag: 'div',\n    attributes: {\n      class: ['ck', 'ck-widget__type-around__fake-caret']\n    }\n  });\n  wrapperDomElement.appendChild(caretTemplate.render());\n} // Returns the ancestor of an element closest to the root which is empty. For instance,\n// for `<baz>`:\n//\n//\t\t<foo>abc<bar><baz></baz></bar></foo>\n//\n// it returns `<bar>`.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/element~Element|null}\n\n\nfunction getDeepestEmptyElementAncestor(schema, element) {\n  let deepestEmptyAncestor = element;\n\n  for (const ancestor of element.getAncestors({\n    parentFirst: true\n  })) {\n    if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {\n      break;\n    }\n\n    deepestEmptyAncestor = ancestor;\n  }\n\n  return deepestEmptyAncestor;\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js"],"names":["Plugin","Template","isArrowKeyCode","isForwardArrowKeyCode","keyCodes","priorities","isTypeAroundWidget","getClosestTypeAroundDomButton","getTypeAroundButtonPosition","getClosestWidgetViewElement","getTypeAroundFakeCaretPosition","TYPE_AROUND_SELECTION_ATTRIBUTE","isNonTypingKeystroke","returnIcon","POSSIBLE_INSERTION_POSITIONS","RETURN_ARROW_ICON_ELEMENT","DOMParser","parseFromString","firstChild","WidgetTypeAround","pluginName","constructor","editor","_currentFakeCaretModelElement","init","_enableTypeAroundUIInjection","_enableInsertingParagraphsOnButtonClick","_enableInsertingParagraphsOnEnterKeypress","_enableInsertingParagraphsOnTypingKeystroke","_enableTypeAroundFakeCaretActivationUsingKeyboardArrows","_enableDeleteIntegration","_enableInsertContentIntegration","destroy","_insertParagraph","widgetModelElement","position","editingView","editing","view","execute","model","createPositionAt","focus","scrollToTheSelection","_insertParagraphAccordingToFakeCaretPosition","modelSelection","document","selection","typeAroundFakeCaretPosition","selectedModelElement","getSelectedElement","schema","t","locale","buttonTitles","before","after","downcastDispatcher","on","evt","data","conversionApi","viewElement","mapper","toViewElement","item","injectUIIntoWidget","writer","priority","domEventData","keyCode","_handleArrowKeyPress","get","directChange","change","removeSelectionAttribute","selectedViewElement","removeClass","map","positionToWidgetCssClass","addClass","listenTo","ui","focusTracker","name","isFocused","isForward","contentLanguageDirection","toModelElement","shouldStopAndPreventDefault","_handleArrowKeyPressOnSelectedWidget","isCollapsed","_handleArrowKeyPressWhenSelectionNextToAWidget","preventDefault","stop","isLeavingWidget","setSelectionAttribute","widgetPlugin","plugins","modelElementNextToSelection","_getObjectElementNextToSelection","viewElementNextToSelection","_setSelectionOverElement","button","domTarget","buttonPosition","widgetViewElement","domConverter","wasHandled","isSoft","keyCodesHandledSomewhereElse","enter","delete","backspace","includes","direction","selectedModelWidget","isFakeCaretBefore","isForwardDelete","shouldDeleteEntireWidget","createSelection","range","getNearestSelectionRange","setSelection","probe","start","modifySelection","isEqual","deepestEmptyRangeAncestor","getDeepestEmptyElementAncestor","parent","deleteContent","doNotAutoparagraph","documentSelection","content","selectable","is","selectedElement","result","insertContent","viewWriter","typeAroundWrapper","createUIElement","class","domDocument","wrapperDomElement","toDomElement","injectButtons","injectFakeCaret","insert","buttonTemplate","tag","attributes","title","children","ownerDocument","importNode","appendChild","render","caretTemplate","element","deepestEmptyAncestor","ancestor","getAncestors","parentFirst","childCount","isLimit"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* global DOMParser */\n\n/**\n * @module widget/widgettypearound\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport Template from '@ckeditor/ckeditor5-ui/src/template';\nimport {\n\tisArrowKeyCode,\n\tisForwardArrowKeyCode,\n\tkeyCodes\n} from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\n\nimport {\n\tisTypeAroundWidget,\n\tgetClosestTypeAroundDomButton,\n\tgetTypeAroundButtonPosition,\n\tgetClosestWidgetViewElement,\n\tgetTypeAroundFakeCaretPosition,\n\tTYPE_AROUND_SELECTION_ATTRIBUTE\n} from './utils';\n\nimport {\n\tisNonTypingKeystroke\n} from '@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling';\n\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\n\nconst POSSIBLE_INSERTION_POSITIONS = [ 'before', 'after' ];\n\n// Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\nconst RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString( returnIcon, 'image/svg+xml' ).firstChild;\n\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects a user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n *\n * @extends module:core/plugin~Plugin\n * @private\n */\nexport default class WidgetTypeAround extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'WidgetTypeAround';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * A reference to the model widget element that has the \"fake caret\" active\n\t\t * on either side of it. It is later used to remove CSS classes associated with the \"fake caret\"\n\t\t * when the widget no longer needs it.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element|null}\n\t\t */\n\t\tthis._currentFakeCaretModelElement = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tthis._enableTypeAroundUIInjection();\n\t\tthis._enableInsertingParagraphsOnButtonClick();\n\t\tthis._enableInsertingParagraphsOnEnterKeypress();\n\t\tthis._enableInsertingParagraphsOnTypingKeystroke();\n\t\tthis._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n\t\tthis._enableDeleteIntegration();\n\t\tthis._enableInsertContentIntegration();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tthis._currentFakeCaretModelElement = null;\n\t}\n\n\t/**\n\t * Inserts a new paragraph next to a widget element with the selection anchored in it.\n\t *\n\t * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n\t * the viewport to the selection in the inserted paragraph.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} widgetModelElement The model widget element next to which a paragraph is inserted.\n\t * @param {'before'|'after'} position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n\t */\n\t_insertParagraph( widgetModelElement, position ) {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\teditor.execute( 'insertParagraph', {\n\t\t\tposition: editor.model.createPositionAt( widgetModelElement, position )\n\t\t} );\n\n\t\teditingView.focus();\n\t\teditingView.scrollToTheSelection();\n\t}\n\n\t/**\n\t * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n\t * does not expect a position but it performs the insertion next to a selected widget\n\t * according to the \"widget-type-around\" model selection attribute value (\"fake caret\" position).\n\t *\n\t * Because this method requires the \"widget-type-around\" attribute to be set,\n\t * the insertion can only happen when the widget \"fake caret\" is active (e.g. activated\n\t * using the keyboard).\n\t *\n\t * @private\n\t * @returns {Boolean} Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n\t */\n\t_insertParagraphAccordingToFakeCaretPosition() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( modelSelection );\n\n\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selectedModelElement = modelSelection.getSelectedElement();\n\n\t\tthis._insertParagraph( selectedModelElement, typeAroundFakeCaretPosition );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Creates a listener in the editing conversion pipeline that injects the type around\n\t * UI into every single widget instance created in the editor.\n\t *\n\t * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n\t * wrapper which renders DOM buttons that users can use to insert paragraphs.\n\t *\n\t * @private\n\t */\n\t_enableTypeAroundUIInjection() {\n\t\tconst editor = this.editor;\n\t\tconst schema = editor.model.schema;\n\t\tconst t = editor.locale.t;\n\t\tconst buttonTitles = {\n\t\t\tbefore: t( 'Insert paragraph before block' ),\n\t\t\tafter: t( 'Insert paragraph after block' )\n\t\t};\n\n\t\teditor.editing.downcastDispatcher.on( 'insert', ( evt, data, conversionApi ) => {\n\t\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\n\t\t\t// Filter out non-widgets and inline widgets.\n\t\t\tif ( isTypeAroundWidget( viewElement, data.item, schema ) ) {\n\t\t\t\tinjectUIIntoWidget( conversionApi.writer, buttonTitles, viewElement );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Brings support for the \"fake caret\" that appears when either:\n\t *\n\t * * the selection moves from a position next to a widget (to a widget) using arrow keys,\n\t * * the arrow key is pressed when the widget is already selected.\n\t *\n\t * The \"fake caret\" lets the user know that they can start typing or just press\n\t * enter to insert a paragraph at the position next to a widget as suggested by the \"fake caret\".\n\t *\n\t * The \"fake caret\" disappears when the user changes the selection or the editor\n\t * gets blurred.\n\t *\n\t * The whole idea is as follows:\n\t *\n\t * 1. A user does one of the 2 scenarios described at the beginning.\n\t * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the \"fake caret\".\n\t * 3. If it should show up, the \"widget-type-around\" model selection attribute is set indicating\n\t *    on which side of the widget it should appear.\n\t * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n\t *    \"fake caret\" on the view widget.\n\t * 5. If the \"fake caret\" should disappear, the selection attribute is removed and the dispatcher\n\t *    does the CSS class clean-up in the view.\n\t * 6. Additionally, \"change:range\" and FocusTracker#isFocused listeners also remove the selection\n\t *    attribute (the former also removes widget CSS classes).\n\t *\n\t * @private\n\t */\n\t_enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst schema = model.schema;\n\t\tconst editingView = editor.editing.view;\n\n\t\t// This is the main listener responsible for the \"fake caret\".\n\t\t// Note: The priority must precede the default Widget class keydown handler (\"high\") and the\n\t\t// TableKeyboard keydown handler (\"high-10\").\n\t\teditingView.document.on( 'keydown', ( evt, domEventData ) => {\n\t\t\tif ( isArrowKeyCode( domEventData.keyCode ) ) {\n\t\t\t\tthis._handleArrowKeyPress( evt, domEventData );\n\t\t\t}\n\t\t}, { priority: priorities.get( 'high' ) + 10 } );\n\n\t\t// This listener makes sure the widget type around selection attribute will be gone from the model\n\t\t// selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n\t\t// (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n\t\t// let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n\t\tmodelSelection.on( 'change:range', ( evt, data ) => {\n\t\t\t// Do not reset the selection attribute when the change was indirect.\n\t\t\tif ( !data.directChange ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get rid of the widget type around attribute of the selection on every change:range.\n\t\t\t// If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n\t\t\teditor.model.change( writer => {\n\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t} );\n\t\t} );\n\n\t\t// Get rid of the widget type around attribute of the selection on every document change\n\t\t// that makes widget not selected any more (i.e. widget was removed).\n\t\tmodel.document.on( 'change:data', () => {\n\t\t\tconst selectedModelElement = modelSelection.getSelectedElement();\n\n\t\t\tif ( selectedModelElement ) {\n\t\t\t\tconst selectedViewElement = editor.editing.mapper.toViewElement( selectedModelElement );\n\n\t\t\t\tif ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t} );\n\t\t} );\n\n\t\t// React to changes of the model selection attribute made by the arrow keys listener.\n\t\t// If the block widget is selected and the attribute changes, downcast the attribute to special\n\t\t// CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n\t\teditor.editing.downcastDispatcher.on( 'selection', ( evt, data, conversionApi ) => {\n\t\t\tconst writer = conversionApi.writer;\n\n\t\t\tif ( this._currentFakeCaretModelElement ) {\n\t\t\t\tconst selectedViewElement = conversionApi.mapper.toViewElement( this._currentFakeCaretModelElement );\n\n\t\t\t\tif ( selectedViewElement ) {\n\t\t\t\t\t// Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n\t\t\t\t\twriter.removeClass( POSSIBLE_INSERTION_POSITIONS.map( positionToWidgetCssClass ), selectedViewElement );\n\n\t\t\t\t\tthis._currentFakeCaretModelElement = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst selectedModelElement = data.selection.getSelectedElement();\n\n\t\t\tif ( !selectedModelElement ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selectedViewElement = conversionApi.mapper.toViewElement( selectedModelElement );\n\n\t\t\tif ( !isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( data.selection );\n\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twriter.addClass( positionToWidgetCssClass( typeAroundFakeCaretPosition ), selectedViewElement );\n\n\t\t\t// Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n\t\t\t// selection changes\n\t\t\tthis._currentFakeCaretModelElement = selectedModelElement;\n\t\t} );\n\n\t\tthis.listenTo( editor.ui.focusTracker, 'change:isFocused', ( evt, name, isFocused ) => {\n\t\t\tif ( !isFocused ) {\n\t\t\t\teditor.model.change( writer => {\n\t\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\tfunction positionToWidgetCssClass( position ) {\n\t\t\treturn `ck-widget_type-around_show-fake-caret_${ position }`;\n\t\t}\n\t}\n\n\t/**\n\t * A listener executed on each \"keydown\" in the view document, a part of\n\t * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n\t *\n\t * It decides whether the arrow key press should activate the \"fake caret\" or not (also whether it should\n\t * be deactivated).\n\t *\n\t * The \"fake caret\" activation is done by setting the \"widget-type-around\" model selection attribute\n\t * in this listener and stopping&preventing the event that would normally be handled by the Widget\n\t * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n\t * includes inline widgets, which are ignored by the WidgetTypeAround plugin).\n\t *\n\t * @private\n\t */\n\t_handleArrowKeyPress( evt, domEventData ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst schema = model.schema;\n\t\tconst editingView = editor.editing.view;\n\n\t\tconst keyCode = domEventData.keyCode;\n\t\tconst isForward = isForwardArrowKeyCode( keyCode, editor.locale.contentLanguageDirection );\n\t\tconst selectedViewElement = editingView.document.selection.getSelectedElement();\n\t\tconst selectedModelElement = editor.editing.mapper.toModelElement( selectedViewElement );\n\t\tlet shouldStopAndPreventDefault;\n\n\t\t// Handle keyboard navigation when a type-around-compatible widget is currently selected.\n\t\tif ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\tshouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget( isForward );\n\t\t}\n\t\t// Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n\t\t// and the widget is about to be selected.\n\t\telse if ( modelSelection.isCollapsed ) {\n\t\t\tshouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget( isForward );\n\t\t}\n\n\t\tif ( shouldStopAndPreventDefault ) {\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n\t * the \"fake caret\" for that widget, depending on the current value of the \"widget-type-around\" model\n\t * selection attribute and the direction of the pressed arrow key.\n\t *\n\t * @private\n\t * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n\t * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n\t * @returns {Boolean} `true` when the key press was handled and no other keydown listener of the editor should\n\t * process the event any further. `false` otherwise.\n\t */\n\t_handleArrowKeyPressOnSelectedWidget( isForward ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( modelSelection );\n\n\t\treturn model.change( writer => {\n\t\t\t// If the fake caret is displayed...\n\t\t\tif ( typeAroundFakeCaretPosition ) {\n\t\t\t\tconst isLeavingWidget = typeAroundFakeCaretPosition === ( isForward ? 'after' : 'before' );\n\n\t\t\t\t// If the keyboard arrow works against the value of the selection attribute...\n\t\t\t\t// then remove the selection attribute but prevent default DOM actions\n\t\t\t\t// and do not let the Widget plugin listener move the selection. This brings\n\t\t\t\t// the widget back to the state, for instance, like if was selected using the mouse.\n\t\t\t\t//\n\t\t\t\t// **Note**: If leaving the widget when the \"fake caret\" is active, then the default\n\t\t\t\t// Widget handler will change the selection and, in turn, this will automatically discard\n\t\t\t\t// the selection attribute.\n\t\t\t\tif ( !isLeavingWidget ) {\n\t\t\t\t\twriter.removeSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n\t\t\t// key press. This also means we cannot let the Widget plugin listener move the selection.\n\t\t\telse {\n\t\t\t\twriter.setSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before' );\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t} );\n\t}\n\n\t/**\n\t * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n\t * to one and upon the \"fake caret\" should become active for this widget upon arrow key press\n\t * (AKA entering/selecting the widget).\n\t *\n\t * **Note**: This code mirrors the implementation from the Widget plugin but also adds the selection attribute.\n\t * Unfortunately, there's no safe way to let the Widget plugin do the selection part first and then just set the\n\t * selection attribute here in the WidgetTypeAround plugin. This is why this code must duplicate some from the Widget plugin.\n\t *\n\t * @private\n\t * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n\t * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n\t * @returns {Boolean} `true` when the key press was handled and no other keydown listener of the editor should\n\t * process the event any further. `false` otherwise.\n\t */\n\t_handleArrowKeyPressWhenSelectionNextToAWidget( isForward ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst schema = model.schema;\n\t\tconst widgetPlugin = editor.plugins.get( 'Widget' );\n\n\t\t// This is the widget the selection is about to be set on.\n\t\tconst modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection( isForward );\n\t\tconst viewElementNextToSelection = editor.editing.mapper.toViewElement( modelElementNextToSelection );\n\n\t\tif ( isTypeAroundWidget( viewElementNextToSelection, modelElementNextToSelection, schema ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twidgetPlugin._setSelectionOverElement( modelElementNextToSelection );\n\t\t\t\twriter.setSelectionAttribute( TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after' );\n\t\t\t} );\n\n\t\t\t// The change() block above does the same job as the Widget plugin. The event can\n\t\t\t// be safely canceled.\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Registers a `mousedown` listener for the view document which intercepts events\n\t * coming from the type around UI, which happens when a user clicks one of the buttons\n\t * that insert a paragraph next to a widget.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnButtonClick() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\teditingView.document.on( 'mousedown', ( evt, domEventData ) => {\n\t\t\tconst button = getClosestTypeAroundDomButton( domEventData.domTarget );\n\n\t\t\tif ( !button ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst buttonPosition = getTypeAroundButtonPosition( button );\n\t\t\tconst widgetViewElement = getClosestWidgetViewElement( button, editingView.domConverter );\n\t\t\tconst widgetModelElement = editor.editing.mapper.toModelElement( widgetViewElement );\n\n\t\t\tthis._insertParagraph( widgetModelElement, buttonPosition );\n\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t} );\n\t}\n\n\t/**\n\t * Creates the \"enter\" key listener on the view document that allows the user to insert a paragraph\n\t * near the widget when either:\n\t *\n\t * * The \"fake caret\" was first activated using the arrow keys,\n\t * * The entire widget is selected in the model.\n\t *\n\t * In the first case, the new paragraph is inserted according to the \"widget-type-around\" selection\n\t * attribute (see {@link #_handleArrowKeyPress}).\n\t *\n\t * It the second case, the new paragraph is inserted based on whether a soft (Shift+Enter) keystroke\n\t * was pressed or not.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnEnterKeypress() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\n\t\tthis.listenTo( editingView.document, 'enter', ( evt, domEventData ) => {\n\t\t\tconst selectedViewElement = editingView.document.selection.getSelectedElement();\n\t\t\tconst selectedModelElement = editor.editing.mapper.toModelElement( selectedViewElement );\n\t\t\tconst schema = editor.model.schema;\n\t\t\tlet wasHandled;\n\n\t\t\t// First check if the widget is selected and there's a type around selection attribute associated\n\t\t\t// with the \"fake caret\" that would tell where to insert a new paragraph.\n\t\t\tif ( this._insertParagraphAccordingToFakeCaretPosition() ) {\n\t\t\t\twasHandled = true;\n\t\t\t}\n\t\t\t// Then, if there is no selection attribute associated with the \"fake caret\", check if the widget\n\t\t\t// simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n\t\t\telse if ( isTypeAroundWidget( selectedViewElement, selectedModelElement, schema ) ) {\n\t\t\t\tthis._insertParagraph( selectedModelElement, domEventData.isSoft ? 'before' : 'after' );\n\n\t\t\t\twasHandled = true;\n\t\t\t}\n\n\t\t\tif ( wasHandled ) {\n\t\t\t\tdomEventData.preventDefault();\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n\t * to insert a paragraph next to a widget when the \"fake caret\" was activated using arrow\n\t * keys but it responds to \"typing keystrokes\" instead of \"enter\".\n\t *\n\t * \"Typing keystrokes\" are keystrokes that insert new content into the document\n\t * like, for instance, letters (\"a\") or numbers (\"4\"). The \"keydown\" listener enabled by this method\n\t * will insert a new paragraph according to the \"widget-type-around\" model selection attribute\n\t * as the user simply starts typing, which creates the impression that the \"fake caret\"\n\t * behaves like a \"real one\" rendered by the browser (AKA your text appears where the caret was).\n\t *\n\t * **Note**: ATM this listener creates 2 undo steps: one for the \"insertParagraph\" command\n\t * and the second for the actual typing. It's not a disaster but this may need to be fixed\n\t * sooner or later.\n\t *\n\t * Learn more in {@link module:typing/utils/injectunsafekeystrokeshandling}.\n\t *\n\t * @private\n\t */\n\t_enableInsertingParagraphsOnTypingKeystroke() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\t\tconst keyCodesHandledSomewhereElse = [\n\t\t\tkeyCodes.enter,\n\t\t\tkeyCodes.delete,\n\t\t\tkeyCodes.backspace\n\t\t];\n\n\t\t// Note: The priority must precede the default Widget class keydown handler (\"high\") and the\n\t\t// TableKeyboard keydown handler (\"high + 1\").\n\t\teditingView.document.on( 'keydown', ( evt, domEventData ) => {\n\t\t\t// Don't handle enter/backspace/delete here. They are handled in dedicated listeners.\n\t\t\tif ( !keyCodesHandledSomewhereElse.includes( domEventData.keyCode ) && !isNonTypingKeystroke( domEventData ) ) {\n\t\t\t\tthis._insertParagraphAccordingToFakeCaretPosition();\n\t\t\t}\n\t\t}, { priority: priorities.get( 'high' ) + 1 } );\n\t}\n\n\t/**\n\t * It creates a \"delete\" event listener on the view document to handle cases when delete/backspace\n\t * is pressed and the \"fake caret\" is currently active.\n\t *\n\t * The \"fake caret\" should create an illusion of a \"real browser caret\" so that when it appears\n\t * before/after a widget, pressing delete/backspace should remove a widget or delete a content\n\t * before/after a widget (depending on the content surrounding the widget).\n\t *\n\t * @private\n\t */\n\t_enableDeleteIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst editingView = editor.editing.view;\n\t\tconst model = editor.model;\n\t\tconst schema = model.schema;\n\n\t\t// Note: The priority must precede the default Widget class delete handler.\n\t\tthis.listenTo( editingView.document, 'delete', ( evt, domEventData ) => {\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( model.document.selection );\n\n\t\t\t// This listener handles only these cases when the \"fake caret\" is active.\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst direction = domEventData.direction;\n\t\t\tconst selectedModelWidget = model.document.selection.getSelectedElement();\n\n\t\t\tconst isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n\t\t\tconst isForwardDelete = direction == 'forward';\n\t\t\tconst shouldDeleteEntireWidget = isFakeCaretBefore === isForwardDelete;\n\n\t\t\tif ( shouldDeleteEntireWidget ) {\n\t\t\t\teditor.execute( 'delete', {\n\t\t\t\t\tselection: model.createSelection( selectedModelWidget, 'on' )\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tconst range = schema.getNearestSelectionRange(\n\t\t\t\t\tmodel.createPositionAt( selectedModelWidget, typeAroundFakeCaretPosition ),\n\t\t\t\t\tdirection\n\t\t\t\t);\n\n\t\t\t\t// If there is somewhere to move selection to, then there will be something to delete.\n\t\t\t\tif ( range ) {\n\t\t\t\t\t// If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n\t\t\t\t\tif ( !range.isCollapsed ) {\n\t\t\t\t\t\tmodel.change( writer => {\n\t\t\t\t\t\t\twriter.setSelection( range );\n\t\t\t\t\t\t\teditor.execute( isForwardDelete ? 'forwardDelete' : 'delete' );\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst probe = model.createSelection( range.start );\n\t\t\t\t\t\tmodel.modifySelection( probe, { direction } );\n\n\t\t\t\t\t\t// If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n\t\t\t\t\t\t// If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n\t\t\t\t\t\tif ( !probe.focus.isEqual( range.start ) ) {\n\t\t\t\t\t\t\tmodel.change( writer => {\n\t\t\t\t\t\t\t\twriter.setSelection( range );\n\t\t\t\t\t\t\t\teditor.execute( isForwardDelete ? 'forwardDelete' : 'delete' );\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n\t\t\t\t\t\t// next to a widget that should be removed. \"delete\" and \"forwardDelete\" commands cannot get rid of it\n\t\t\t\t\t\t// so calling Model#deleteContent here manually.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor( schema, range.start.parent );\n\n\t\t\t\t\t\t\tmodel.deleteContent( model.createSelection( deepestEmptyRangeAncestor, 'on' ), {\n\t\t\t\t\t\t\t\tdoNotAutoparagraph: true\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If some content was deleted, don't let the handler from the Widget plugin kick in.\n\t\t\t// If nothing was deleted, then the default handler will have nothing to do anyway.\n\t\t\tdomEventData.preventDefault();\n\t\t\tevt.stop();\n\t\t}, { priority: priorities.get( 'high' ) + 1 } );\n\t}\n\n\t/**\n\t * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n\t * content near a widget when the \"fake caret\" was first activated using the arrow keys.\n\t *\n\t * The content is inserted according to the \"widget-type-around\" selection attribute (see {@link #_handleArrowKeyPress}).\n\t *\n\t * @private\n\t */\n\t_enableInsertContentIntegration() {\n\t\tconst editor = this.editor;\n\t\tconst model = this.editor.model;\n\t\tconst documentSelection = model.document.selection;\n\n\t\tthis.listenTo( editor.model, 'insertContent', ( evt, [ content, selectable ] ) => {\n\t\t\tif ( selectable && !selectable.is( 'documentSelection' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( documentSelection );\n\n\t\t\tif ( !typeAroundFakeCaretPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevt.stop();\n\n\t\t\treturn model.change( writer => {\n\t\t\t\tconst selectedElement = documentSelection.getSelectedElement();\n\t\t\t\tconst position = model.createPositionAt( selectedElement, typeAroundFakeCaretPosition );\n\t\t\t\tconst selection = writer.createSelection( position );\n\n\t\t\t\tconst result = model.insertContent( content, selection );\n\n\t\t\t\twriter.setSelection( selection );\n\n\t\t\t\treturn result;\n\t\t\t} );\n\t\t}, { priority: 'high' } );\n\t}\n}\n\n// Injects the type around UI into a view widget instance.\n//\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {Object.<String,String>} buttonTitles\n// @param {module:engine/view/element~Element} widgetViewElement\nfunction injectUIIntoWidget( viewWriter, buttonTitles, widgetViewElement ) {\n\tconst typeAroundWrapper = viewWriter.createUIElement( 'div', {\n\t\tclass: 'ck ck-reset_all ck-widget__type-around'\n\t}, function( domDocument ) {\n\t\tconst wrapperDomElement = this.toDomElement( domDocument );\n\n\t\tinjectButtons( wrapperDomElement, buttonTitles );\n\t\tinjectFakeCaret( wrapperDomElement );\n\n\t\treturn wrapperDomElement;\n\t} );\n\n\t// Inject the type around wrapper into the widget's wrapper.\n\tviewWriter.insert( viewWriter.createPositionAt( widgetViewElement, 'end' ), typeAroundWrapper );\n}\n\n// FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n// and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n// <svg> here.\n//\n// @param {HTMLElement} wrapperDomElement\n// @param {Object.<String,String>} buttonTitles\nfunction injectButtons( wrapperDomElement, buttonTitles ) {\n\tfor ( const position of POSSIBLE_INSERTION_POSITIONS ) {\n\t\tconst buttonTemplate = new Template( {\n\t\t\ttag: 'div',\n\t\t\tattributes: {\n\t\t\t\tclass: [\n\t\t\t\t\t'ck',\n\t\t\t\t\t'ck-widget__type-around__button',\n\t\t\t\t\t`ck-widget__type-around__button_${ position }`\n\t\t\t\t],\n\t\t\t\ttitle: buttonTitles[ position ]\n\t\t\t},\n\t\t\tchildren: [\n\t\t\t\twrapperDomElement.ownerDocument.importNode( RETURN_ARROW_ICON_ELEMENT, true )\n\t\t\t]\n\t\t} );\n\n\t\twrapperDomElement.appendChild( buttonTemplate.render() );\n\t}\n}\n\n// @param {HTMLElement} wrapperDomElement\nfunction injectFakeCaret( wrapperDomElement ) {\n\tconst caretTemplate = new Template( {\n\t\ttag: 'div',\n\t\tattributes: {\n\t\t\tclass: [\n\t\t\t\t'ck',\n\t\t\t\t'ck-widget__type-around__fake-caret'\n\t\t\t]\n\t\t}\n\t} );\n\n\twrapperDomElement.appendChild( caretTemplate.render() );\n}\n\n// Returns the ancestor of an element closest to the root which is empty. For instance,\n// for `<baz>`:\n//\n//\t\t<foo>abc<bar><baz></baz></bar></foo>\n//\n// it returns `<bar>`.\n//\n// @param {module:engine/model/schema~Schema} schema\n// @param {module:engine/model/element~Element} element\n// @returns {module:engine/model/element~Element|null}\nfunction getDeepestEmptyElementAncestor( schema, element ) {\n\tlet deepestEmptyAncestor = element;\n\n\tfor ( const ancestor of element.getAncestors( { parentFirst: true } ) ) {\n\t\tif ( ancestor.childCount > 1 || schema.isLimit( ancestor ) ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdeepestEmptyAncestor = ancestor;\n\t}\n\n\treturn deepestEmptyAncestor;\n}\n"]},"metadata":{},"sourceType":"module"}