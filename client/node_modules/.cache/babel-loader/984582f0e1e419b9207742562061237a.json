{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Matcher from '../view/matcher';\nimport ModelRange from '../model/range';\nimport ConversionHelpers from './conversionhelpers';\nimport { cloneDeep } from 'lodash-es';\nimport ModelSelection from '../model/selection';\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\n\nexport default class UpcastHelpers extends ConversionHelpers {\n  /**\n   * View element to model element conversion helper.\n   *\n   * This conversion results in creating a model element. For example,\n   * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n   *\n   * Keep in mind that the element will be inserted only if it is allowed\n   * by {@link module:engine/model/schema~Schema schema} configuration.\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n   *\t\t\tview: 'p',\n   *\t\t\tmodel: 'paragraph'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n   *\t\t\tview: 'p',\n   *\t\t\tmodel: 'paragraph',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'p',\n   *\t\t\t\tclasses: 'fancy'\n   *\t\t\t},\n   *\t\t\tmodel: 'fancyParagraph'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n   * \t\t\tview: {\n   *\t\t\t\tname: 'p',\n   *\t\t\t\tclasses: 'heading'\n   * \t\t\t},\n   * \t\t\tmodel: ( viewElement, modelWriter ) => {\n   * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n   * \t\t\t}\n   * \t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToElement\n   * @param {Object} config Conversion configuration.\n   * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n   * set, the converter will fire for every view element.\n   * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n   * instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n  elementToElement(config) {\n    return this.add(upcastElementToElement(config));\n  }\n  /**\n   * View element to model attribute conversion helper.\n   *\n   * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n   * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n   *\n   * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n   *\n   *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n   *\n   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n   * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n   *\n   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: 'strong',\n   *\t\t\tmodel: 'bold'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: 'strong',\n   *\t\t\tmodel: 'bold',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tclasses: 'bold'\n   *\t\t\t},\n   *\t\t\tmodel: 'bold'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'styled',\n   *\t\t\t\tvalue: 'dark'\n   *\t\t\t}\n   *\t\t} );\n   *\n   * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tstyles: {\n   *\t\t\t\t\t'font-size': /[\\s\\S]+/\n   *\t\t\t\t}\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'fontSize',\n   *\t\t\t\tvalue: viewElement => {\n   *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n   *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n   *\n   *\t\t\t\t\tif ( value <= 10 ) {\n   *\t\t\t\t\t\treturn 'small';\n   *\t\t\t\t\t} else if ( value > 12 ) {\n   *\t\t\t\t\t\treturn 'big';\n   *\t\t\t\t\t}\n   *\n   *\t\t\t\t\treturn null;\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToAttribute\n   * @param {Object} config Conversion configuration.\n   * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n   * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n   * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n   * If `String` is given, the model attribute value will be set to `true`.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n\n\n  elementToAttribute(config) {\n    return this.add(upcastElementToAttribute(config));\n  }\n  /**\n   * View attribute to model attribute conversion helper.\n   *\n   * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n   * `<image source=\"foo.jpg\"></image>` in the model.\n   *\n   * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n   * is set only on the corresponding model node:\n   *\n   *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n   *\n   * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n   * all the children in the model:\n   *\n   *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n   *\n   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n   * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n   *\n   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: 'src',\n   *\t\t\tmodel: 'source'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: { key: 'src' },\n   *\t\t\tmodel: 'source'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: { key: 'src' },\n   *\t\t\tmodel: 'source',\n   *\t\t\tconverterPriority: 'normal'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tkey: 'data-style',\n   *\t\t\t\tvalue: /[\\s\\S]+/\n   *\t\t\t},\n   *\t\t\tmodel: 'styled'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'img',\n   *\t\t\t\tkey: 'class',\n   *\t\t\t\tvalue: 'styled-dark'\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'styled',\n   *\t\t\t\tvalue: 'dark'\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tkey: 'class',\n   *\t\t\t\tvalue: /styled-[\\S]+/\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'styled'\n   *\t\t\t\tvalue: viewElement => {\n   *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n   *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n   *\n   *\t\t\t\t\treturn match[ 1 ];\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Converting styles works a bit differently as it requires `view.styles` to be an object and by default\n   * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`\n   * callback that returns the desired value.\n   *\n   *\t\t// Default conversion of font-weight style will result in setting bold attribute to true.\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tstyles: {\n   *\t\t\t\t\t'font-weight': 'bold'\n   *\t\t\t\t}\n   *\t\t\t},\n   *\t\t\tmodel: 'bold'\n   *\t\t} );\n   *\n   *\t\t// This converter will pass any style value to the `lineHeight` model attribute.\n   *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n   *\t\t\tview: {\n   *\t\t\t\tstyles: {\n   *\t\t\t\t\t'line-height': /[\\s\\S]+/\n   *\t\t\t\t}\n   *\t\t\t},\n   *\t\t\tmodel: {\n   *\t\t\t\tkey: 'lineHeight',\n   *\t\t\t\tvalue: viewElement => viewElement.getStyle( 'line-height' )\n   *\t\t\t}\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #attributeToAttribute\n   * @param {Object} config Conversion configuration.\n   * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n   * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n   * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n   * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n   * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n   * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n   * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n   * If `String` is given, the model attribute value will be same as view attribute value.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n\n\n  attributeToAttribute(config) {\n    return this.add(upcastAttributeToAttribute(config));\n  }\n  /**\n   * View element to model marker conversion helper.\n   *\n   * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n   * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n   * after the conversion is done, the marker will be available in\n   * {@link module:engine/model/model~Model#markers model document markers}.\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n   *\t\t\tview: 'marker-search',\n   *\t\t\tmodel: 'search'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n   *\t\t\tview: 'marker-search',\n   *\t\t\tmodel: 'search',\n   *\t\t\tconverterPriority: 'high'\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n   *\t\t\tview: 'marker-search',\n   *\t\t\tmodel: viewElement => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n   *\t\t} );\n   *\n   *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n   *\t\t\tview: {\n   *\t\t\t\tname: 'span',\n   *\t\t\t\tattributes: {\n   *\t\t\t\t\t'data-marker': 'search'\n   *\t\t\t\t}\n   *\t\t\t},\n   *\t\t\tmodel: 'search'\n   *\t\t} );\n   *\n   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n   * to the conversion process.\n   *\n   * @method #elementToMarker\n   * @param {Object} config Conversion configuration.\n   * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n   * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n   * a model marker name.\n   * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n   * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n   */\n\n\n  elementToMarker(config) {\n    return this.add(upcastElementToMarker(config));\n  }\n\n}\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\n\nexport function convertToModelFragment() {\n  return (evt, data, conversionApi) => {\n    // Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n    if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {\n      name: true\n    })) {\n      const {\n        modelRange,\n        modelCursor\n      } = conversionApi.convertChildren(data.viewItem, data.modelCursor);\n      data.modelRange = modelRange;\n      data.modelCursor = modelCursor;\n    }\n  };\n}\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\n\nexport function convertText() {\n  return (evt, data, conversionApi) => {\n    if (conversionApi.schema.checkChild(data.modelCursor, '$text')) {\n      if (conversionApi.consumable.consume(data.viewItem)) {\n        const text = conversionApi.writer.createText(data.viewItem.data);\n        conversionApi.writer.insert(text, data.modelCursor);\n        data.modelRange = ModelRange._createFromPositionAndShift(data.modelCursor, text.offsetSize);\n        data.modelCursor = data.modelRange.end;\n      }\n    }\n  };\n}\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\n\nexport function convertSelectionChange(model, mapper) {\n  return (evt, data) => {\n    const viewSelection = data.newSelection;\n    const modelSelection = new ModelSelection();\n    const ranges = [];\n\n    for (const viewRange of viewSelection.getRanges()) {\n      ranges.push(mapper.toModelRange(viewRange));\n    }\n\n    modelSelection.setTo(ranges, {\n      backward: viewSelection.isBackward\n    });\n\n    if (!modelSelection.isEqual(model.document.selection)) {\n      model.change(writer => {\n        writer.setSelection(modelSelection);\n      });\n    }\n  };\n} // View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\nfunction upcastElementToElement(config) {\n  config = cloneDeep(config);\n  const converter = prepareToElementConverter(config);\n  const elementName = getViewElementNameFromConfig(config.view);\n  const eventName = elementName ? 'element:' + elementName : 'element';\n  return dispatcher => {\n    dispatcher.on(eventName, converter, {\n      priority: config.converterPriority || 'normal'\n    });\n  };\n} // View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastElementToAttribute(config) {\n  config = cloneDeep(config);\n  normalizeModelAttributeConfig(config);\n  const converter = prepareToAttributeConverter(config, false);\n  const elementName = getViewElementNameFromConfig(config.view);\n  const eventName = elementName ? 'element:' + elementName : 'element';\n  return dispatcher => {\n    dispatcher.on(eventName, converter, {\n      priority: config.converterPriority || 'low'\n    });\n  };\n} // View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastAttributeToAttribute(config) {\n  config = cloneDeep(config);\n  let viewKey = null;\n\n  if (typeof config.view == 'string' || config.view.key) {\n    viewKey = normalizeViewAttributeKeyValueConfig(config);\n  }\n\n  normalizeModelAttributeConfig(config, viewKey);\n  const converter = prepareToAttributeConverter(config, true);\n  return dispatcher => {\n    dispatcher.on('element', converter, {\n      priority: config.converterPriority || 'low'\n    });\n  };\n} // View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\n\n\nfunction upcastElementToMarker(config) {\n  config = cloneDeep(config);\n  normalizeToMarkerConfig(config);\n  return upcastElementToElement(config);\n} // Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion view config.\n// @returns {String|null} View element name or `null` if name is not directly set.\n\n\nfunction getViewElementNameFromConfig(viewConfig) {\n  if (typeof viewConfig == 'string') {\n    return viewConfig;\n  }\n\n  if (typeof viewConfig == 'object' && typeof viewConfig.name == 'string') {\n    return viewConfig.name;\n  }\n\n  return null;\n} // Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\n\n\nfunction prepareToElementConverter(config) {\n  const matcher = config.view ? new Matcher(config.view) : null;\n  return (evt, data, conversionApi) => {\n    let match = {}; // If `config.view` has not been passed do not try matching. In this case, the converter should fire for all elements.\n\n    if (matcher) {\n      // This will be usually just one pattern but we support matchers with many patterns too.\n      const matcherResult = matcher.match(data.viewItem); // If there is no match, this callback should not do anything.\n\n      if (!matcherResult) {\n        return;\n      }\n\n      match = matcherResult.match;\n    } // Force consuming element's name.\n\n\n    match.name = true; // Create model element basing on config.\n\n    const modelElement = getModelElement(config.model, data.viewItem, conversionApi.writer); // Do not convert if element building function returned falsy value.\n\n    if (!modelElement) {\n      return;\n    } // When element was already consumed then skip it.\n\n\n    if (!conversionApi.consumable.test(data.viewItem, match)) {\n      return;\n    } // Find allowed parent for element that we are going to insert.\n    // If current parent does not allow to insert element but one of the ancestors does\n    // then split nodes to allowed parent.\n\n\n    const splitResult = conversionApi.splitToAllowedParent(modelElement, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\n    if (!splitResult) {\n      return;\n    } // Insert element on allowed position.\n\n\n    conversionApi.writer.insert(modelElement, splitResult.position); // Convert children and insert to element.\n\n    conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelElement, 0)); // Consume appropriate value from consumable values list.\n\n    conversionApi.consumable.consume(data.viewItem, match);\n    const parts = conversionApi.getSplitParts(modelElement); // Set conversion result range.\n\n    data.modelRange = new ModelRange(conversionApi.writer.createPositionBefore(modelElement), conversionApi.writer.createPositionAfter(parts[parts.length - 1])); // Now we need to check where the `modelCursor` should be.\n\n    if (splitResult.cursorParent) {\n      // If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n      //\n      // before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n      // after:  <allowed><notAllowed>foo</notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n      data.modelCursor = conversionApi.writer.createPositionAt(splitResult.cursorParent, 0);\n    } else {\n      // Otherwise just continue after inserted element.\n      data.modelCursor = data.modelRange.end;\n    }\n  };\n} // Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/model/writer~Writer} writer A writer instance to use to create the model element.\n\n\nfunction getModelElement(model, input, writer) {\n  if (model instanceof Function) {\n    return model(input, writer);\n  } else {\n    return writer.createElement(model);\n  }\n} // Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\n\n\nfunction normalizeViewAttributeKeyValueConfig(config) {\n  if (typeof config.view == 'string') {\n    config.view = {\n      key: config.view\n    };\n  }\n\n  const key = config.view.key;\n  let normalized;\n\n  if (key == 'class' || key == 'style') {\n    const keyName = key == 'class' ? 'classes' : 'styles';\n    normalized = {\n      [keyName]: config.view.value\n    };\n  } else {\n    const value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n    normalized = {\n      attributes: {\n        [key]: value\n      }\n    };\n  }\n\n  if (config.view.name) {\n    normalized.name = config.view.name;\n  }\n\n  config.view = normalized;\n  return key;\n} // Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\n\n\nfunction normalizeModelAttributeConfig(config, viewAttributeKeyToCopy = null) {\n  const defaultModelValue = viewAttributeKeyToCopy === null ? true : viewElement => viewElement.getAttribute(viewAttributeKeyToCopy);\n  const key = typeof config.model != 'object' ? config.model : config.model.key;\n  const value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n  config.model = {\n    key,\n    value\n  };\n} // Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n\n\nfunction prepareToAttributeConverter(config, shallow) {\n  const matcher = new Matcher(config.view);\n  return (evt, data, conversionApi) => {\n    const match = matcher.match(data.viewItem); // If there is no match, this callback should not do anything.\n\n    if (!match) {\n      return;\n    }\n\n    const modelKey = config.model.key;\n    const modelValue = typeof config.model.value == 'function' ? config.model.value(data.viewItem) : config.model.value; // Do not convert if attribute building function returned falsy value.\n\n    if (modelValue === null) {\n      return;\n    }\n\n    if (onlyViewNameIsDefined(config.view, data.viewItem)) {\n      match.match.name = true;\n    } else {\n      // Do not test or consume `name` consumable.\n      delete match.match.name;\n    } // Try to consume appropriate values from consumable values list.\n\n\n    if (!conversionApi.consumable.test(data.viewItem, match.match)) {\n      return;\n    } // Since we are converting to attribute we need an range on which we will set the attribute.\n    // If the range is not created yet, we will create it.\n\n\n    if (!data.modelRange) {\n      // Convert children and set conversion result as a current data.\n      data = Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));\n    } // Set attribute on current `output`. `Schema` is checked inside this helper function.\n\n\n    const attributeWasSet = setAttributeOn(data.modelRange, {\n      key: modelKey,\n      value: modelValue\n    }, shallow, conversionApi);\n\n    if (attributeWasSet) {\n      conversionApi.consumable.consume(data.viewItem, match.match);\n    }\n  };\n} // Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion view config.\n// @returns {Boolean}\n\n\nfunction onlyViewNameIsDefined(viewConfig, viewItem) {\n  // https://github.com/ckeditor/ckeditor5-engine/issues/1786\n  const configToTest = typeof viewConfig == 'function' ? viewConfig(viewItem) : viewConfig;\n\n  if (typeof configToTest == 'object' && !getViewElementNameFromConfig(configToTest)) {\n    return false;\n  }\n\n  return !configToTest.classes && !configToTest.attributes && !configToTest.styles;\n} // Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\n\n\nfunction setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {\n  let result = false; // Set attribute on each item in range according to Schema.\n\n  for (const node of Array.from(modelRange.getItems({\n    shallow\n  }))) {\n    if (conversionApi.schema.checkAttribute(node, modelAttribute.key)) {\n      conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);\n      result = true;\n    }\n  }\n\n  return result;\n} // Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `_upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\n\n\nfunction normalizeToMarkerConfig(config) {\n  const oldModel = config.model;\n\n  config.model = (viewElement, modelWriter) => {\n    const markerName = typeof oldModel == 'string' ? oldModel : oldModel(viewElement);\n    return modelWriter.createElement('$marker', {\n      'data-name': markerName\n    });\n  };\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js"],"names":["Matcher","ModelRange","ConversionHelpers","cloneDeep","ModelSelection","UpcastHelpers","elementToElement","config","add","upcastElementToElement","elementToAttribute","upcastElementToAttribute","attributeToAttribute","upcastAttributeToAttribute","elementToMarker","upcastElementToMarker","convertToModelFragment","evt","data","conversionApi","modelRange","consumable","consume","viewItem","name","modelCursor","convertChildren","convertText","schema","checkChild","text","writer","createText","insert","_createFromPositionAndShift","offsetSize","end","convertSelectionChange","model","mapper","viewSelection","newSelection","modelSelection","ranges","viewRange","getRanges","push","toModelRange","setTo","backward","isBackward","isEqual","document","selection","change","setSelection","converter","prepareToElementConverter","elementName","getViewElementNameFromConfig","view","eventName","dispatcher","on","priority","converterPriority","normalizeModelAttributeConfig","prepareToAttributeConverter","viewKey","key","normalizeViewAttributeKeyValueConfig","normalizeToMarkerConfig","viewConfig","matcher","match","matcherResult","modelElement","getModelElement","test","splitResult","splitToAllowedParent","position","createPositionAt","parts","getSplitParts","createPositionBefore","createPositionAfter","length","cursorParent","input","Function","createElement","normalized","keyName","value","attributes","viewAttributeKeyToCopy","defaultModelValue","viewElement","getAttribute","shallow","modelKey","modelValue","onlyViewNameIsDefined","Object","assign","attributeWasSet","setAttributeOn","configToTest","classes","styles","modelAttribute","result","node","Array","from","getItems","checkAttribute","setAttribute","oldModel","modelWriter","markerName"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport Matcher from '../view/matcher';\nimport ModelRange from '../model/range';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\nimport ModelSelection from '../model/selection';\n\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class UpcastHelpers extends ConversionHelpers {\n\t/**\n\t * View element to model element conversion helper.\n\t *\n\t * This conversion results in creating a model element. For example,\n\t * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n\t *\n\t * Keep in mind that the element will be inserted only if it is allowed\n\t * by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'fancyParagraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t * \t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'heading'\n\t * \t\t\t},\n\t * \t\t\tmodel: ( viewElement, modelWriter ) => {\n\t * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n\t * \t\t\t}\n\t * \t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n\t * set, the converter will fire for every view element.\n\t * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n\t * instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( upcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * View element to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n\t * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n\t *\n\t * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-size': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalue: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n\t *\n\t *\t\t\t\t\tif ( value <= 10 ) {\n\t *\t\t\t\t\t\treturn 'small';\n\t *\t\t\t\t\t} else if ( value > 12 ) {\n\t *\t\t\t\t\t\treturn 'big';\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n\t * If `String` is given, the model attribute value will be set to `true`.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToAttribute( config ) {\n\t\treturn this.add( upcastElementToAttribute( config ) );\n\t}\n\n\t/**\n\t * View attribute to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n\t * `<image source=\"foo.jpg\"></image>` in the model.\n\t *\n\t * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n\t * is set only on the corresponding model node:\n\t *\n\t *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n\t *\n\t * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n\t * all the children in the model:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: 'src',\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tconverterPriority: 'normal'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'data-style',\n\t *\t\t\t\tvalue: /[\\s\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: 'styled'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'img',\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: 'styled-dark'\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: /styled-[\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled'\n\t *\t\t\t\tvalue: viewElement => {\n\t *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n\t *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n\t *\n\t *\t\t\t\t\treturn match[ 1 ];\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Converting styles works a bit differently as it requires `view.styles` to be an object and by default\n\t * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`\n\t * callback that returns the desired value.\n\t *\n\t *\t\t// Default conversion of font-weight style will result in setting bold attribute to true.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\t// This converter will pass any style value to the `lineHeight` model attribute.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'line-height': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'lineHeight',\n\t *\t\t\t\tvalue: viewElement => viewElement.getStyle( 'line-height' )\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n\t * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n\t * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n\t * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n\t * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n\t * If `String` is given, the model attribute value will be same as view attribute value.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( upcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * View element to model marker conversion helper.\n\t *\n\t * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n\t * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n\t * after the conversion is done, the marker will be available in\n\t * {@link module:engine/model/model~Model#markers model document markers}.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: viewElement => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToMarker\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n\t * a model marker name.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToMarker( config ) {\n\t\treturn this.add( upcastElementToMarker( config ) );\n\t}\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\nexport function convertToModelFragment() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n\t\tif ( !data.modelRange && conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\t\tconst { modelRange, modelCursor } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n\n\t\t\tdata.modelRange = modelRange;\n\t\t\tdata.modelCursor = modelCursor;\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\nexport function convertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( conversionApi.schema.checkChild( data.modelCursor, '$text' ) ) {\n\t\t\tif ( conversionApi.consumable.consume( data.viewItem ) ) {\n\t\t\t\tconst text = conversionApi.writer.createText( data.viewItem.data );\n\n\t\t\t\tconversionApi.writer.insert( text, data.modelCursor );\n\n\t\t\t\tdata.modelRange = ModelRange._createFromPositionAndShift( data.modelCursor, text.offsetSize );\n\t\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\nexport function convertSelectionChange( model, mapper ) {\n\treturn ( evt, data ) => {\n\t\tconst viewSelection = data.newSelection;\n\t\tconst modelSelection = new ModelSelection();\n\n\t\tconst ranges = [];\n\n\t\tfor ( const viewRange of viewSelection.getRanges() ) {\n\t\t\tranges.push( mapper.toModelRange( viewRange ) );\n\t\t}\n\n\t\tmodelSelection.setTo( ranges, { backward: viewSelection.isBackward } );\n\n\t\tif ( !modelSelection.isEqual( model.document.selection ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( modelSelection );\n\t\t\t} );\n\t\t}\n\t};\n}\n\n// View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst converter = prepareToElementConverter( config );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeModelAttributeConfig( config );\n\n\tconst converter = prepareToAttributeConverter( config, false );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tlet viewKey = null;\n\n\tif ( typeof config.view == 'string' || config.view.key ) {\n\t\tviewKey = normalizeViewAttributeKeyValueConfig( config );\n\t}\n\n\tnormalizeModelAttributeConfig( config, viewKey );\n\n\tconst converter = prepareToAttributeConverter( config, true );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element', converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToMarker( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeToMarkerConfig( config );\n\n\treturn upcastElementToElement( config );\n}\n\n// Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion view config.\n// @returns {String|null} View element name or `null` if name is not directly set.\nfunction getViewElementNameFromConfig( viewConfig ) {\n\tif ( typeof viewConfig == 'string' ) {\n\t\treturn viewConfig;\n\t}\n\n\tif ( typeof viewConfig == 'object' && typeof viewConfig.name == 'string' ) {\n\t\treturn viewConfig.name;\n\t}\n\n\treturn null;\n}\n\n// Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\nfunction prepareToElementConverter( config ) {\n\tconst matcher = config.view ? new Matcher( config.view ) : null;\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tlet match = {};\n\n\t\t// If `config.view` has not been passed do not try matching. In this case, the converter should fire for all elements.\n\t\tif ( matcher ) {\n\t\t\t// This will be usually just one pattern but we support matchers with many patterns too.\n\t\t\tconst matcherResult = matcher.match( data.viewItem );\n\n\t\t\t// If there is no match, this callback should not do anything.\n\t\t\tif ( !matcherResult ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmatch = matcherResult.match;\n\t\t}\n\n\t\t// Force consuming element's name.\n\t\tmatch.name = true;\n\n\t\t// Create model element basing on config.\n\t\tconst modelElement = getModelElement( config.model, data.viewItem, conversionApi.writer );\n\n\t\t// Do not convert if element building function returned falsy value.\n\t\tif ( !modelElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// When element was already consumed then skip it.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find allowed parent for element that we are going to insert.\n\t\t// If current parent does not allow to insert element but one of the ancestors does\n\t\t// then split nodes to allowed parent.\n\t\tconst splitResult = conversionApi.splitToAllowedParent( modelElement, data.modelCursor );\n\n\t\t// When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\t\tif ( !splitResult ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Insert element on allowed position.\n\t\tconversionApi.writer.insert( modelElement, splitResult.position );\n\n\t\t// Convert children and insert to element.\n\t\tconversionApi.convertChildren( data.viewItem, conversionApi.writer.createPositionAt( modelElement, 0 ) );\n\n\t\t// Consume appropriate value from consumable values list.\n\t\tconversionApi.consumable.consume( data.viewItem, match );\n\n\t\tconst parts = conversionApi.getSplitParts( modelElement );\n\n\t\t// Set conversion result range.\n\t\tdata.modelRange = new ModelRange(\n\t\t\tconversionApi.writer.createPositionBefore( modelElement ),\n\t\t\tconversionApi.writer.createPositionAfter( parts[ parts.length - 1 ] )\n\t\t);\n\n\t\t// Now we need to check where the `modelCursor` should be.\n\t\tif ( splitResult.cursorParent ) {\n\t\t\t// If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n\t\t\t//\n\t\t\t// before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n\t\t\t// after:  <allowed><notAllowed>foo</notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n\n\t\t\tdata.modelCursor = conversionApi.writer.createPositionAt( splitResult.cursorParent, 0 );\n\t\t} else {\n\t\t\t// Otherwise just continue after inserted element.\n\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t}\n\t};\n}\n\n// Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/model/writer~Writer} writer A writer instance to use to create the model element.\nfunction getModelElement( model, input, writer ) {\n\tif ( model instanceof Function ) {\n\t\treturn model( input, writer );\n\t} else {\n\t\treturn writer.createElement( model );\n\t}\n}\n\n// Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\nfunction normalizeViewAttributeKeyValueConfig( config ) {\n\tif ( typeof config.view == 'string' ) {\n\t\tconfig.view = { key: config.view };\n\t}\n\n\tconst key = config.view.key;\n\tlet normalized;\n\n\tif ( key == 'class' || key == 'style' ) {\n\t\tconst keyName = key == 'class' ? 'classes' : 'styles';\n\n\t\tnormalized = {\n\t\t\t[ keyName ]: config.view.value\n\t\t};\n\t} else {\n\t\tconst value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n\n\t\tnormalized = {\n\t\t\tattributes: {\n\t\t\t\t[ key ]: value\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( config.view.name ) {\n\t\tnormalized.name = config.view.name;\n\t}\n\n\tconfig.view = normalized;\n\n\treturn key;\n}\n\n// Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\nfunction normalizeModelAttributeConfig( config, viewAttributeKeyToCopy = null ) {\n\tconst defaultModelValue = viewAttributeKeyToCopy === null ? true : viewElement => viewElement.getAttribute( viewAttributeKeyToCopy );\n\n\tconst key = typeof config.model != 'object' ? config.model : config.model.key;\n\tconst value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n\n\tconfig.model = { key, value };\n}\n\n// Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\nfunction prepareToAttributeConverter( config, shallow ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst match = matcher.match( data.viewItem );\n\n\t\t// If there is no match, this callback should not do anything.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelKey = config.model.key;\n\t\tconst modelValue = typeof config.model.value == 'function' ? config.model.value( data.viewItem ) : config.model.value;\n\n\t\t// Do not convert if attribute building function returned falsy value.\n\t\tif ( modelValue === null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( onlyViewNameIsDefined( config.view, data.viewItem ) ) {\n\t\t\tmatch.match.name = true;\n\t\t} else {\n\t\t\t// Do not test or consume `name` consumable.\n\t\t\tdelete match.match.name;\n\t\t}\n\n\t\t// Try to consume appropriate values from consumable values list.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match.match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Since we are converting to attribute we need an range on which we will set the attribute.\n\t\t// If the range is not created yet, we will create it.\n\t\tif ( !data.modelRange ) {\n\t\t\t// Convert children and set conversion result as a current data.\n\t\t\tdata = Object.assign( data, conversionApi.convertChildren( data.viewItem, data.modelCursor ) );\n\t\t}\n\n\t\t// Set attribute on current `output`. `Schema` is checked inside this helper function.\n\t\tconst attributeWasSet = setAttributeOn( data.modelRange, { key: modelKey, value: modelValue }, shallow, conversionApi );\n\n\t\tif ( attributeWasSet ) {\n\t\t\tconversionApi.consumable.consume( data.viewItem, match.match );\n\t\t}\n\t};\n}\n\n// Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion view config.\n// @returns {Boolean}\nfunction onlyViewNameIsDefined( viewConfig, viewItem ) {\n\t// https://github.com/ckeditor/ckeditor5-engine/issues/1786\n\tconst configToTest = typeof viewConfig == 'function' ? viewConfig( viewItem ) : viewConfig;\n\n\tif ( typeof configToTest == 'object' && !getViewElementNameFromConfig( configToTest ) ) {\n\t\treturn false;\n\t}\n\n\treturn !configToTest.classes && !configToTest.attributes && !configToTest.styles;\n}\n\n// Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\nfunction setAttributeOn( modelRange, modelAttribute, shallow, conversionApi ) {\n\tlet result = false;\n\n\t// Set attribute on each item in range according to Schema.\n\tfor ( const node of Array.from( modelRange.getItems( { shallow } ) ) ) {\n\t\tif ( conversionApi.schema.checkAttribute( node, modelAttribute.key ) ) {\n\t\t\tconversionApi.writer.setAttribute( modelAttribute.key, modelAttribute.value, node );\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `_upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\nfunction normalizeToMarkerConfig( config ) {\n\tconst oldModel = config.model;\n\n\tconfig.model = ( viewElement, modelWriter ) => {\n\t\tconst markerName = typeof oldModel == 'string' ? oldModel : oldModel( viewElement );\n\n\t\treturn modelWriter.createElement( '$marker', { 'data-name': markerName } );\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}