{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/collection\n */\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport isIterable from './isiterable';\nimport mix from './mix';\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class Collection {\n  /**\n   * Creates a new Collection instance.\n   *\n   * You can provide an iterable of initial items the collection will be created with:\n   *\n   *\t\tconst collection = new Collection( [ { id: 'John' }, { id: 'Mike' } ] );\n   *\n   *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n   *\t\tconsole.log( collection.get( 1 ) ); // -> { id: 'Mike' }\n   *\t\tconsole.log( collection.get( 'Mike' ) ); // -> { id: 'Mike' }\n   *\n   * Or you can first create a collection and then add new items using the {@link #add} method:\n   *\n   *\t\tconst collection = new Collection();\n   *\n   *\t\tcollection.add( { id: 'John' } );\n   *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n   *\n   * Whatever option you choose, you can always pass a configuration object as the last argument\n   * of the constructor:\n   *\n   *\t\tconst emptyCollection = new Collection( { idProperty: 'name' } );\n   *\t\temptyCollection.add( { name: 'John' } );\n   *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n   *\n   *\t\tconst nonEmptyCollection = new Collection( [ { name: 'John' } ], { idProperty: 'name' } );\n   *\t\tnonEmptyCollection.add( { name: 'George' } );\n   *\t\tconsole.log( collection.get( 'George' ) ); // -> { name: 'George' }\n   *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n   *\n   * @param {Iterable.<Object>|Object} initialItemsOrOptions The initial items of the collection or\n   * the options object.\n   * @param {Object} [options={}] The options object, when the first argument is an array of initial items.\n   * @param {String} [options.idProperty='id'] The name of the property which is used to identify an item.\n   * Items that do not have such a property will be assigned one when added to the collection.\n   */\n  constructor(initialItemsOrOptions = {}, options = {}) {\n    const hasInitialItems = isIterable(initialItemsOrOptions);\n\n    if (!hasInitialItems) {\n      options = initialItemsOrOptions;\n    }\n    /**\n     * The internal list of items in the collection.\n     *\n     * @private\n     * @member {Object[]}\n     */\n\n\n    this._items = [];\n    /**\n     * The internal map of items in the collection.\n     *\n     * @private\n     * @member {Map}\n     */\n\n    this._itemMap = new Map();\n    /**\n     * The name of the property which is considered to identify an item.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._idProperty = options.idProperty || 'id';\n    /**\n     * A helper mapping external items of a bound collection ({@link #bindTo})\n     * and actual items of this collection. It provides information\n     * necessary to properly remove items bound to another collection.\n     *\n     * See {@link #_bindToInternalToExternalMap}.\n     *\n     * @protected\n     * @member {WeakMap}\n     */\n\n    this._bindToExternalToInternalMap = new WeakMap();\n    /**\n     * A helper mapping items of this collection to external items of a bound collection\n     * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.\n     * to avoid loops in twoâ€“way bindings.\n     *\n     * See {@link #_bindToExternalToInternalMap}.\n     *\n     * @protected\n     * @member {WeakMap}\n     */\n\n    this._bindToInternalToExternalMap = new WeakMap();\n    /**\n     * Stores indexes of skipped items from bound external collection.\n     *\n     * @private\n     * @member {Array}\n     */\n\n    this._skippedIndexesFromExternal = []; // Set the initial content of the collection (if provided in the constructor).\n\n    if (hasInitialItems) {\n      for (const item of initialItemsOrOptions) {\n        this._items.push(item);\n\n        this._itemMap.set(this._getItemIdBeforeAdding(item), item);\n      }\n    }\n    /**\n     * A collection instance this collection is bound to as a result\n     * of calling {@link #bindTo} method.\n     *\n     * @protected\n     * @member {module:utils/collection~Collection} #_bindToCollection\n     */\n\n  }\n  /**\n   * The number of items available in the collection.\n   *\n   * @member {Number} #length\n   */\n\n\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Returns the first item from the collection or null when collection is empty.\n   *\n   * @returns {Object|null} The first item or `null` if collection is empty.\n   */\n\n\n  get first() {\n    return this._items[0] || null;\n  }\n  /**\n   * Returns the last item from the collection or null when collection is empty.\n   *\n   * @returns {Object|null} The last item or `null` if collection is empty.\n   */\n\n\n  get last() {\n    return this._items[this.length - 1] || null;\n  }\n  /**\n   * Adds an item into the collection.\n   *\n   * If the item does not have an id, then it will be automatically generated and set on the item.\n   *\n   * @chainable\n   * @param {Object} item\n   * @param {Number} [index] The position of the item in the collection. The item\n   * is pushed to the collection when `index` not specified.\n   * @fires add\n   */\n\n\n  add(item, index) {\n    const itemId = this._getItemIdBeforeAdding(item); // TODO: Use ES6 default function argument.\n\n\n    if (index === undefined) {\n      index = this._items.length;\n    } else if (index > this._items.length || index < 0) {\n      /**\n       * The index number has invalid value.\n       *\n       * @error collection-add-item-bad-index\n       */\n      throw new CKEditorError('collection-add-item-invalid-index', this);\n    }\n\n    this._items.splice(index, 0, item);\n\n    this._itemMap.set(itemId, item);\n\n    this.fire('add', item, index);\n    return this;\n  }\n  /**\n   * Gets item by its id or index.\n   *\n   * @param {String|Number} idOrIndex The item id or index in the collection.\n   * @returns {Object|null} The requested item or `null` if such item does not exist.\n   */\n\n\n  get(idOrIndex) {\n    let item;\n\n    if (typeof idOrIndex == 'string') {\n      item = this._itemMap.get(idOrIndex);\n    } else if (typeof idOrIndex == 'number') {\n      item = this._items[idOrIndex];\n    } else {\n      /**\n       * Index or id must be given.\n       *\n       * @error collection-get-invalid-arg\n       */\n      throw new CKEditorError('collection-get-invalid-arg: Index or id must be given.', this);\n    }\n\n    return item || null;\n  }\n  /**\n   * Returns a boolean indicating whether the collection contains an item.\n   *\n   * @param {Object|String} itemOrId The item or its id in the collection.\n   * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n   */\n\n\n  has(itemOrId) {\n    if (typeof itemOrId == 'string') {\n      return this._itemMap.has(itemOrId);\n    } else {\n      // Object\n      const idProperty = this._idProperty;\n      const id = itemOrId[idProperty];\n      return this._itemMap.has(id);\n    }\n  }\n  /**\n   * Gets index of item in the collection.\n   * When item is not defined in the collection then index will be equal -1.\n   *\n   * @param {Object|String} itemOrId The item or its id in the collection.\n   * @returns {Number} Index of given item.\n   */\n\n\n  getIndex(itemOrId) {\n    let item;\n\n    if (typeof itemOrId == 'string') {\n      item = this._itemMap.get(itemOrId);\n    } else {\n      item = itemOrId;\n    }\n\n    return this._items.indexOf(item);\n  }\n  /**\n   * Removes an item from the collection.\n   *\n   * @param {Object|Number|String} subject The item to remove, its id or index in the collection.\n   * @returns {Object} The removed item.\n   * @fires remove\n   */\n\n\n  remove(subject) {\n    let index, id, item;\n    let itemDoesNotExist = false;\n    const idProperty = this._idProperty;\n\n    if (typeof subject == 'string') {\n      id = subject;\n      item = this._itemMap.get(id);\n      itemDoesNotExist = !item;\n\n      if (item) {\n        index = this._items.indexOf(item);\n      }\n    } else if (typeof subject == 'number') {\n      index = subject;\n      item = this._items[index];\n      itemDoesNotExist = !item;\n\n      if (item) {\n        id = item[idProperty];\n      }\n    } else {\n      item = subject;\n      id = item[idProperty];\n      index = this._items.indexOf(item);\n      itemDoesNotExist = index == -1 || !this._itemMap.get(id);\n    }\n\n    if (itemDoesNotExist) {\n      /**\n       * Item not found.\n       *\n       * @error collection-remove-404\n       */\n      throw new CKEditorError('collection-remove-404: Item not found.', this);\n    }\n\n    this._items.splice(index, 1);\n\n    this._itemMap.delete(id);\n\n    const externalItem = this._bindToInternalToExternalMap.get(item);\n\n    this._bindToInternalToExternalMap.delete(item);\n\n    this._bindToExternalToInternalMap.delete(externalItem);\n\n    this.fire('remove', item, index);\n    return item;\n  }\n  /**\n   * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Array} The result of mapping.\n   */\n\n\n  map(callback, ctx) {\n    return this._items.map(callback, ctx);\n  }\n  /**\n   * Finds the first item in the collection for which the `callback` returns a true value.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Object} The item for which `callback` returned a true value.\n   */\n\n\n  find(callback, ctx) {\n    return this._items.find(callback, ctx);\n  }\n  /**\n   * Returns an array with items for which the `callback` returned a true value.\n   *\n   * @param {Function} callback\n   * @param {Object} callback.item\n   * @param {Number} callback.index\n   * @param {Object} ctx Context in which the `callback` will be called.\n   * @returns {Object[]} The array with matching items.\n   */\n\n\n  filter(callback, ctx) {\n    return this._items.filter(callback, ctx);\n  }\n  /**\n   * Removes all items from the collection and destroys the binding created using\n   * {@link #bindTo}.\n   */\n\n\n  clear() {\n    if (this._bindToCollection) {\n      this.stopListening(this._bindToCollection);\n      this._bindToCollection = null;\n    }\n\n    while (this.length) {\n      this.remove(0);\n    }\n  }\n  /**\n   * Binds and synchronizes the collection with another one.\n   *\n   * The binding can be a simple factory:\n   *\n   *\t\tclass FactoryClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).as( FactoryClass );\n   *\n   *\t\tsource.add( { label: 'foo' } );\n   *\t\tsource.add( { label: 'bar' } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n   *\n   *\t\tsource.remove( 0 );\n   *\t\tconsole.log( target.length ); // 1\n   *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n   *\n   * or the factory driven by a custom callback:\n   *\n   *\t\tclass FooClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tclass BarClass {\n   *\t\t\tconstructor( data ) {\n   *\t\t\t\tthis.label = data.label;\n   *\t\t\t}\n   *\t\t}\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( ( item ) => {\n   *\t\t\tif ( item.label == 'foo' ) {\n   *\t\t\t\treturn new FooClass( item );\n   *\t\t\t} else {\n   *\t\t\t\treturn new BarClass( item );\n   *\t\t\t}\n   *\t\t} );\n   *\n   *\t\tsource.add( { label: 'foo' } );\n   *\t\tsource.add( { label: 'bar' } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n   *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n   *\n   * or the factory out of property name:\n   *\n   *\t\tconst source = new Collection( { idProperty: 'label' } );\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( 'label' );\n   *\n   *\t\tsource.add( { label: { value: 'foo' } } );\n   *\t\tsource.add( { label: { value: 'bar' } } );\n   *\n   *\t\tconsole.log( target.length ); // 2\n   *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n   *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n   *\n   * It's possible to skip specified items by returning falsy value:\n   *\n   *\t\tconst source = new Collection();\n   *\t\tconst target = new Collection();\n   *\n   *\t\ttarget.bindTo( source ).using( item => {\n   *\t\t\tif ( item.hidden ) {\n   *\t\t\t\treturn null;\n   *\t\t\t}\n   *\n   *\t\t\treturn item;\n   *\t\t} );\n   *\n   *\t\tsource.add( { hidden: true } );\n   *\t\tsource.add( { hidden: false } );\n   *\n   *\t\tconsole.log( source.length ); // 2\n   *\t\tconsole.log( target.length ); // 1\n   *\n   * **Note**: {@link #clear} can be used to break the binding.\n   *\n   * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n   * @returns {Object}\n   * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n   */\n\n\n  bindTo(externalCollection) {\n    if (this._bindToCollection) {\n      /**\n       * The collection cannot be bound more than once.\n       *\n       * @error collection-bind-to-rebind\n       */\n      throw new CKEditorError('collection-bind-to-rebind: The collection cannot be bound more than once.', this);\n    }\n\n    this._bindToCollection = externalCollection;\n    return {\n      as: Class => {\n        this._setUpBindToBinding(item => new Class(item));\n      },\n      using: callbackOrProperty => {\n        if (typeof callbackOrProperty == 'function') {\n          this._setUpBindToBinding(item => callbackOrProperty(item));\n        } else {\n          this._setUpBindToBinding(item => item[callbackOrProperty]);\n        }\n      }\n    };\n  }\n  /**\n   * Finalizes and activates a binding initiated by {#bindTo}.\n   *\n   * @protected\n   * @param {Function} factory A function which produces collection items.\n   */\n\n\n  _setUpBindToBinding(factory) {\n    const externalCollection = this._bindToCollection; // Adds the item to the collection once a change has been done to the external collection.\n    //\n    // @private\n\n    const addItem = (evt, externalItem, index) => {\n      const isExternalBoundToThis = externalCollection._bindToCollection == this;\n\n      const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem); // If an external collection is bound to this collection, which makes it a 2â€“way binding,\n      // and the particular external collection item is already bound, don't add it here.\n      // The external item has been created **out of this collection's item** and (re)adding it will\n      // cause a loop.\n\n\n      if (isExternalBoundToThis && externalItemBound) {\n        this._bindToExternalToInternalMap.set(externalItem, externalItemBound);\n\n        this._bindToInternalToExternalMap.set(externalItemBound, externalItem);\n      } else {\n        const item = factory(externalItem); // When there is no item we need to remember skipped index first and then we can skip this item.\n\n        if (!item) {\n          this._skippedIndexesFromExternal.push(index);\n\n          return;\n        } // Lets try to put item at the same index as index in external collection\n        // but when there are a skipped items in one or both collections we need to recalculate this index.\n\n\n        let finalIndex = index; // When we try to insert item after some skipped items from external collection we need\n        // to include this skipped items and decrease index.\n        //\n        // For the following example:\n        // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n        // internal -> [ A ]\n        //\n        // Another item is been added at the end of external collection:\n        // external.add( 'D' )\n        // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n        //\n        // We can't just add 'D' to internal at the same index as index in external because\n        // this will produce empty indexes what is invalid:\n        // internal -> [ 'A', empty, empty, 'D' ]\n        //\n        // So we need to include skipped items and decrease index\n        // internal -> [ 'A', 'D' ]\n\n        for (const skipped of this._skippedIndexesFromExternal) {\n          if (index > skipped) {\n            finalIndex--;\n          }\n        } // We need to take into consideration that external collection could skip some items from\n        // internal collection.\n        //\n        // For the following example:\n        // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n        // external -> [ A ]\n        //\n        // Another item is been added at the end of external collection:\n        // external.add( 'D' )\n        // external -> [ 'A', 'D' ]\n        //\n        // We need to include skipped items and place new item after them:\n        // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n\n\n        for (const skipped of externalCollection._skippedIndexesFromExternal) {\n          if (finalIndex >= skipped) {\n            finalIndex++;\n          }\n        }\n\n        this._bindToExternalToInternalMap.set(externalItem, item);\n\n        this._bindToInternalToExternalMap.set(item, externalItem);\n\n        this.add(item, finalIndex); // After adding new element to internal collection we need update indexes\n        // of skipped items in external collection.\n\n        for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {\n          if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {\n            externalCollection._skippedIndexesFromExternal[i]++;\n          }\n        }\n      }\n    }; // Load the initial content of the collection.\n\n\n    for (const externalItem of externalCollection) {\n      addItem(null, externalItem, externalCollection.getIndex(externalItem));\n    } // Synchronize the with collection as new items are added.\n\n\n    this.listenTo(externalCollection, 'add', addItem); // Synchronize the with collection as new items are removed.\n\n    this.listenTo(externalCollection, 'remove', (evt, externalItem, index) => {\n      const item = this._bindToExternalToInternalMap.get(externalItem);\n\n      if (item) {\n        this.remove(item);\n      } // After removing element from external collection we need update/remove indexes\n      // of skipped items in internal collection.\n\n\n      this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {\n        if (index < skipped) {\n          result.push(skipped - 1);\n        }\n\n        if (index > skipped) {\n          result.push(skipped);\n        }\n\n        return result;\n      }, []);\n    });\n  }\n  /**\n   * Returns an unique id property for a given `item`.\n   *\n   * The method will generate new id and assign it to the `item` if it doesn't have any.\n   *\n   * @private\n   * @param {Object} item Item to be added.\n   * @returns {String}\n   */\n\n\n  _getItemIdBeforeAdding(item) {\n    const idProperty = this._idProperty;\n    let itemId;\n\n    if (idProperty in item) {\n      itemId = item[idProperty];\n\n      if (typeof itemId != 'string') {\n        /**\n         * This item's id should be a string.\n         *\n         * @error collection-add-invalid-id\n         */\n        throw new CKEditorError('collection-add-invalid-id', this);\n      }\n\n      if (this.get(itemId)) {\n        /**\n         * This item already exists in the collection.\n         *\n         * @error collection-add-item-already-exists\n         */\n        throw new CKEditorError('collection-add-item-already-exists', this);\n      }\n    } else {\n      item[idProperty] = itemId = uid();\n    }\n\n    return itemId;\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this._items[Symbol.iterator]();\n  }\n  /**\n   * Fired when an item is added to the collection.\n   *\n   * @event add\n   * @param {Object} item The added item.\n   */\n\n  /**\n   * Fired when an item is removed from the collection.\n   *\n   * @event remove\n   * @param {Object} item The removed item.\n   * @param {Number} index Index from which item was removed.\n   */\n\n\n}\nmix(Collection, EmitterMixin);\n/**\n * An object returned by the {@link module:utils/collection~Collection#bindTo `bindTo()`} method\n * providing functions that specify the type of the binding.\n *\n * See the {@link module:utils/collection~Collection#bindTo `bindTo()`} documentation for examples.\n *\n * @interface module:utils/collection~CollectionBindToChain\n */\n\n/**\n * Creates a callback or a property binding.\n *\n * @method #using\n * @param {Function|String} callbackOrProperty  When the function is passed, it should return\n * the collection items. When the string is provided, the property value is used to create the bound collection items.\n */\n\n/**\n * Creates the class factory binding in which items of the source collection are passed to\n * the constructor of the specified class.\n *\n * @method #as\n * @param {Function} Class The class constructor used to create instances in the factory.\n */","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-utils/src/collection.js"],"names":["EmitterMixin","CKEditorError","uid","isIterable","mix","Collection","constructor","initialItemsOrOptions","options","hasInitialItems","_items","_itemMap","Map","_idProperty","idProperty","_bindToExternalToInternalMap","WeakMap","_bindToInternalToExternalMap","_skippedIndexesFromExternal","item","push","set","_getItemIdBeforeAdding","length","first","last","add","index","itemId","undefined","splice","fire","get","idOrIndex","has","itemOrId","id","getIndex","indexOf","remove","subject","itemDoesNotExist","delete","externalItem","map","callback","ctx","find","filter","clear","_bindToCollection","stopListening","bindTo","externalCollection","as","Class","_setUpBindToBinding","using","callbackOrProperty","factory","addItem","evt","isExternalBoundToThis","externalItemBound","finalIndex","skipped","i","listenTo","reduce","result","Symbol","iterator"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/collection\n */\n\nimport EmitterMixin from './emittermixin';\nimport CKEditorError from './ckeditorerror';\nimport uid from './uid';\nimport isIterable from './isiterable';\nimport mix from './mix';\n\n/**\n * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes\n * in the collection (like in an array) or by their ids.\n *\n * If an object without an `id` property is being added to the collection, the `id` property will be generated\n * automatically. Note that the automatically generated id is unique only within this single collection instance.\n *\n * By default an item in the collection is identified by its `id` property. The name of the identifier can be\n * configured through the constructor of the collection.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Collection {\n\t/**\n\t * Creates a new Collection instance.\n\t *\n\t * You can provide an iterable of initial items the collection will be created with:\n\t *\n\t *\t\tconst collection = new Collection( [ { id: 'John' }, { id: 'Mike' } ] );\n\t *\n\t *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n\t *\t\tconsole.log( collection.get( 1 ) ); // -> { id: 'Mike' }\n\t *\t\tconsole.log( collection.get( 'Mike' ) ); // -> { id: 'Mike' }\n\t *\n\t * Or you can first create a collection and then add new items using the {@link #add} method:\n\t *\n\t *\t\tconst collection = new Collection();\n\t *\n\t *\t\tcollection.add( { id: 'John' } );\n\t *\t\tconsole.log( collection.get( 0 ) ); // -> { id: 'John' }\n\t *\n\t * Whatever option you choose, you can always pass a configuration object as the last argument\n\t * of the constructor:\n\t *\n\t *\t\tconst emptyCollection = new Collection( { idProperty: 'name' } );\n\t *\t\temptyCollection.add( { name: 'John' } );\n\t *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n\t *\n\t *\t\tconst nonEmptyCollection = new Collection( [ { name: 'John' } ], { idProperty: 'name' } );\n\t *\t\tnonEmptyCollection.add( { name: 'George' } );\n\t *\t\tconsole.log( collection.get( 'George' ) ); // -> { name: 'George' }\n\t *\t\tconsole.log( collection.get( 'John' ) ); // -> { name: 'John' }\n\t *\n\t * @param {Iterable.<Object>|Object} initialItemsOrOptions The initial items of the collection or\n\t * the options object.\n\t * @param {Object} [options={}] The options object, when the first argument is an array of initial items.\n\t * @param {String} [options.idProperty='id'] The name of the property which is used to identify an item.\n\t * Items that do not have such a property will be assigned one when added to the collection.\n\t */\n\tconstructor( initialItemsOrOptions = {}, options = {} ) {\n\t\tconst hasInitialItems = isIterable( initialItemsOrOptions );\n\n\t\tif ( !hasInitialItems ) {\n\t\t\toptions = initialItemsOrOptions;\n\t\t}\n\n\t\t/**\n\t\t * The internal list of items in the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Object[]}\n\t\t */\n\t\tthis._items = [];\n\n\t\t/**\n\t\t * The internal map of items in the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._itemMap = new Map();\n\n\t\t/**\n\t\t * The name of the property which is considered to identify an item.\n\t\t *\n\t\t * @private\n\t\t * @member {String}\n\t\t */\n\t\tthis._idProperty = options.idProperty || 'id';\n\n\t\t/**\n\t\t * A helper mapping external items of a bound collection ({@link #bindTo})\n\t\t * and actual items of this collection. It provides information\n\t\t * necessary to properly remove items bound to another collection.\n\t\t *\n\t\t * See {@link #_bindToInternalToExternalMap}.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._bindToExternalToInternalMap = new WeakMap();\n\n\t\t/**\n\t\t * A helper mapping items of this collection to external items of a bound collection\n\t\t * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.\n\t\t * to avoid loops in twoâ€“way bindings.\n\t\t *\n\t\t * See {@link #_bindToExternalToInternalMap}.\n\t\t *\n\t\t * @protected\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._bindToInternalToExternalMap = new WeakMap();\n\n\t\t/**\n\t\t * Stores indexes of skipped items from bound external collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Array}\n\t\t */\n\t\tthis._skippedIndexesFromExternal = [];\n\n\t\t// Set the initial content of the collection (if provided in the constructor).\n\t\tif ( hasInitialItems ) {\n\t\t\tfor ( const item of initialItemsOrOptions ) {\n\t\t\t\tthis._items.push( item );\n\t\t\t\tthis._itemMap.set( this._getItemIdBeforeAdding( item ), item );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * A collection instance this collection is bound to as a result\n\t\t * of calling {@link #bindTo} method.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:utils/collection~Collection} #_bindToCollection\n\t\t */\n\t}\n\n\t/**\n\t * The number of items available in the collection.\n\t *\n\t * @member {Number} #length\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * Returns the first item from the collection or null when collection is empty.\n\t *\n\t * @returns {Object|null} The first item or `null` if collection is empty.\n\t */\n\tget first() {\n\t\treturn this._items[ 0 ] || null;\n\t}\n\n\t/**\n\t * Returns the last item from the collection or null when collection is empty.\n\t *\n\t * @returns {Object|null} The last item or `null` if collection is empty.\n\t */\n\tget last() {\n\t\treturn this._items[ this.length - 1 ] || null;\n\t}\n\n\t/**\n\t * Adds an item into the collection.\n\t *\n\t * If the item does not have an id, then it will be automatically generated and set on the item.\n\t *\n\t * @chainable\n\t * @param {Object} item\n\t * @param {Number} [index] The position of the item in the collection. The item\n\t * is pushed to the collection when `index` not specified.\n\t * @fires add\n\t */\n\tadd( item, index ) {\n\t\tconst itemId = this._getItemIdBeforeAdding( item );\n\n\t\t// TODO: Use ES6 default function argument.\n\t\tif ( index === undefined ) {\n\t\t\tindex = this._items.length;\n\t\t} else if ( index > this._items.length || index < 0 ) {\n\t\t\t/**\n\t\t\t * The index number has invalid value.\n\t\t\t *\n\t\t\t * @error collection-add-item-bad-index\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-add-item-invalid-index', this );\n\t\t}\n\n\t\tthis._items.splice( index, 0, item );\n\n\t\tthis._itemMap.set( itemId, item );\n\n\t\tthis.fire( 'add', item, index );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets item by its id or index.\n\t *\n\t * @param {String|Number} idOrIndex The item id or index in the collection.\n\t * @returns {Object|null} The requested item or `null` if such item does not exist.\n\t */\n\tget( idOrIndex ) {\n\t\tlet item;\n\n\t\tif ( typeof idOrIndex == 'string' ) {\n\t\t\titem = this._itemMap.get( idOrIndex );\n\t\t} else if ( typeof idOrIndex == 'number' ) {\n\t\t\titem = this._items[ idOrIndex ];\n\t\t} else {\n\t\t\t/**\n\t\t\t * Index or id must be given.\n\t\t\t *\n\t\t\t * @error collection-get-invalid-arg\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-get-invalid-arg: Index or id must be given.', this );\n\t\t}\n\n\t\treturn item || null;\n\t}\n\n\t/**\n\t * Returns a boolean indicating whether the collection contains an item.\n\t *\n\t * @param {Object|String} itemOrId The item or its id in the collection.\n\t * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.\n\t */\n\thas( itemOrId ) {\n\t\tif ( typeof itemOrId == 'string' ) {\n\t\t\treturn this._itemMap.has( itemOrId );\n\t\t} else { // Object\n\t\t\tconst idProperty = this._idProperty;\n\t\t\tconst id = itemOrId[ idProperty ];\n\n\t\t\treturn this._itemMap.has( id );\n\t\t}\n\t}\n\n\t/**\n\t * Gets index of item in the collection.\n\t * When item is not defined in the collection then index will be equal -1.\n\t *\n\t * @param {Object|String} itemOrId The item or its id in the collection.\n\t * @returns {Number} Index of given item.\n\t */\n\tgetIndex( itemOrId ) {\n\t\tlet item;\n\n\t\tif ( typeof itemOrId == 'string' ) {\n\t\t\titem = this._itemMap.get( itemOrId );\n\t\t} else {\n\t\t\titem = itemOrId;\n\t\t}\n\n\t\treturn this._items.indexOf( item );\n\t}\n\n\t/**\n\t * Removes an item from the collection.\n\t *\n\t * @param {Object|Number|String} subject The item to remove, its id or index in the collection.\n\t * @returns {Object} The removed item.\n\t * @fires remove\n\t */\n\tremove( subject ) {\n\t\tlet index, id, item;\n\t\tlet itemDoesNotExist = false;\n\t\tconst idProperty = this._idProperty;\n\n\t\tif ( typeof subject == 'string' ) {\n\t\t\tid = subject;\n\t\t\titem = this._itemMap.get( id );\n\t\t\titemDoesNotExist = !item;\n\n\t\t\tif ( item ) {\n\t\t\t\tindex = this._items.indexOf( item );\n\t\t\t}\n\t\t} else if ( typeof subject == 'number' ) {\n\t\t\tindex = subject;\n\t\t\titem = this._items[ index ];\n\t\t\titemDoesNotExist = !item;\n\n\t\t\tif ( item ) {\n\t\t\t\tid = item[ idProperty ];\n\t\t\t}\n\t\t} else {\n\t\t\titem = subject;\n\t\t\tid = item[ idProperty ];\n\t\t\tindex = this._items.indexOf( item );\n\t\t\titemDoesNotExist = ( index == -1 || !this._itemMap.get( id ) );\n\t\t}\n\n\t\tif ( itemDoesNotExist ) {\n\t\t\t/**\n\t\t\t * Item not found.\n\t\t\t *\n\t\t\t * @error collection-remove-404\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-remove-404: Item not found.', this );\n\t\t}\n\n\t\tthis._items.splice( index, 1 );\n\t\tthis._itemMap.delete( id );\n\n\t\tconst externalItem = this._bindToInternalToExternalMap.get( item );\n\t\tthis._bindToInternalToExternalMap.delete( item );\n\t\tthis._bindToExternalToInternalMap.delete( externalItem );\n\n\t\tthis.fire( 'remove', item, index );\n\n\t\treturn item;\n\t}\n\n\t/**\n\t * Executes the callback for each item in the collection and composes an array or values returned by this callback.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Array} The result of mapping.\n\t */\n\tmap( callback, ctx ) {\n\t\treturn this._items.map( callback, ctx );\n\t}\n\n\t/**\n\t * Finds the first item in the collection for which the `callback` returns a true value.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Object} The item for which `callback` returned a true value.\n\t */\n\tfind( callback, ctx ) {\n\t\treturn this._items.find( callback, ctx );\n\t}\n\n\t/**\n\t * Returns an array with items for which the `callback` returned a true value.\n\t *\n\t * @param {Function} callback\n\t * @param {Object} callback.item\n\t * @param {Number} callback.index\n\t * @param {Object} ctx Context in which the `callback` will be called.\n\t * @returns {Object[]} The array with matching items.\n\t */\n\tfilter( callback, ctx ) {\n\t\treturn this._items.filter( callback, ctx );\n\t}\n\n\t/**\n\t * Removes all items from the collection and destroys the binding created using\n\t * {@link #bindTo}.\n\t */\n\tclear() {\n\t\tif ( this._bindToCollection ) {\n\t\t\tthis.stopListening( this._bindToCollection );\n\t\t\tthis._bindToCollection = null;\n\t\t}\n\n\t\twhile ( this.length ) {\n\t\t\tthis.remove( 0 );\n\t\t}\n\t}\n\n\t/**\n\t * Binds and synchronizes the collection with another one.\n\t *\n\t * The binding can be a simple factory:\n\t *\n\t *\t\tclass FactoryClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).as( FactoryClass );\n\t *\n\t *\t\tsource.add( { label: 'foo' } );\n\t *\t\tsource.add( { label: 'bar' } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 1 ).label ); // 'bar'\n\t *\n\t *\t\tsource.remove( 0 );\n\t *\t\tconsole.log( target.length ); // 1\n\t *\t\tconsole.log( target.get( 0 ).label ); // 'bar'\n\t *\n\t * or the factory driven by a custom callback:\n\t *\n\t *\t\tclass FooClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tclass BarClass {\n\t *\t\t\tconstructor( data ) {\n\t *\t\t\t\tthis.label = data.label;\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( ( item ) => {\n\t *\t\t\tif ( item.label == 'foo' ) {\n\t *\t\t\t\treturn new FooClass( item );\n\t *\t\t\t} else {\n\t *\t\t\t\treturn new BarClass( item );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\tsource.add( { label: 'foo' } );\n\t *\t\tsource.add( { label: 'bar' } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 0 ) instanceof FooClass ); // true\n\t *\t\tconsole.log( target.get( 1 ) instanceof BarClass ); // true\n\t *\n\t * or the factory out of property name:\n\t *\n\t *\t\tconst source = new Collection( { idProperty: 'label' } );\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( 'label' );\n\t *\n\t *\t\tsource.add( { label: { value: 'foo' } } );\n\t *\t\tsource.add( { label: { value: 'bar' } } );\n\t *\n\t *\t\tconsole.log( target.length ); // 2\n\t *\t\tconsole.log( target.get( 0 ).value ); // 'foo'\n\t *\t\tconsole.log( target.get( 1 ).value ); // 'bar'\n\t *\n\t * It's possible to skip specified items by returning falsy value:\n\t *\n\t *\t\tconst source = new Collection();\n\t *\t\tconst target = new Collection();\n\t *\n\t *\t\ttarget.bindTo( source ).using( item => {\n\t *\t\t\tif ( item.hidden ) {\n\t *\t\t\t\treturn null;\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn item;\n\t *\t\t} );\n\t *\n\t *\t\tsource.add( { hidden: true } );\n\t *\t\tsource.add( { hidden: false } );\n\t *\n\t *\t\tconsole.log( source.length ); // 2\n\t *\t\tconsole.log( target.length ); // 1\n\t *\n\t * **Note**: {@link #clear} can be used to break the binding.\n\t *\n\t * @param {module:utils/collection~Collection} externalCollection A collection to be bound.\n\t * @returns {Object}\n\t * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.\n\t */\n\tbindTo( externalCollection ) {\n\t\tif ( this._bindToCollection ) {\n\t\t\t/**\n\t\t\t * The collection cannot be bound more than once.\n\t\t\t *\n\t\t\t * @error collection-bind-to-rebind\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'collection-bind-to-rebind: The collection cannot be bound more than once.', this );\n\t\t}\n\n\t\tthis._bindToCollection = externalCollection;\n\n\t\treturn {\n\t\t\tas: Class => {\n\t\t\t\tthis._setUpBindToBinding( item => new Class( item ) );\n\t\t\t},\n\n\t\t\tusing: callbackOrProperty => {\n\t\t\t\tif ( typeof callbackOrProperty == 'function' ) {\n\t\t\t\t\tthis._setUpBindToBinding( item => callbackOrProperty( item ) );\n\t\t\t\t} else {\n\t\t\t\t\tthis._setUpBindToBinding( item => item[ callbackOrProperty ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Finalizes and activates a binding initiated by {#bindTo}.\n\t *\n\t * @protected\n\t * @param {Function} factory A function which produces collection items.\n\t */\n\t_setUpBindToBinding( factory ) {\n\t\tconst externalCollection = this._bindToCollection;\n\n\t\t// Adds the item to the collection once a change has been done to the external collection.\n\t\t//\n\t\t// @private\n\t\tconst addItem = ( evt, externalItem, index ) => {\n\t\t\tconst isExternalBoundToThis = externalCollection._bindToCollection == this;\n\t\t\tconst externalItemBound = externalCollection._bindToInternalToExternalMap.get( externalItem );\n\n\t\t\t// If an external collection is bound to this collection, which makes it a 2â€“way binding,\n\t\t\t// and the particular external collection item is already bound, don't add it here.\n\t\t\t// The external item has been created **out of this collection's item** and (re)adding it will\n\t\t\t// cause a loop.\n\t\t\tif ( isExternalBoundToThis && externalItemBound ) {\n\t\t\t\tthis._bindToExternalToInternalMap.set( externalItem, externalItemBound );\n\t\t\t\tthis._bindToInternalToExternalMap.set( externalItemBound, externalItem );\n\t\t\t} else {\n\t\t\t\tconst item = factory( externalItem );\n\n\t\t\t\t// When there is no item we need to remember skipped index first and then we can skip this item.\n\t\t\t\tif ( !item ) {\n\t\t\t\t\tthis._skippedIndexesFromExternal.push( index );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Lets try to put item at the same index as index in external collection\n\t\t\t\t// but when there are a skipped items in one or both collections we need to recalculate this index.\n\t\t\t\tlet finalIndex = index;\n\n\t\t\t\t// When we try to insert item after some skipped items from external collection we need\n\t\t\t\t// to include this skipped items and decrease index.\n\t\t\t\t//\n\t\t\t\t// For the following example:\n\t\t\t\t// external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]\n\t\t\t\t// internal -> [ A ]\n\t\t\t\t//\n\t\t\t\t// Another item is been added at the end of external collection:\n\t\t\t\t// external.add( 'D' )\n\t\t\t\t// external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]\n\t\t\t\t//\n\t\t\t\t// We can't just add 'D' to internal at the same index as index in external because\n\t\t\t\t// this will produce empty indexes what is invalid:\n\t\t\t\t// internal -> [ 'A', empty, empty, 'D' ]\n\t\t\t\t//\n\t\t\t\t// So we need to include skipped items and decrease index\n\t\t\t\t// internal -> [ 'A', 'D' ]\n\t\t\t\tfor ( const skipped of this._skippedIndexesFromExternal ) {\n\t\t\t\t\tif ( index > skipped ) {\n\t\t\t\t\t\tfinalIndex--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration that external collection could skip some items from\n\t\t\t\t// internal collection.\n\t\t\t\t//\n\t\t\t\t// For the following example:\n\t\t\t\t// internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]\n\t\t\t\t// external -> [ A ]\n\t\t\t\t//\n\t\t\t\t// Another item is been added at the end of external collection:\n\t\t\t\t// external.add( 'D' )\n\t\t\t\t// external -> [ 'A', 'D' ]\n\t\t\t\t//\n\t\t\t\t// We need to include skipped items and place new item after them:\n\t\t\t\t// internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]\n\t\t\t\tfor ( const skipped of externalCollection._skippedIndexesFromExternal ) {\n\t\t\t\t\tif ( finalIndex >= skipped ) {\n\t\t\t\t\t\tfinalIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._bindToExternalToInternalMap.set( externalItem, item );\n\t\t\t\tthis._bindToInternalToExternalMap.set( item, externalItem );\n\t\t\t\tthis.add( item, finalIndex );\n\n\t\t\t\t// After adding new element to internal collection we need update indexes\n\t\t\t\t// of skipped items in external collection.\n\t\t\t\tfor ( let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++ ) {\n\t\t\t\t\tif ( finalIndex <= externalCollection._skippedIndexesFromExternal[ i ] ) {\n\t\t\t\t\t\texternalCollection._skippedIndexesFromExternal[ i ]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Load the initial content of the collection.\n\t\tfor ( const externalItem of externalCollection ) {\n\t\t\taddItem( null, externalItem, externalCollection.getIndex( externalItem ) );\n\t\t}\n\n\t\t// Synchronize the with collection as new items are added.\n\t\tthis.listenTo( externalCollection, 'add', addItem );\n\n\t\t// Synchronize the with collection as new items are removed.\n\t\tthis.listenTo( externalCollection, 'remove', ( evt, externalItem, index ) => {\n\t\t\tconst item = this._bindToExternalToInternalMap.get( externalItem );\n\n\t\t\tif ( item ) {\n\t\t\t\tthis.remove( item );\n\t\t\t}\n\n\t\t\t// After removing element from external collection we need update/remove indexes\n\t\t\t// of skipped items in internal collection.\n\t\t\tthis._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce( ( result, skipped ) => {\n\t\t\t\tif ( index < skipped ) {\n\t\t\t\t\tresult.push( skipped - 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( index > skipped ) {\n\t\t\t\t\tresult.push( skipped );\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [] );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns an unique id property for a given `item`.\n\t *\n\t * The method will generate new id and assign it to the `item` if it doesn't have any.\n\t *\n\t * @private\n\t * @param {Object} item Item to be added.\n\t * @returns {String}\n\t */\n\t_getItemIdBeforeAdding( item ) {\n\t\tconst idProperty = this._idProperty;\n\t\tlet itemId;\n\n\t\tif ( ( idProperty in item ) ) {\n\t\t\titemId = item[ idProperty ];\n\n\t\t\tif ( typeof itemId != 'string' ) {\n\t\t\t\t/**\n\t\t\t\t * This item's id should be a string.\n\t\t\t\t *\n\t\t\t\t * @error collection-add-invalid-id\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'collection-add-invalid-id', this );\n\t\t\t}\n\n\t\t\tif ( this.get( itemId ) ) {\n\t\t\t\t/**\n\t\t\t\t * This item already exists in the collection.\n\t\t\t\t *\n\t\t\t\t * @error collection-add-item-already-exists\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'collection-add-item-already-exists', this );\n\t\t\t}\n\t\t} else {\n\t\t\titem[ idProperty ] = itemId = uid();\n\t\t}\n\n\t\treturn itemId;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Fired when an item is added to the collection.\n\t *\n\t * @event add\n\t * @param {Object} item The added item.\n\t */\n\n\t/**\n\t * Fired when an item is removed from the collection.\n\t *\n\t * @event remove\n\t * @param {Object} item The removed item.\n\t * @param {Number} index Index from which item was removed.\n\t */\n}\n\nmix( Collection, EmitterMixin );\n\n/**\n * An object returned by the {@link module:utils/collection~Collection#bindTo `bindTo()`} method\n * providing functions that specify the type of the binding.\n *\n * See the {@link module:utils/collection~Collection#bindTo `bindTo()`} documentation for examples.\n *\n * @interface module:utils/collection~CollectionBindToChain\n */\n\n/**\n * Creates a callback or a property binding.\n *\n * @method #using\n * @param {Function|String} callbackOrProperty  When the function is passed, it should return\n * the collection items. When the string is provided, the property value is used to create the bound collection items.\n */\n\n/**\n * Creates the class factory binding in which items of the source collection are passed to\n * the constructor of the specified class.\n *\n * @method #as\n * @param {Function} Class The class constructor used to create instances in the factory.\n */\n"]},"metadata":{},"sourceType":"module"}