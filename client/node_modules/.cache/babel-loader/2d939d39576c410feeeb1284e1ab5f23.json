{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/history\n */\n\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\nexport default class History {\n  /**\n   * Creates an empty History instance.\n   */\n  constructor() {\n    /**\n     * Operations added to the history.\n     *\n     * @protected\n     * @member {Array.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_operations\n     */\n    this._operations = [];\n    /**\n     * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n     * {@link module:engine/model/operation/operation~Operation operation}.\n     *\n     * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n     * value is an operation that has been undone by the \"undoing operation\".\n     *\n     * @private\n     * @member {Map} module:engine/model/history~History#_undoPairs\n     */\n\n    this._undoPairs = new Map();\n    /**\n     * Holds all undone operations.\n     *\n     * @private\n     * @member {Set.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_undoneOperations\n     */\n\n    this._undoneOperations = new Set();\n  }\n  /**\n   * Adds an operation to the history.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n   */\n\n\n  addOperation(operation) {\n    if (this._operations.includes(operation)) {\n      return;\n    }\n\n    this._operations.push(operation);\n  }\n  /**\n   * Returns operations added to the history.\n   *\n   * @param {Number} [from=0] Base version from which operations should be returned (inclusive). Defaults to `0`, which means\n   * that operations from the first one will be returned.\n   * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which operations should be returned (exclusive).\n   * Defaults to `Number.POSITIVE_INFINITY` which means that operations up to the last one will be returned.\n   * @returns {Iterable.<module:engine/model/operation/operation~Operation>} Operations added to the history.\n   */\n\n\n  getOperations(from = 0, to = Number.POSITIVE_INFINITY) {\n    if (from < 0) {\n      return [];\n    }\n\n    return this._operations.slice(from, to);\n  }\n  /**\n   * Returns operation from the history that bases on given `baseVersion`.\n   *\n   * @param {Number} baseVersion Base version of the operation to get.\n   * @returns {module:engine/model/operation/operation~Operation|null} Operation with given base version or `null` if\n   * there is no such operation in history.\n   */\n\n\n  getOperation(baseVersion) {\n    return this._operations[baseVersion];\n  }\n  /**\n   * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n   * history is keeping more context information about operations, which helps in operational transformation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n   * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n   */\n\n\n  setOperationAsUndone(undoneOperation, undoingOperation) {\n    this._undoPairs.set(undoingOperation, undoneOperation);\n\n    this._undoneOperations.add(undoneOperation);\n  }\n  /**\n   * Checks whether given `operation` is undoing any other operation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n   * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n   */\n\n\n  isUndoingOperation(operation) {\n    return this._undoPairs.has(operation);\n  }\n  /**\n   * Checks whether given `operation` has been undone by any other operation.\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n   * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n   */\n\n\n  isUndoneOperation(operation) {\n    return this._undoneOperations.has(operation);\n  }\n  /**\n   * For given `undoingOperation`, returns the operation which has been undone by it.\n   *\n   * @param {module:engine/model/operation/operation~Operation} undoingOperation\n   * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n   * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n   */\n\n\n  getUndoneOperation(undoingOperation) {\n    return this._undoPairs.get(undoingOperation);\n  }\n\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/model/history.js"],"names":["History","constructor","_operations","_undoPairs","Map","_undoneOperations","Set","addOperation","operation","includes","push","getOperations","from","to","Number","POSITIVE_INFINITY","slice","getOperation","baseVersion","setOperationAsUndone","undoneOperation","undoingOperation","set","add","isUndoingOperation","has","isUndoneOperation","getUndoneOperation","get"],"mappings":"AAAA;;;;;AAKA;;;;AAIA;;;AAGA,eAAe,MAAMA,OAAN,CAAc;AAC5B;;;AAGAC,EAAAA,WAAW,GAAG;AACb;;;;;;AAMA,SAAKC,WAAL,GAAmB,EAAnB;AAEA;;;;;;;;;;;AAUA,SAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AAEA;;;;;;;AAMA,SAAKC,iBAAL,GAAyB,IAAIC,GAAJ,EAAzB;AACA;AAED;;;;;;;AAKAC,EAAAA,YAAY,CAAEC,SAAF,EAAc;AACzB,QAAK,KAAKN,WAAL,CAAiBO,QAAjB,CAA2BD,SAA3B,CAAL,EAA8C;AAC7C;AACA;;AAED,SAAKN,WAAL,CAAiBQ,IAAjB,CAAuBF,SAAvB;AACA;AAED;;;;;;;;;;;AASAG,EAAAA,aAAa,CAAEC,IAAI,GAAG,CAAT,EAAYC,EAAE,GAAGC,MAAM,CAACC,iBAAxB,EAA4C;AACxD,QAAKH,IAAI,GAAG,CAAZ,EAAgB;AACf,aAAO,EAAP;AACA;;AAED,WAAO,KAAKV,WAAL,CAAiBc,KAAjB,CAAwBJ,IAAxB,EAA8BC,EAA9B,CAAP;AACA;AAED;;;;;;;;;AAOAI,EAAAA,YAAY,CAAEC,WAAF,EAAgB;AAC3B,WAAO,KAAKhB,WAAL,CAAkBgB,WAAlB,CAAP;AACA;AAED;;;;;;;;;AAOAC,EAAAA,oBAAoB,CAAEC,eAAF,EAAmBC,gBAAnB,EAAsC;AACzD,SAAKlB,UAAL,CAAgBmB,GAAhB,CAAqBD,gBAArB,EAAuCD,eAAvC;;AACA,SAAKf,iBAAL,CAAuBkB,GAAvB,CAA4BH,eAA5B;AACA;AAED;;;;;;;;AAMAI,EAAAA,kBAAkB,CAAEhB,SAAF,EAAc;AAC/B,WAAO,KAAKL,UAAL,CAAgBsB,GAAhB,CAAqBjB,SAArB,CAAP;AACA;AAED;;;;;;;;AAMAkB,EAAAA,iBAAiB,CAAElB,SAAF,EAAc;AAC9B,WAAO,KAAKH,iBAAL,CAAuBoB,GAAvB,CAA4BjB,SAA5B,CAAP;AACA;AAED;;;;;;;;;AAOAmB,EAAAA,kBAAkB,CAAEN,gBAAF,EAAqB;AACtC,WAAO,KAAKlB,UAAL,CAAgByB,GAAhB,CAAqBP,gBAArB,CAAP;AACA;;AApH2B","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/history\n */\n\n/**\n * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.\n */\nexport default class History {\n\t/**\n\t * Creates an empty History instance.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Operations added to the history.\n\t\t *\n\t\t * @protected\n\t\t * @member {Array.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_operations\n\t\t */\n\t\tthis._operations = [];\n\n\t\t/**\n\t\t * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which\n\t\t * {@link module:engine/model/operation/operation~Operation operation}.\n\t\t *\n\t\t * Keys of the map are \"undoing operations\", that is operations that undone some other operations. For each key, the\n\t\t * value is an operation that has been undone by the \"undoing operation\".\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/history~History#_undoPairs\n\t\t */\n\t\tthis._undoPairs = new Map();\n\n\t\t/**\n\t\t * Holds all undone operations.\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_undoneOperations\n\t\t */\n\t\tthis._undoneOperations = new Set();\n\t}\n\n\t/**\n\t * Adds an operation to the history.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to add.\n\t */\n\taddOperation( operation ) {\n\t\tif ( this._operations.includes( operation ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._operations.push( operation );\n\t}\n\n\t/**\n\t * Returns operations added to the history.\n\t *\n\t * @param {Number} [from=0] Base version from which operations should be returned (inclusive). Defaults to `0`, which means\n\t * that operations from the first one will be returned.\n\t * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which operations should be returned (exclusive).\n\t * Defaults to `Number.POSITIVE_INFINITY` which means that operations up to the last one will be returned.\n\t * @returns {Iterable.<module:engine/model/operation/operation~Operation>} Operations added to the history.\n\t */\n\tgetOperations( from = 0, to = Number.POSITIVE_INFINITY ) {\n\t\tif ( from < 0 ) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn this._operations.slice( from, to );\n\t}\n\n\t/**\n\t * Returns operation from the history that bases on given `baseVersion`.\n\t *\n\t * @param {Number} baseVersion Base version of the operation to get.\n\t * @returns {module:engine/model/operation/operation~Operation|null} Operation with given base version or `null` if\n\t * there is no such operation in history.\n\t */\n\tgetOperation( baseVersion ) {\n\t\treturn this._operations[ baseVersion ];\n\t}\n\n\t/**\n\t * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,\n\t * history is keeping more context information about operations, which helps in operational transformation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.\n\t * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.\n\t */\n\tsetOperationAsUndone( undoneOperation, undoingOperation ) {\n\t\tthis._undoPairs.set( undoingOperation, undoneOperation );\n\t\tthis._undoneOperations.add( undoneOperation );\n\t}\n\n\t/**\n\t * Checks whether given `operation` is undoing any other operation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n\t * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.\n\t */\n\tisUndoingOperation( operation ) {\n\t\treturn this._undoPairs.has( operation );\n\t}\n\n\t/**\n\t * Checks whether given `operation` has been undone by any other operation.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to check.\n\t * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.\n\t */\n\tisUndoneOperation( operation ) {\n\t\treturn this._undoneOperations.has( operation );\n\t}\n\n\t/**\n\t * For given `undoingOperation`, returns the operation which has been undone by it.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} undoingOperation\n\t * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given\n\t * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.\n\t */\n\tgetUndoneOperation( undoingOperation ) {\n\t\treturn this._undoPairs.get( undoingOperation );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}