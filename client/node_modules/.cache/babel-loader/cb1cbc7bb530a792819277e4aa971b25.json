{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/deletecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\nimport ChangeBuffer from './utils/changebuffer';\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n *\n * @extends module:core/command~Command\n */\n\nexport default class DeleteCommand extends Command {\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it\n   * should consume the content when the selection is collapsed.\n   */\n  constructor(editor, direction) {\n    super(editor);\n    /**\n     * The directionality of the delete describing in what direction it should\n     * consume the content when the selection is collapsed.\n     *\n     * @readonly\n     * @member {'forward'|'backward'} #direction\n     */\n\n    this.direction = direction;\n    /**\n     * Delete's change buffer used to group subsequent changes into batches.\n     *\n     * @readonly\n     * @private\n     * @member {typing.ChangeBuffer} #buffer\n     */\n\n    this._buffer = new ChangeBuffer(editor.model, editor.config.get('typing.undoStep'));\n  }\n  /**\n   * The current change buffer.\n   *\n   * @type {module:typing/utils/changebuffer~ChangeBuffer}\n   */\n\n\n  get buffer() {\n    return this._buffer;\n  }\n  /**\n   * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n   * or a piece of content in the {@link #direction defined direction}.\n   *\n   * @fires execute\n   * @param {Object} [options] The command options.\n   * @param {'character'} [options.unit='character'] See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n   * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.\n   * See the {@link module:engine/view/document~Document#event:delete} event data.\n   * @param {module:engine/model/selection~Selection} [options.selection] Selection to remove. If not set, current model selection\n   * will be used.\n   */\n\n\n  execute(options = {}) {\n    const model = this.editor.model;\n    const doc = model.document;\n    model.enqueueChange(this._buffer.batch, writer => {\n      this._buffer.lock();\n\n      const selection = writer.createSelection(options.selection || doc.selection); // Do not replace the whole selected content if selection was collapsed.\n      // This prevents such situation:\n      //\n      // <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n      // starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n\n      const doNotResetEntireContent = selection.isCollapsed; // Try to extend the selection in the specified direction.\n\n      if (selection.isCollapsed) {\n        model.modifySelection(selection, {\n          direction: this.direction,\n          unit: options.unit\n        });\n      } // Check if deleting in an empty editor. See #61.\n\n\n      if (this._shouldEntireContentBeReplacedWithParagraph(options.sequence || 1)) {\n        this._replaceEntireContentWithParagraph(writer);\n\n        return;\n      } // If selection is still collapsed, then there's nothing to delete.\n\n\n      if (selection.isCollapsed) {\n        return;\n      }\n\n      let changeCount = 0;\n      selection.getFirstRange().getMinimalFlatRanges().forEach(range => {\n        changeCount += count(range.getWalker({\n          singleCharacters: true,\n          ignoreElementEnd: true,\n          shallow: true\n        }));\n      });\n      model.deleteContent(selection, {\n        doNotResetEntireContent,\n        direction: this.direction\n      });\n\n      this._buffer.input(changeCount);\n\n      writer.setSelection(selection);\n\n      this._buffer.unlock();\n    });\n  }\n  /**\n   * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n   * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n   * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n   *\n   * But, if the user pressed the key in an empty editable for the first time,\n   * we want to replace the entire content with a paragraph if:\n   *\n   * * the current limit element is empty,\n   * * the paragraph is allowed in the limit element,\n   * * the limit doesn't already have a paragraph inside.\n   *\n   * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n   *\n   * @private\n   * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n   * @returns {Boolean}\n   */\n\n\n  _shouldEntireContentBeReplacedWithParagraph(sequence) {\n    // Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n    if (sequence > 1) {\n      return false;\n    }\n\n    const model = this.editor.model;\n    const doc = model.document;\n    const selection = doc.selection;\n    const limitElement = model.schema.getLimitElement(selection); // If a collapsed selection contains the whole content it means that the content is empty\n    // (from the user perspective).\n\n    const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);\n\n    if (!limitElementIsEmpty) {\n      return false;\n    }\n\n    if (!model.schema.checkChild(limitElement, 'paragraph')) {\n      return false;\n    }\n\n    const limitElementFirstChild = limitElement.getChild(0); // Does nothing if the limit element already contains only a paragraph.\n    // We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n    // because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n\n    if (limitElementFirstChild && limitElementFirstChild.name === 'paragraph') {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n   *\n   * @private\n   */\n\n\n  _replaceEntireContentWithParagraph(writer) {\n    const model = this.editor.model;\n    const doc = model.document;\n    const selection = doc.selection;\n    const limitElement = model.schema.getLimitElement(selection);\n    const paragraph = writer.createElement('paragraph');\n    writer.remove(writer.createRangeIn(limitElement));\n    writer.insert(paragraph, limitElement);\n    writer.setSelection(paragraph, 0);\n  }\n\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-typing/src/deletecommand.js"],"names":["Command","count","ChangeBuffer","DeleteCommand","constructor","editor","direction","_buffer","model","config","get","buffer","execute","options","doc","document","enqueueChange","batch","writer","lock","selection","createSelection","doNotResetEntireContent","isCollapsed","modifySelection","unit","_shouldEntireContentBeReplacedWithParagraph","sequence","_replaceEntireContentWithParagraph","changeCount","getFirstRange","getMinimalFlatRanges","forEach","range","getWalker","singleCharacters","ignoreElementEnd","shallow","deleteContent","input","setSelection","unlock","limitElement","schema","getLimitElement","limitElementIsEmpty","containsEntireContent","checkChild","limitElementFirstChild","getChild","name","paragraph","createElement","remove","createRangeIn","insert"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/deletecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport count from '@ckeditor/ckeditor5-utils/src/count';\n\nimport ChangeBuffer from './utils/changebuffer';\n\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n *\n * @extends module:core/command~Command\n */\nexport default class DeleteCommand extends Command {\n\t/**\n\t * Creates an instance of the command.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it\n\t * should consume the content when the selection is collapsed.\n\t */\n\tconstructor( editor, direction ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The directionality of the delete describing in what direction it should\n\t\t * consume the content when the selection is collapsed.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'forward'|'backward'} #direction\n\t\t */\n\t\tthis.direction = direction;\n\n\t\t/**\n\t\t * Delete's change buffer used to group subsequent changes into batches.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {typing.ChangeBuffer} #buffer\n\t\t */\n\t\tthis._buffer = new ChangeBuffer( editor.model, editor.config.get( 'typing.undoStep' ) );\n\t}\n\n\t/**\n\t * The current change buffer.\n\t *\n\t * @type {module:typing/utils/changebuffer~ChangeBuffer}\n\t */\n\tget buffer() {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n\t * or a piece of content in the {@link #direction defined direction}.\n\t *\n\t * @fires execute\n\t * @param {Object} [options] The command options.\n\t * @param {'character'} [options.unit='character'] See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n\t * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.\n\t * See the {@link module:engine/view/document~Document#event:delete} event data.\n\t * @param {module:engine/model/selection~Selection} [options.selection] Selection to remove. If not set, current model selection\n\t * will be used.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\n\t\tmodel.enqueueChange( this._buffer.batch, writer => {\n\t\t\tthis._buffer.lock();\n\n\t\t\tconst selection = writer.createSelection( options.selection || doc.selection );\n\n\t\t\t// Do not replace the whole selected content if selection was collapsed.\n\t\t\t// This prevents such situation:\n\t\t\t//\n\t\t\t// <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n\t\t\t// starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n\t\t\tconst doNotResetEntireContent = selection.isCollapsed;\n\n\t\t\t// Try to extend the selection in the specified direction.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\tmodel.modifySelection( selection, { direction: this.direction, unit: options.unit } );\n\t\t\t}\n\n\t\t\t// Check if deleting in an empty editor. See #61.\n\t\t\tif ( this._shouldEntireContentBeReplacedWithParagraph( options.sequence || 1 ) ) {\n\t\t\t\tthis._replaceEntireContentWithParagraph( writer );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If selection is still collapsed, then there's nothing to delete.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet changeCount = 0;\n\n\t\t\tselection.getFirstRange().getMinimalFlatRanges().forEach( range => {\n\t\t\t\tchangeCount += count(\n\t\t\t\t\trange.getWalker( { singleCharacters: true, ignoreElementEnd: true, shallow: true } )\n\t\t\t\t);\n\t\t\t} );\n\n\t\t\tmodel.deleteContent( selection, {\n\t\t\t\tdoNotResetEntireContent,\n\t\t\t\tdirection: this.direction\n\t\t\t} );\n\n\t\t\tthis._buffer.input( changeCount );\n\n\t\t\twriter.setSelection( selection );\n\n\t\t\tthis._buffer.unlock();\n\t\t} );\n\t}\n\n\t/**\n\t * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n\t * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n\t * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n\t *\n\t * But, if the user pressed the key in an empty editable for the first time,\n\t * we want to replace the entire content with a paragraph if:\n\t *\n\t * * the current limit element is empty,\n\t * * the paragraph is allowed in the limit element,\n\t * * the limit doesn't already have a paragraph inside.\n\t *\n\t * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n\t *\n\t * @private\n\t * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.\n\t * @returns {Boolean}\n\t */\n\t_shouldEntireContentBeReplacedWithParagraph( sequence ) {\n\t\t// Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n\t\tif ( sequence > 1 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst limitElement = model.schema.getLimitElement( selection );\n\n\t\t// If a collapsed selection contains the whole content it means that the content is empty\n\t\t// (from the user perspective).\n\t\tconst limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent( limitElement );\n\n\t\tif ( !limitElementIsEmpty ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !model.schema.checkChild( limitElement, 'paragraph' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst limitElementFirstChild = limitElement.getChild( 0 );\n\n\t\t// Does nothing if the limit element already contains only a paragraph.\n\t\t// We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n\t\t// because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n\t\tif ( limitElementFirstChild && limitElementFirstChild.name === 'paragraph' ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n\t *\n\t * @private\n\t */\n\t_replaceEntireContentWithParagraph( writer ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\t\tconst limitElement = model.schema.getLimitElement( selection );\n\t\tconst paragraph = writer.createElement( 'paragraph' );\n\n\t\twriter.remove( writer.createRangeIn( limitElement ) );\n\t\twriter.insert( paragraph, limitElement );\n\n\t\twriter.setSelection( paragraph, 0 );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}