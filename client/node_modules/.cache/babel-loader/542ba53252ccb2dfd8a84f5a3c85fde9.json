{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\nimport Position from '../position';\nimport LivePosition from '../liveposition';\nimport Element from '../element';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste\n * functionality to work.\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\n\nexport default function insertContent(model, content, selectable, placeOrOffset) {\n  return model.change(writer => {\n    let selection;\n\n    if (!selectable) {\n      selection = model.document.selection;\n    } else if (selectable instanceof Selection || selectable instanceof DocumentSelection) {\n      selection = selectable;\n    } else {\n      selection = writer.createSelection(selectable, placeOrOffset);\n    }\n\n    if (!selection.isCollapsed) {\n      model.deleteContent(selection, {\n        doNotAutoparagraph: true\n      });\n    }\n\n    const insertion = new Insertion(model, writer, selection.anchor);\n    let nodesToInsert;\n\n    if (content.is('documentFragment')) {\n      nodesToInsert = content.getChildren();\n    } else {\n      nodesToInsert = [content];\n    }\n\n    insertion.handleNodes(nodesToInsert, {\n      // The set of children being inserted is the only set in this context\n      // so it's the first and last (it's a hack ;)).\n      isFirst: true,\n      isLast: true\n    });\n    const newRange = insertion.getSelectionRange();\n    /* istanbul ignore else */\n\n    if (newRange) {\n      if (selection instanceof DocumentSelection) {\n        writer.setSelection(newRange);\n      } else {\n        selection.setTo(newRange);\n      }\n    } else {// We are not testing else because it's a safe check for unpredictable edge cases:\n      // an insertion without proper range to select.\n      //\n      // @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n    }\n\n    const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);\n    insertion.destroy();\n    return affectedRange;\n  });\n}\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\n\nclass Insertion {\n  constructor(model, writer, position) {\n    /**\n     * The model in context of which the insertion should be performed.\n     *\n     * @member {module:engine/model~Model} #model\n     */\n    this.model = model;\n    /**\n     * Batch to which operations will be added.\n     *\n     * @member {module:engine/controller/writer~Batch} #writer\n     */\n\n    this.writer = writer;\n    /**\n     * The position at which (or near which) the next node will be inserted.\n     *\n     * @member {module:engine/model/position~Position} #position\n     */\n\n    this.position = position;\n    /**\n     * Elements with which the inserted elements can be merged.\n     *\n     *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n     *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n     *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n     *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n     *\n     *\n     * @member {Set} #canMergeWith\n     */\n\n    this.canMergeWith = new Set([this.position.parent]);\n    /**\n     * Schema of the model.\n     *\n     * @member {module:engine/model/schema~Schema} #schema\n     */\n\n    this.schema = model.schema;\n    this._filterAttributesOf = [];\n    /**\n     * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n     */\n\n    this._affectedStart = null;\n    /**\n     * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n     *\n     * @private\n     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n     */\n\n    this._affectedEnd = null;\n  }\n  /**\n   * Handles insertion of a set of nodes.\n   *\n   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n   * @param {Object} parentContext Context in which parent of these nodes was supposed to be inserted.\n   * If the parent context is passed it means that the parent element was stripped (was not allowed).\n   */\n\n\n  handleNodes(nodes, parentContext) {\n    nodes = Array.from(nodes);\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      this._handleNode(node, {\n        isFirst: i === 0 && parentContext.isFirst,\n        isLast: i === nodes.length - 1 && parentContext.isLast\n      });\n    } // TMP this will become a post-fixer.\n\n\n    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);\n    this._filterAttributesOf = [];\n  }\n  /**\n   * Returns range to be selected after insertion.\n   * Returns `null` if there is no valid range to select after insertion.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getSelectionRange() {\n    if (this.nodeToSelect) {\n      return Range._createOn(this.nodeToSelect);\n    }\n\n    return this.model.schema.getNearestSelectionRange(this.position);\n  }\n  /**\n   * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n   * before the insertion. Returns `null` if no changes were done.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getAffectedRange() {\n    if (!this._affectedStart) {\n      return null;\n    }\n\n    return new Range(this._affectedStart, this._affectedEnd);\n  }\n  /**\n   * Destroys `Insertion` instance.\n   */\n\n\n  destroy() {\n    if (this._affectedStart) {\n      this._affectedStart.detach();\n    }\n\n    if (this._affectedEnd) {\n      this._affectedEnd.detach();\n    }\n  }\n  /**\n   * Handles insertion of a single node.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node\n   * @param {Object} context\n   * @param {Boolean} context.isFirst Whether the given node is the first one in the content to be inserted.\n   * @param {Boolean} context.isLast Whether the given node is the last one in the content to be inserted.\n   */\n\n\n  _handleNode(node, context) {\n    // Let's handle object in a special way.\n    // * They should never be merged with other elements.\n    // * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n    if (this.schema.isObject(node)) {\n      this._handleObject(node, context);\n\n      return;\n    } // Try to find a place for the given node.\n    // Split the position.parent's branch up to a point where the node can be inserted.\n    // If it isn't allowed in the whole branch, then of course don't split anything.\n\n\n    const isAllowed = this._checkAndSplitToAllowedPosition(node, context);\n\n    if (!isAllowed) {\n      this._handleDisallowedNode(node, context);\n\n      return;\n    }\n\n    this._insert(node); // After the node was inserted we may try to merge it with its siblings.\n    // This should happen only if it was the first and/or last of the nodes (so only with boundary nodes)\n    // and only if the selection was in those elements initially.\n    //\n    // E.g.:\n    // <p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n    // and:\n    // <p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n    // but:\n    // <p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging)\n    // <p>x</p>[<img>]<p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging, note: after running deleteContents\n    //\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t it's exactly the same case as above)\n\n\n    this._mergeSiblingsOf(node, context);\n  }\n  /**\n   * @private\n   * @param {module:engine/model/element~Element} node The object element.\n   * @param {Object} context\n   */\n\n\n  _handleObject(node, context) {\n    // Try finding it a place in the tree.\n    if (this._checkAndSplitToAllowedPosition(node)) {\n      this._insert(node);\n    } // Try autoparagraphing.\n    else {\n        this._tryAutoparagraphing(node, context);\n      }\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n   * @param {Object} context\n   */\n\n\n  _handleDisallowedNode(node, context) {\n    // If the node is an element, try inserting its children (strip the parent).\n    if (node.is('element')) {\n      this.handleNodes(node.getChildren(), context);\n    } // If text is not allowed, try autoparagraphing it.\n    else {\n        this._tryAutoparagraphing(node, context);\n      }\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node The node to insert.\n   */\n\n\n  _insert(node) {\n    /* istanbul ignore if */\n    if (!this.schema.checkChild(this.position, node)) {\n      // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n      // Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n\n      /**\n       * Given node cannot be inserted on the given position.\n       *\n       * @error insertcontent-wrong-position\n       * @param {module:engine/model/node~Node} node Node to insert.\n       * @param {module:engine/model/position~Position} position Position to insert the node at.\n       */\n      throw new CKEditorError('insertcontent-wrong-position: Given node cannot be inserted on the given position.', this, {\n        node,\n        position: this.position\n      });\n    }\n\n    const livePos = LivePosition.fromPosition(this.position, 'toNext');\n\n    this._setAffectedBoundaries(this.position);\n\n    this.writer.insert(node, this.position);\n    this.position = livePos.toPosition();\n    livePos.detach(); // The last inserted object should be selected because we can't put a collapsed selection after it.\n\n    if (this.schema.isObject(node) && !this.schema.checkChild(this.position, '$text')) {\n      this.nodeToSelect = node;\n    } else {\n      this.nodeToSelect = null;\n    }\n\n    this._filterAttributesOf.push(node);\n  }\n  /**\n   * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n   * mark the affected range.\n   *\n   * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n   * during merging, but the logic there is more complicated so it is left out of this function.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position\n   */\n\n\n  _setAffectedBoundaries(position) {\n    // Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n    // <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n    // This is why it cannot be a range but two separate positions.\n    if (!this._affectedStart) {\n      this._affectedStart = LivePosition.fromPosition(position, 'toPrevious');\n    } // If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n    // inserted into the parent but the next node is moved-out of that parent:\n    // (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n    // (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n\n\n    if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {\n      if (this._affectedEnd) {\n        this._affectedEnd.detach();\n      }\n\n      this._affectedEnd = LivePosition.fromPosition(position, 'toNext');\n    }\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @param {Object} context\n   */\n\n\n  _mergeSiblingsOf(node, context) {\n    if (!(node instanceof Element)) {\n      return;\n    }\n\n    const mergeLeft = this._canMergeLeft(node, context);\n\n    const mergeRight = this._canMergeRight(node, context);\n\n    const mergePosLeft = LivePosition._createBefore(node);\n\n    mergePosLeft.stickiness = 'toNext';\n\n    const mergePosRight = LivePosition._createAfter(node);\n\n    mergePosRight.stickiness = 'toNext';\n\n    if (mergeLeft) {\n      const livePosition = LivePosition.fromPosition(this.position);\n      livePosition.stickiness = 'toNext'; // If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n      // removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n      // by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n      // shown as `][`).\n      //\n      // Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n      //\n      // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n      //\n      // Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n\n      if (this._affectedStart.isEqual(mergePosLeft)) {\n        this._affectedStart.detach();\n\n        this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toPrevious');\n      }\n\n      this.writer.merge(mergePosLeft); // If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n      //\n      // Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n      //\n      // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n      // <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n\n      if (mergePosLeft.isEqual(this._affectedEnd) && context.isLast) {\n        this._affectedEnd.detach();\n\n        this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toNext');\n      }\n\n      this.position = livePosition.toPosition();\n      livePosition.detach();\n    }\n\n    if (mergeRight) {\n      /* istanbul ignore if */\n      if (!this.position.isEqual(mergePosRight)) {\n        // Algorithm's correctness check. We should never end up here but it's good to know that we did.\n        // At this point the insertion position should be after the node we'll merge. If it isn't,\n        // it should need to be secured as in the left merge case.\n\n        /**\n         * An internal error occured during merging insertion content with siblings.\n         * The insertion position should equal to the merge position.\n         *\n         * @error insertcontent-invalid-insertion-position\n         */\n        throw new CKEditorError('insertcontent-invalid-insertion-position', this);\n      } // Move the position to the previous node, so it isn't moved to the graveyard on merge.\n      // <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\n\n      this.position = Position._createAt(mergePosRight.nodeBefore, 'end'); // OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n      // NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\n      const livePosition = LivePosition.fromPosition(this.position, 'toPrevious'); // See comment above on moving `_affectedStart`.\n\n      if (this._affectedEnd.isEqual(mergePosRight)) {\n        this._affectedEnd.detach();\n\n        this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, 'end', 'toNext');\n      }\n\n      this.writer.merge(mergePosRight); // See comment above on moving `_affectedStart`.\n\n      if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && context.isFirst) {\n        this._affectedStart.detach();\n\n        this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, 'toPrevious');\n      }\n\n      this.position = livePosition.toPosition();\n      livePosition.detach();\n    }\n\n    if (mergeLeft || mergeRight) {\n      // After merge elements that were marked by _insert() to be filtered might be gone so\n      // we need to mark the new container.\n      this._filterAttributesOf.push(this.position.parent);\n    }\n\n    mergePosLeft.detach();\n    mergePosRight.detach();\n  }\n  /**\n   * Checks whether specified node can be merged with previous sibling element.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @param {Object} context\n   * @returns {Boolean}\n   */\n\n\n  _canMergeLeft(node, context) {\n    const previousSibling = node.previousSibling;\n    return context.isFirst && previousSibling instanceof Element && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);\n  }\n  /**\n   * Checks whether specified node can be merged with next sibling element.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n   * @param {Object} context\n   * @returns {Boolean}\n   */\n\n\n  _canMergeRight(node, context) {\n    const nextSibling = node.nextSibling;\n    return context.isLast && nextSibling instanceof Element && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);\n  }\n  /**\n   * Tries wrapping the node in a new paragraph and inserting it this way.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n   * @param {Object} context\n   */\n\n\n  _tryAutoparagraphing(node, context) {\n    const paragraph = this.writer.createElement('paragraph'); // Do not autoparagraph if the paragraph won't be allowed there,\n    // cause that would lead to an infinite loop. The paragraph would be rejected in\n    // the next _handleNode() call and we'd be here again.\n\n    if (this._getAllowedIn(paragraph, this.position.parent) && this.schema.checkChild(paragraph, node)) {\n      paragraph._appendChild(node);\n\n      this._handleNode(paragraph, context);\n    }\n  }\n  /**\n   * @private\n   * @param {module:engine/model/node~Node} node\n   * @returns {Boolean} Whether an allowed position was found.\n   * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n   */\n\n\n  _checkAndSplitToAllowedPosition(node) {\n    const allowedIn = this._getAllowedIn(node, this.position.parent);\n\n    if (!allowedIn) {\n      return false;\n    }\n\n    while (allowedIn != this.position.parent) {\n      // If a parent which we'd need to leave is a limit element, break.\n      if (this.schema.isLimit(this.position.parent)) {\n        return false;\n      }\n\n      if (this.position.isAtStart) {\n        // If insertion position is at the beginning of the parent, move it out instead of splitting.\n        // <p>^Foo</p> -> ^<p>Foo</p>\n        const parent = this.position.parent;\n        this.position = this.writer.createPositionBefore(parent); // Special case â€“ parent is empty (<p>^</p>).\n        //\n        // 1. parent.isEmpty\n        // We can remove the element after moving insertion position out of it.\n        //\n        // 2. parent.parent === allowedIn\n        // However parent should remain in place when allowed element is above limit element in document tree.\n        // For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n        // content allowed in $root.\n\n        if (parent.isEmpty && parent.parent === allowedIn) {\n          this.writer.remove(parent);\n        }\n      } else if (this.position.isAtEnd) {\n        // If insertion position is at the end of the parent, move it out instead of splitting.\n        // <p>Foo^</p> -> <p>Foo</p>^\n        this.position = this.writer.createPositionAfter(this.position.parent);\n      } else {\n        const tempPos = this.writer.createPositionAfter(this.position.parent);\n\n        this._setAffectedBoundaries(this.position);\n\n        this.writer.split(this.position);\n        this.position = tempPos;\n        this.canMergeWith.add(this.position.nodeAfter);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n   *\n   * @private\n   * @param {module:engine/model/node~Node} node The node to check.\n   * @param {module:engine/model/element~Element} element The element in which the node's correctness should be checked.\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  _getAllowedIn(node, element) {\n    if (this.schema.checkChild(element, node)) {\n      return element;\n    }\n\n    if (element.parent) {\n      return this._getAllowedIn(node, element.parent);\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js"],"names":["Position","LivePosition","Element","Range","DocumentSelection","Selection","CKEditorError","insertContent","model","content","selectable","placeOrOffset","change","writer","selection","document","createSelection","isCollapsed","deleteContent","doNotAutoparagraph","insertion","Insertion","anchor","nodesToInsert","is","getChildren","handleNodes","isFirst","isLast","newRange","getSelectionRange","setSelection","setTo","affectedRange","getAffectedRange","createRange","destroy","constructor","position","canMergeWith","Set","parent","schema","_filterAttributesOf","_affectedStart","_affectedEnd","nodes","parentContext","Array","from","i","length","node","_handleNode","removeDisallowedAttributes","nodeToSelect","_createOn","getNearestSelectionRange","detach","context","isObject","_handleObject","isAllowed","_checkAndSplitToAllowedPosition","_handleDisallowedNode","_insert","_mergeSiblingsOf","_tryAutoparagraphing","checkChild","livePos","fromPosition","_setAffectedBoundaries","insert","toPosition","push","isBefore","mergeLeft","_canMergeLeft","mergeRight","_canMergeRight","mergePosLeft","_createBefore","stickiness","mergePosRight","_createAfter","livePosition","isEqual","_createAt","nodeBefore","merge","getShiftedBy","previousSibling","has","checkMerge","nextSibling","paragraph","createElement","_getAllowedIn","_appendChild","allowedIn","isLimit","isAtStart","createPositionBefore","isEmpty","remove","isAtEnd","createPositionAfter","tempPos","split","add","nodeAfter","element"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/insertcontent\n */\n\nimport Position from '../position';\nimport LivePosition from '../liveposition';\nimport Element from '../element';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\nimport Selection from '../selection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Inserts content into the editor (specified selection) as one would expect the paste\n * functionality to work.\n *\n * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified\n * to the insertion selection (equal to a range to be selected after insertion).\n *\n * If `selectable` is not passed, the content will be inserted using the current selection of the model document.\n *\n * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.\n * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n * Selection into which the content should be inserted.\n * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n * at the insertion position.\n */\nexport default function insertContent( model, content, selectable, placeOrOffset ) {\n\treturn model.change( writer => {\n\t\tlet selection;\n\n\t\tif ( !selectable ) {\n\t\t\tselection = model.document.selection;\n\t\t} else if ( selectable instanceof Selection || selectable instanceof DocumentSelection ) {\n\t\t\tselection = selectable;\n\t\t} else {\n\t\t\tselection = writer.createSelection( selectable, placeOrOffset );\n\t\t}\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\tmodel.deleteContent( selection, { doNotAutoparagraph: true } );\n\t\t}\n\n\t\tconst insertion = new Insertion( model, writer, selection.anchor );\n\n\t\tlet nodesToInsert;\n\n\t\tif ( content.is( 'documentFragment' ) ) {\n\t\t\tnodesToInsert = content.getChildren();\n\t\t} else {\n\t\t\tnodesToInsert = [ content ];\n\t\t}\n\n\t\tinsertion.handleNodes( nodesToInsert, {\n\t\t\t// The set of children being inserted is the only set in this context\n\t\t\t// so it's the first and last (it's a hack ;)).\n\t\t\tisFirst: true,\n\t\t\tisLast: true\n\t\t} );\n\n\t\tconst newRange = insertion.getSelectionRange();\n\n\t\t/* istanbul ignore else */\n\t\tif ( newRange ) {\n\t\t\tif ( selection instanceof DocumentSelection ) {\n\t\t\t\twriter.setSelection( newRange );\n\t\t\t} else {\n\t\t\t\tselection.setTo( newRange );\n\t\t\t}\n\t\t} else {\n\t\t\t// We are not testing else because it's a safe check for unpredictable edge cases:\n\t\t\t// an insertion without proper range to select.\n\t\t\t//\n\t\t\t// @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );\n\t\t}\n\n\t\tconst affectedRange = insertion.getAffectedRange() || model.createRange( selection.anchor );\n\n\t\tinsertion.destroy();\n\n\t\treturn affectedRange;\n\t} );\n}\n\n/**\n * Utility class for performing content insertion.\n *\n * @private\n */\nclass Insertion {\n\tconstructor( model, writer, position ) {\n\t\t/**\n\t\t * The model in context of which the insertion should be performed.\n\t\t *\n\t\t * @member {module:engine/model~Model} #model\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Batch to which operations will be added.\n\t\t *\n\t\t * @member {module:engine/controller/writer~Batch} #writer\n\t\t */\n\t\tthis.writer = writer;\n\n\t\t/**\n\t\t * The position at which (or near which) the next node will be inserted.\n\t\t *\n\t\t * @member {module:engine/model/position~Position} #position\n\t\t */\n\t\tthis.position = position;\n\n\t\t/**\n\t\t * Elements with which the inserted elements can be merged.\n\t\t *\n\t\t *\t\t<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)\n\t\t *\t\t<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)\n\t\t *\t\t<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,\n\t\t *\t\t\t\t\t\t\t\tso both its pieces will be added to this set)\n\t\t *\n\t\t *\n\t\t * @member {Set} #canMergeWith\n\t\t */\n\t\tthis.canMergeWith = new Set( [ this.position.parent ] );\n\n\t\t/**\n\t\t * Schema of the model.\n\t\t *\n\t\t * @member {module:engine/model/schema~Schema} #schema\n\t\t */\n\t\tthis.schema = model.schema;\n\n\t\tthis._filterAttributesOf = [];\n\n\t\t/**\n\t\t * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart\n\t\t */\n\t\tthis._affectedStart = null;\n\n\t\t/**\n\t\t * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd\n\t\t */\n\t\tthis._affectedEnd = null;\n\t}\n\n\t/**\n\t * Handles insertion of a set of nodes.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.\n\t * @param {Object} parentContext Context in which parent of these nodes was supposed to be inserted.\n\t * If the parent context is passed it means that the parent element was stripped (was not allowed).\n\t */\n\thandleNodes( nodes, parentContext ) {\n\t\tnodes = Array.from( nodes );\n\n\t\tfor ( let i = 0; i < nodes.length; i++ ) {\n\t\t\tconst node = nodes[ i ];\n\n\t\t\tthis._handleNode( node, {\n\t\t\t\tisFirst: i === 0 && parentContext.isFirst,\n\t\t\t\tisLast: ( i === ( nodes.length - 1 ) ) && parentContext.isLast\n\t\t\t} );\n\t\t}\n\n\t\t// TMP this will become a post-fixer.\n\t\tthis.schema.removeDisallowedAttributes( this._filterAttributesOf, this.writer );\n\t\tthis._filterAttributesOf = [];\n\t}\n\n\t/**\n\t * Returns range to be selected after insertion.\n\t * Returns `null` if there is no valid range to select after insertion.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetSelectionRange() {\n\t\tif ( this.nodeToSelect ) {\n\t\t\treturn Range._createOn( this.nodeToSelect );\n\t\t}\n\n\t\treturn this.model.schema.getNearestSelectionRange( this.position );\n\t}\n\n\t/**\n\t * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state\n\t * before the insertion. Returns `null` if no changes were done.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetAffectedRange() {\n\t\tif ( !this._affectedStart ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn new Range( this._affectedStart, this._affectedEnd );\n\t}\n\n\t/**\n\t * Destroys `Insertion` instance.\n\t */\n\tdestroy() {\n\t\tif ( this._affectedStart ) {\n\t\t\tthis._affectedStart.detach();\n\t\t}\n\n\t\tif ( this._affectedEnd ) {\n\t\t\tthis._affectedEnd.detach();\n\t\t}\n\t}\n\n\t/**\n\t * Handles insertion of a single node.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node\n\t * @param {Object} context\n\t * @param {Boolean} context.isFirst Whether the given node is the first one in the content to be inserted.\n\t * @param {Boolean} context.isLast Whether the given node is the last one in the content to be inserted.\n\t */\n\t_handleNode( node, context ) {\n\t\t// Let's handle object in a special way.\n\t\t// * They should never be merged with other elements.\n\t\t// * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.\n\t\tif ( this.schema.isObject( node ) ) {\n\t\t\tthis._handleObject( node, context );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Try to find a place for the given node.\n\t\t// Split the position.parent's branch up to a point where the node can be inserted.\n\t\t// If it isn't allowed in the whole branch, then of course don't split anything.\n\t\tconst isAllowed = this._checkAndSplitToAllowedPosition( node, context );\n\n\t\tif ( !isAllowed ) {\n\t\t\tthis._handleDisallowedNode( node, context );\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis._insert( node );\n\n\t\t// After the node was inserted we may try to merge it with its siblings.\n\t\t// This should happen only if it was the first and/or last of the nodes (so only with boundary nodes)\n\t\t// and only if the selection was in those elements initially.\n\t\t//\n\t\t// E.g.:\n\t\t// <p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>\n\t\t// and:\n\t\t// <p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>\n\t\t// but:\n\t\t// <p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging)\n\t\t// <p>x</p>[<img>]<p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging, note: after running deleteContents\n\t\t//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t it's exactly the same case as above)\n\t\tthis._mergeSiblingsOf( node, context );\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/element~Element} node The object element.\n\t * @param {Object} context\n\t */\n\t_handleObject( node, context ) {\n\t\t// Try finding it a place in the tree.\n\t\tif ( this._checkAndSplitToAllowedPosition( node ) ) {\n\t\t\tthis._insert( node );\n\t\t}\n\t\t// Try autoparagraphing.\n\t\telse {\n\t\t\tthis._tryAutoparagraphing( node, context );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.\n\t * @param {Object} context\n\t */\n\t_handleDisallowedNode( node, context ) {\n\t\t// If the node is an element, try inserting its children (strip the parent).\n\t\tif ( node.is( 'element' ) ) {\n\t\t\tthis.handleNodes( node.getChildren(), context );\n\t\t}\n\t\t// If text is not allowed, try autoparagraphing it.\n\t\telse {\n\t\t\tthis._tryAutoparagraphing( node, context );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node to insert.\n\t */\n\t_insert( node ) {\n\t\t/* istanbul ignore if */\n\t\tif ( !this.schema.checkChild( this.position, node ) ) {\n\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t// Note that it would often be a silent issue if we insert node in a place where it's not allowed.\n\n\t\t\t/**\n\t\t\t * Given node cannot be inserted on the given position.\n\t\t\t *\n\t\t\t * @error insertcontent-wrong-position\n\t\t\t * @param {module:engine/model/node~Node} node Node to insert.\n\t\t\t * @param {module:engine/model/position~Position} position Position to insert the node at.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'insertcontent-wrong-position: Given node cannot be inserted on the given position.',\n\t\t\t\tthis,\n\t\t\t\t{ node, position: this.position }\n\t\t\t);\n\t\t}\n\n\t\tconst livePos = LivePosition.fromPosition( this.position, 'toNext' );\n\n\t\tthis._setAffectedBoundaries( this.position );\n\t\tthis.writer.insert( node, this.position );\n\n\t\tthis.position = livePos.toPosition();\n\t\tlivePos.detach();\n\n\t\t// The last inserted object should be selected because we can't put a collapsed selection after it.\n\t\tif ( this.schema.isObject( node ) && !this.schema.checkChild( this.position, '$text' ) ) {\n\t\t\tthis.nodeToSelect = node;\n\t\t} else {\n\t\t\tthis.nodeToSelect = null;\n\t\t}\n\n\t\tthis._filterAttributesOf.push( node );\n\t}\n\n\t/**\n\t * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to\n\t * mark the affected range.\n\t *\n\t * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed\n\t * during merging, but the logic there is more complicated so it is left out of this function.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position\n\t */\n\t_setAffectedBoundaries( position ) {\n\t\t// Set affected boundaries stickiness so that those position will \"expand\" when something is inserted in between them:\n\t\t// <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>\n\t\t// This is why it cannot be a range but two separate positions.\n\t\tif ( !this._affectedStart ) {\n\t\t\tthis._affectedStart = LivePosition.fromPosition( position, 'toPrevious' );\n\t\t}\n\n\t\t// If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was\n\t\t// inserted into the parent but the next node is moved-out of that parent:\n\t\t// (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>\n\t\t// (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[\n\t\tif ( !this._affectedEnd || this._affectedEnd.isBefore( position ) ) {\n\t\t\tif ( this._affectedEnd ) {\n\t\t\t\tthis._affectedEnd.detach();\n\t\t\t}\n\n\t\t\tthis._affectedEnd = LivePosition.fromPosition( position, 'toNext' );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @param {Object} context\n\t */\n\t_mergeSiblingsOf( node, context ) {\n\t\tif ( !( node instanceof Element ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst mergeLeft = this._canMergeLeft( node, context );\n\t\tconst mergeRight = this._canMergeRight( node, context );\n\t\tconst mergePosLeft = LivePosition._createBefore( node );\n\t\tmergePosLeft.stickiness = 'toNext';\n\t\tconst mergePosRight = LivePosition._createAfter( node );\n\t\tmergePosRight.stickiness = 'toNext';\n\n\t\tif ( mergeLeft ) {\n\t\t\tconst livePosition = LivePosition.fromPosition( this.position );\n\t\t\tlivePosition.stickiness = 'toNext';\n\n\t\t\t// If `_affectedStart` is sames as merge position, it means that the element \"marked\" by `_affectedStart` is going to be\n\t\t\t// removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved\n\t\t\t// by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the \"range\" is\n\t\t\t// shown as `][`).\n\t\t\t//\n\t\t\t// Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:\n\t\t\t//\n\t\t\t// <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n\t\t\t// <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t\t// <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>\n\t\t\t//\n\t\t\t// Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.\n\t\t\tif ( this._affectedStart.isEqual( mergePosLeft ) ) {\n\t\t\t\tthis._affectedStart.detach();\n\t\t\t\tthis._affectedStart = LivePosition._createAt( mergePosLeft.nodeBefore, 'end', 'toPrevious' );\n\t\t\t}\n\n\t\t\tthis.writer.merge( mergePosLeft );\n\n\t\t\t// If only one element (the merged one) is in the \"affected range\", also move the affected range end appropriately.\n\t\t\t//\n\t\t\t// Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:\n\t\t\t//\n\t\t\t// <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->\n\t\t\t// <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t\t// <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->\n\t\t\t// <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>\n\t\t\tif ( mergePosLeft.isEqual( this._affectedEnd ) && context.isLast ) {\n\t\t\t\tthis._affectedEnd.detach();\n\t\t\t\tthis._affectedEnd = LivePosition._createAt( mergePosLeft.nodeBefore, 'end', 'toNext' );\n\t\t\t}\n\n\t\t\tthis.position = livePosition.toPosition();\n\t\t\tlivePosition.detach();\n\t\t}\n\n\t\tif ( mergeRight ) {\n\t\t\t/* istanbul ignore if */\n\t\t\tif ( !this.position.isEqual( mergePosRight ) ) {\n\t\t\t\t// Algorithm's correctness check. We should never end up here but it's good to know that we did.\n\t\t\t\t// At this point the insertion position should be after the node we'll merge. If it isn't,\n\t\t\t\t// it should need to be secured as in the left merge case.\n\t\t\t\t/**\n\t\t\t\t * An internal error occured during merging insertion content with siblings.\n\t\t\t\t * The insertion position should equal to the merge position.\n\t\t\t\t *\n\t\t\t\t * @error insertcontent-invalid-insertion-position\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'insertcontent-invalid-insertion-position', this );\n\t\t\t}\n\n\t\t\t// Move the position to the previous node, so it isn't moved to the graveyard on merge.\n\t\t\t// <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>\n\t\t\tthis.position = Position._createAt( mergePosRight.nodeBefore, 'end' );\n\n\t\t\t// OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)\n\t\t\t// NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)\n\t\t\tconst livePosition = LivePosition.fromPosition( this.position, 'toPrevious' );\n\n\t\t\t// See comment above on moving `_affectedStart`.\n\t\t\tif ( this._affectedEnd.isEqual( mergePosRight ) ) {\n\t\t\t\tthis._affectedEnd.detach();\n\t\t\t\tthis._affectedEnd = LivePosition._createAt( mergePosRight.nodeBefore, 'end', 'toNext' );\n\t\t\t}\n\n\t\t\tthis.writer.merge( mergePosRight );\n\n\t\t\t// See comment above on moving `_affectedStart`.\n\t\t\tif ( mergePosRight.getShiftedBy( -1 ).isEqual( this._affectedStart ) && context.isFirst ) {\n\t\t\t\tthis._affectedStart.detach();\n\t\t\t\tthis._affectedStart = LivePosition._createAt( mergePosRight.nodeBefore, 0, 'toPrevious' );\n\t\t\t}\n\n\t\t\tthis.position = livePosition.toPosition();\n\t\t\tlivePosition.detach();\n\t\t}\n\n\t\tif ( mergeLeft || mergeRight ) {\n\t\t\t// After merge elements that were marked by _insert() to be filtered might be gone so\n\t\t\t// we need to mark the new container.\n\t\t\tthis._filterAttributesOf.push( this.position.parent );\n\t\t}\n\n\t\tmergePosLeft.detach();\n\t\tmergePosRight.detach();\n\t}\n\n\t/**\n\t * Checks whether specified node can be merged with previous sibling element.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @param {Object} context\n\t * @returns {Boolean}\n\t */\n\t_canMergeLeft( node, context ) {\n\t\tconst previousSibling = node.previousSibling;\n\n\t\treturn context.isFirst &&\n\t\t\t( previousSibling instanceof Element ) &&\n\t\t\tthis.canMergeWith.has( previousSibling ) &&\n\t\t\tthis.model.schema.checkMerge( previousSibling, node );\n\t}\n\n\t/**\n\t * Checks whether specified node can be merged with next sibling element.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which could potentially be merged.\n\t * @param {Object} context\n\t * @returns {Boolean}\n\t */\n\t_canMergeRight( node, context ) {\n\t\tconst nextSibling = node.nextSibling;\n\n\t\treturn context.isLast &&\n\t\t\t( nextSibling instanceof Element ) &&\n\t\t\tthis.canMergeWith.has( nextSibling ) &&\n\t\t\tthis.model.schema.checkMerge( node, nextSibling );\n\t}\n\n\t/**\n\t * Tries wrapping the node in a new paragraph and inserting it this way.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.\n\t * @param {Object} context\n\t */\n\t_tryAutoparagraphing( node, context ) {\n\t\tconst paragraph = this.writer.createElement( 'paragraph' );\n\n\t\t// Do not autoparagraph if the paragraph won't be allowed there,\n\t\t// cause that would lead to an infinite loop. The paragraph would be rejected in\n\t\t// the next _handleNode() call and we'd be here again.\n\t\tif ( this._getAllowedIn( paragraph, this.position.parent ) && this.schema.checkChild( paragraph, node ) ) {\n\t\t\tparagraph._appendChild( node );\n\t\t\tthis._handleNode( paragraph, context );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/node~Node} node\n\t * @returns {Boolean} Whether an allowed position was found.\n\t * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.\n\t */\n\t_checkAndSplitToAllowedPosition( node ) {\n\t\tconst allowedIn = this._getAllowedIn( node, this.position.parent );\n\n\t\tif ( !allowedIn ) {\n\t\t\treturn false;\n\t\t}\n\n\t\twhile ( allowedIn != this.position.parent ) {\n\t\t\t// If a parent which we'd need to leave is a limit element, break.\n\t\t\tif ( this.schema.isLimit( this.position.parent ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif ( this.position.isAtStart ) {\n\t\t\t\t// If insertion position is at the beginning of the parent, move it out instead of splitting.\n\t\t\t\t// <p>^Foo</p> -> ^<p>Foo</p>\n\t\t\t\tconst parent = this.position.parent;\n\n\t\t\t\tthis.position = this.writer.createPositionBefore( parent );\n\n\t\t\t\t// Special case â€“ parent is empty (<p>^</p>).\n\t\t\t\t//\n\t\t\t\t// 1. parent.isEmpty\n\t\t\t\t// We can remove the element after moving insertion position out of it.\n\t\t\t\t//\n\t\t\t\t// 2. parent.parent === allowedIn\n\t\t\t\t// However parent should remain in place when allowed element is above limit element in document tree.\n\t\t\t\t// For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted\n\t\t\t\t// content allowed in $root.\n\t\t\t\tif ( parent.isEmpty && parent.parent === allowedIn ) {\n\t\t\t\t\tthis.writer.remove( parent );\n\t\t\t\t}\n\t\t\t} else if ( this.position.isAtEnd ) {\n\t\t\t\t// If insertion position is at the end of the parent, move it out instead of splitting.\n\t\t\t\t// <p>Foo^</p> -> <p>Foo</p>^\n\t\t\t\tthis.position = this.writer.createPositionAfter( this.position.parent );\n\t\t\t} else {\n\t\t\t\tconst tempPos = this.writer.createPositionAfter( this.position.parent );\n\n\t\t\t\tthis._setAffectedBoundaries( this.position );\n\t\t\t\tthis.writer.split( this.position );\n\n\t\t\t\tthis.position = tempPos;\n\n\t\t\t\tthis.canMergeWith.add( this.position.nodeAfter );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.\n\t *\n\t * @private\n\t * @param {module:engine/model/node~Node} node The node to check.\n\t * @param {module:engine/model/element~Element} element The element in which the node's correctness should be checked.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\t_getAllowedIn( node, element ) {\n\t\tif ( this.schema.checkChild( element, node ) ) {\n\t\t\treturn element;\n\t\t}\n\n\t\tif ( element.parent ) {\n\t\t\treturn this._getAllowedIn( node, element.parent );\n\t\t}\n\n\t\treturn null;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}