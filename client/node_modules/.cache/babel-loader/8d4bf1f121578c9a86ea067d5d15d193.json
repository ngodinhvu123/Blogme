{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\n\n/* globals console */\nimport CKEditorError, { attachLinkToDocumentation } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class PluginCollection {\n  /**\n   * Creates an instance of the plugin collection class.\n   * Allows loading and initializing plugins and their dependencies.\n   * Allows to provide a list of already loaded plugins. These plugins will not be destroyed along with this collection.\n   *\n   * @param {module:core/editor/editor~Editor|module:core/context~Context} context\n   * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n   * when {@link module:core/plugincollection~PluginCollection#init} is used with plugin names (strings, instead of constructors).\n   * Usually, the editor will pass its built-in plugins to the collection so they can later be\n   * used in `config.plugins` or `config.removePlugins` by names.\n   * @param {Iterable.<Array>} contextPlugins A list of already initialized plugins represented by a\n   * `[ PluginConstructor, pluginInstance ]` pair.\n   */\n  constructor(context, availablePlugins = [], contextPlugins = []) {\n    /**\n     * @protected\n     * @type {module:core/editor/editor~Editor|module:core/context~Context}\n     */\n    this._context = context;\n    /**\n     * @protected\n     * @type {Map}\n     */\n\n    this._plugins = new Map();\n    /**\n     * A map of plugin constructors that can be retrieved by their names.\n     *\n     * @protected\n     * @type {Map.<String|Function,Function>}\n     */\n\n    this._availablePlugins = new Map();\n\n    for (const PluginConstructor of availablePlugins) {\n      if (PluginConstructor.pluginName) {\n        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n      }\n    }\n    /**\n     * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.\n     *\n     * @protected\n     * @type {Map<Function,Function>}\n     */\n\n\n    this._contextPlugins = new Map();\n\n    for (const [PluginConstructor, pluginInstance] of contextPlugins) {\n      this._contextPlugins.set(PluginConstructor, pluginInstance);\n\n      this._contextPlugins.set(pluginInstance, PluginConstructor); // To make it possible to require a plugin by its name.\n\n\n      if (PluginConstructor.pluginName) {\n        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n      }\n    }\n  }\n  /**\n   * Iterable interface.\n   *\n   * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n   *\n   * @returns {Iterable.<Array>}\n   */\n\n\n  *[Symbol.iterator]() {\n    for (const entry of this._plugins) {\n      if (typeof entry[0] == 'function') {\n        yield entry;\n      }\n    }\n  }\n  /**\n   * Gets the plugin instance by its constructor or name.\n   *\n   *\t\t// Check if 'Clipboard' plugin was loaded.\n   *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n   *\t\t\t// Get clipboard plugin instance\n   *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n   *\n   *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n   *\t\t\t\t// Do something on clipboard input.\n   *\t\t\t} );\n   *\t\t}\n   *\n   * **Note**: This method will throw error if plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n   * to check if plugin is available.\n   *\n   * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n   * @returns {module:core/plugin~PluginInterface}\n   */\n\n\n  get(key) {\n    const plugin = this._plugins.get(key);\n\n    if (!plugin) {\n      /**\n       * The plugin is not loaded and could not be obtained.\n       *\n       * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n       * the plugin collection.\n       * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n       * property.\n       *\n       * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n       * to check if plugin was loaded.\n       *\n       * @error plugincollection-plugin-not-loaded\n       * @param {String} plugin The name of the plugin which is not loaded.\n       */\n      const errorMsg = 'plugincollection-plugin-not-loaded: The requested plugin is not loaded.';\n      let pluginName = key;\n\n      if (typeof key == 'function') {\n        pluginName = key.pluginName || key.name;\n      }\n\n      throw new CKEditorError(errorMsg, this._context, {\n        plugin: pluginName\n      });\n    }\n\n    return plugin;\n  }\n  /**\n   * Checks if a plugin is loaded.\n   *\n   *\t\t// Check if the 'Clipboard' plugin was loaded.\n   *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n   *\t\t\t// Now use the clipboard plugin instance:\n   *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n   *\n   *\t\t\t// ...\n   *\t\t}\n   *\n   * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n   * @returns {Boolean}\n   */\n\n\n  has(key) {\n    return this._plugins.has(key);\n  }\n  /**\n   * Initializes a set of plugins and adds them to the collection.\n   *\n   * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n   * or {@link module:core/plugin~PluginInterface.pluginName plugin names}. The second option (names) works only if\n   * `availablePlugins` were passed to the {@link #constructor}.\n   * @param {Array.<String|Function>} [removePlugins] Names of plugins or plugin constructors\n   * that should not be loaded (despite being specified in the `plugins` array).\n   * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n   * and available in the collection.\n   */\n\n\n  init(plugins, removePlugins = []) {\n    const that = this;\n    const context = this._context;\n    const loading = new Set();\n    const loaded = [];\n    const pluginConstructors = mapToAvailableConstructors(plugins);\n    const removePluginConstructors = mapToAvailableConstructors(removePlugins);\n    const missingPlugins = getMissingPluginNames(plugins);\n\n    if (missingPlugins) {\n      /**\n       * Some plugins are not available and could not be loaded.\n       *\n       * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n       * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n       * property.\n       *\n       * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means\n       * that you try to enable a plugin which was not included in that build. This may be due to a typo\n       * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n       * read more about {@glink builds/guides/development/custom-builds custom builds}.\n       *\n       * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n       * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n       * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n       * provide each plugin through reference (as a constructor function). Check out the examples in\n       * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source \"Building from source\"}.\n       *\n       * @error plugincollection-plugin-not-found\n       * @param {Array.<String>} plugins The name of the plugins which could not be loaded.\n       */\n      const errorMsg = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.'; // Log the error so it's more visible on the console. Hopefully, for better DX.\n\n      console.error(attachLinkToDocumentation(errorMsg), {\n        plugins: missingPlugins\n      });\n      return Promise.reject(new CKEditorError(errorMsg, context, {\n        plugins: missingPlugins\n      }));\n    }\n\n    return Promise.all(pluginConstructors.map(loadPlugin)).then(() => initPlugins(loaded, 'init')).then(() => initPlugins(loaded, 'afterInit')).then(() => loaded);\n\n    function loadPlugin(PluginConstructor) {\n      if (removePluginConstructors.includes(PluginConstructor)) {\n        return;\n      } // The plugin is already loaded or being loaded - do nothing.\n\n\n      if (that._plugins.has(PluginConstructor) || loading.has(PluginConstructor)) {\n        return;\n      }\n\n      return instantiatePlugin(PluginConstructor).catch(err => {\n        /**\n         * It was not possible to load the plugin.\n         *\n         * This is a generic error logged to the console when a JavaSript error is thrown during the initialization\n         * of one of the plugins.\n         *\n         * If you correctly handled the promise returned by the editor's `create()` method (like shown below),\n         * you will find the original error logged to the console, too:\n         *\n         *\t\tClassicEditor.create( document.getElementById( 'editor' ) )\n         *\t\t\t.then( editor => {\n         *\t\t\t\t// ...\n         * \t\t\t} )\n         *\t\t\t.catch( error => {\n         *\t\t\t\tconsole.error( error );\n         *\t\t\t} );\n         *\n         * @error plugincollection-load\n         * @param {String} plugin The name of the plugin that could not be loaded.\n         */\n        console.error(attachLinkToDocumentation('plugincollection-load: It was not possible to load the plugin.'), {\n          plugin: PluginConstructor\n        });\n        throw err;\n      });\n    }\n\n    function initPlugins(loadedPlugins, method) {\n      return loadedPlugins.reduce((promise, plugin) => {\n        if (!plugin[method]) {\n          return promise;\n        }\n\n        if (that._contextPlugins.has(plugin)) {\n          return promise;\n        }\n\n        return promise.then(plugin[method].bind(plugin));\n      }, Promise.resolve());\n    }\n\n    function instantiatePlugin(PluginConstructor) {\n      return new Promise(resolve => {\n        loading.add(PluginConstructor);\n\n        if (PluginConstructor.requires) {\n          PluginConstructor.requires.forEach(RequiredPluginConstructorOrName => {\n            const RequiredPluginConstructor = getPluginConstructor(RequiredPluginConstructorOrName);\n\n            if (PluginConstructor.isContextPlugin && !RequiredPluginConstructor.isContextPlugin) {\n              /**\n               * If a plugin is a context plugin, all plugins it requires should also be context plugins\n               * instead of plugins. In other words, if one plugin can be used in the context,\n               * all its requirements should also be ready to be used in the context. Note that the context\n               * provides only a part of the API provided by the editor. If one plugin needs a full\n               * editor API, all plugins which require it are considered as plugins that need a full\n               * editor API.\n               *\n               * @error plugincollection-context-required\n               * @param {String} plugin The name of the required plugin.\n               * @param {String} requiredBy The name of the parent plugin.\n               */\n              throw new CKEditorError('plugincollection-context-required: Context plugin can not require plugin which is not a context plugin', null, {\n                plugin: RequiredPluginConstructor.name,\n                requiredBy: PluginConstructor.name\n              });\n            }\n\n            if (removePlugins.includes(RequiredPluginConstructor)) {\n              /**\n               * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n               *\n               * @error plugincollection-required\n               * @param {String} plugin The name of the required plugin.\n               * @param {String} requiredBy The name of the parent plugin.\n               */\n              throw new CKEditorError('plugincollection-required: Cannot load a plugin because one of its dependencies is listed in' + 'the `removePlugins` option.', context, {\n                plugin: RequiredPluginConstructor.name,\n                requiredBy: PluginConstructor.name\n              });\n            }\n\n            loadPlugin(RequiredPluginConstructor);\n          });\n        }\n\n        const plugin = that._contextPlugins.get(PluginConstructor) || new PluginConstructor(context);\n\n        that._add(PluginConstructor, plugin);\n\n        loaded.push(plugin);\n        resolve();\n      });\n    }\n\n    function getPluginConstructor(PluginConstructorOrName) {\n      if (typeof PluginConstructorOrName == 'function') {\n        return PluginConstructorOrName;\n      }\n\n      return that._availablePlugins.get(PluginConstructorOrName);\n    }\n\n    function getMissingPluginNames(plugins) {\n      const missingPlugins = [];\n\n      for (const pluginNameOrConstructor of plugins) {\n        if (!getPluginConstructor(pluginNameOrConstructor)) {\n          missingPlugins.push(pluginNameOrConstructor);\n        }\n      }\n\n      return missingPlugins.length ? missingPlugins : null;\n    }\n\n    function mapToAvailableConstructors(plugins) {\n      return plugins.map(pluginNameOrConstructor => getPluginConstructor(pluginNameOrConstructor)).filter(PluginConstructor => !!PluginConstructor);\n    }\n  }\n  /**\n   * Destroys all loaded plugins.\n   *\n   * @returns {Promise}\n   */\n\n\n  destroy() {\n    const promises = [];\n\n    for (const [, pluginInstance] of this) {\n      if (typeof pluginInstance.destroy == 'function' && !this._contextPlugins.has(pluginInstance)) {\n        promises.push(pluginInstance.destroy());\n      }\n    }\n\n    return Promise.all(promises);\n  }\n  /**\n   * Adds the plugin to the collection. Exposed mainly for testing purposes.\n   *\n   * @protected\n   * @param {Function} PluginConstructor The plugin constructor.\n   * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n   */\n\n\n  _add(PluginConstructor, plugin) {\n    this._plugins.set(PluginConstructor, plugin);\n\n    const pluginName = PluginConstructor.pluginName;\n\n    if (!pluginName) {\n      return;\n    }\n\n    if (this._plugins.has(pluginName)) {\n      /**\n       * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n       * This will lead to runtime conflicts between these plugins.\n       *\n       * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n       * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n       * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n       *\n       * Check your import paths and the list of plugins passed to\n       * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n       * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n       *\n       * The second option is that your `node_modules/` directory contains duplicated versions of the same\n       * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n       * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n       * of packages, their dependencies may need to be installed in more than one version which may lead to this\n       * warning.\n       *\n       * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n       * dependencies of this plugin are being duplicated.\n       * They are already built into that editor build and now get added for the second time as dependencies\n       * of the plugin you are installing.\n       *\n       * Read more about {@glink builds/guides/integration/installing-plugins installing plugins}.\n       *\n       * @error plugincollection-plugin-name-conflict\n       * @param {String} pluginName The duplicated plugin name.\n       * @param {Function} plugin1 The first plugin constructor.\n       * @param {Function} plugin2 The second plugin constructor.\n       */\n      throw new CKEditorError('plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.', null, {\n        pluginName,\n        plugin1: this._plugins.get(pluginName).constructor,\n        plugin2: PluginConstructor\n      });\n    }\n\n    this._plugins.set(pluginName, plugin);\n  }\n\n}\nmix(PluginCollection, EmitterMixin);","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js"],"names":["CKEditorError","attachLinkToDocumentation","EmitterMixin","mix","PluginCollection","constructor","context","availablePlugins","contextPlugins","_context","_plugins","Map","_availablePlugins","PluginConstructor","pluginName","set","_contextPlugins","pluginInstance","Symbol","iterator","entry","get","key","plugin","errorMsg","name","has","init","plugins","removePlugins","that","loading","Set","loaded","pluginConstructors","mapToAvailableConstructors","removePluginConstructors","missingPlugins","getMissingPluginNames","console","error","Promise","reject","all","map","loadPlugin","then","initPlugins","includes","instantiatePlugin","catch","err","loadedPlugins","method","reduce","promise","bind","resolve","add","requires","forEach","RequiredPluginConstructorOrName","RequiredPluginConstructor","getPluginConstructor","isContextPlugin","requiredBy","_add","push","PluginConstructorOrName","pluginNameOrConstructor","length","filter","destroy","promises","plugin1","plugin2"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\n\n/* globals console */\n\nimport CKEditorError, { attachLinkToDocumentation } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class PluginCollection {\n\t/**\n\t * Creates an instance of the plugin collection class.\n\t * Allows loading and initializing plugins and their dependencies.\n\t * Allows to provide a list of already loaded plugins. These plugins will not be destroyed along with this collection.\n\t *\n\t * @param {module:core/editor/editor~Editor|module:core/context~Context} context\n\t * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n\t * when {@link module:core/plugincollection~PluginCollection#init} is used with plugin names (strings, instead of constructors).\n\t * Usually, the editor will pass its built-in plugins to the collection so they can later be\n\t * used in `config.plugins` or `config.removePlugins` by names.\n\t * @param {Iterable.<Array>} contextPlugins A list of already initialized plugins represented by a\n\t * `[ PluginConstructor, pluginInstance ]` pair.\n\t */\n\tconstructor( context, availablePlugins = [], contextPlugins = [] ) {\n\t\t/**\n\t\t * @protected\n\t\t * @type {module:core/editor/editor~Editor|module:core/context~Context}\n\t\t */\n\t\tthis._context = context;\n\n\t\t/**\n\t\t * @protected\n\t\t * @type {Map}\n\t\t */\n\t\tthis._plugins = new Map();\n\n\t\t/**\n\t\t * A map of plugin constructors that can be retrieved by their names.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map.<String|Function,Function>}\n\t\t */\n\t\tthis._availablePlugins = new Map();\n\n\t\tfor ( const PluginConstructor of availablePlugins ) {\n\t\t\tif ( PluginConstructor.pluginName ) {\n\t\t\t\tthis._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map<Function,Function>}\n\t\t */\n\t\tthis._contextPlugins = new Map();\n\n\t\tfor ( const [ PluginConstructor, pluginInstance ] of contextPlugins ) {\n\t\t\tthis._contextPlugins.set( PluginConstructor, pluginInstance );\n\t\t\tthis._contextPlugins.set( pluginInstance, PluginConstructor );\n\n\t\t\t// To make it possible to require a plugin by its name.\n\t\t\tif ( PluginConstructor.pluginName ) {\n\t\t\t\tthis._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n\t *\n\t * @returns {Iterable.<Array>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tfor ( const entry of this._plugins ) {\n\t\t\tif ( typeof entry[ 0 ] == 'function' ) {\n\t\t\t\tyield entry;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the plugin instance by its constructor or name.\n\t *\n\t *\t\t// Check if 'Clipboard' plugin was loaded.\n\t *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n\t *\t\t\t// Get clipboard plugin instance\n\t *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n\t *\n\t *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n\t *\t\t\t\t// Do something on clipboard input.\n\t *\t\t\t} );\n\t *\t\t}\n\t *\n\t * **Note**: This method will throw error if plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n\t * to check if plugin is available.\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {module:core/plugin~PluginInterface}\n\t */\n\tget( key ) {\n\t\tconst plugin = this._plugins.get( key );\n\n\t\tif ( !plugin ) {\n\t\t\t/**\n\t\t\t * The plugin is not loaded and could not be obtained.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n\t\t\t * the plugin collection.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n\t\t\t * to check if plugin was loaded.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-loaded\n\t\t\t * @param {String} plugin The name of the plugin which is not loaded.\n\t\t\t */\n\t\t\tconst errorMsg = 'plugincollection-plugin-not-loaded: The requested plugin is not loaded.';\n\n\t\t\tlet pluginName = key;\n\n\t\t\tif ( typeof key == 'function' ) {\n\t\t\t\tpluginName = key.pluginName || key.name;\n\t\t\t}\n\n\t\t\tthrow new CKEditorError( errorMsg, this._context, { plugin: pluginName } );\n\t\t}\n\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * Checks if a plugin is loaded.\n\t *\n\t *\t\t// Check if the 'Clipboard' plugin was loaded.\n\t *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n\t *\t\t\t// Now use the clipboard plugin instance:\n\t *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n\t *\n\t *\t\t\t// ...\n\t *\t\t}\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {Boolean}\n\t */\n\thas( key ) {\n\t\treturn this._plugins.has( key );\n\t}\n\n\t/**\n\t * Initializes a set of plugins and adds them to the collection.\n\t *\n\t * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n\t * or {@link module:core/plugin~PluginInterface.pluginName plugin names}. The second option (names) works only if\n\t * `availablePlugins` were passed to the {@link #constructor}.\n\t * @param {Array.<String|Function>} [removePlugins] Names of plugins or plugin constructors\n\t * that should not be loaded (despite being specified in the `plugins` array).\n\t * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n\t * and available in the collection.\n\t */\n\tinit( plugins, removePlugins = [] ) {\n\t\tconst that = this;\n\t\tconst context = this._context;\n\t\tconst loading = new Set();\n\t\tconst loaded = [];\n\n\t\tconst pluginConstructors = mapToAvailableConstructors( plugins );\n\t\tconst removePluginConstructors = mapToAvailableConstructors( removePlugins );\n\t\tconst missingPlugins = getMissingPluginNames( plugins );\n\n\t\tif ( missingPlugins ) {\n\t\t\t/**\n\t\t\t * Some plugins are not available and could not be loaded.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means\n\t\t\t * that you try to enable a plugin which was not included in that build. This may be due to a typo\n\t\t\t * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n\t\t\t * read more about {@glink builds/guides/development/custom-builds custom builds}.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n\t\t\t * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n\t\t\t * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n\t\t\t * provide each plugin through reference (as a constructor function). Check out the examples in\n\t\t\t * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source \"Building from source\"}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-found\n\t\t\t * @param {Array.<String>} plugins The name of the plugins which could not be loaded.\n\t\t\t */\n\t\t\tconst errorMsg = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.';\n\n\t\t\t// Log the error so it's more visible on the console. Hopefully, for better DX.\n\t\t\tconsole.error( attachLinkToDocumentation( errorMsg ), { plugins: missingPlugins } );\n\n\t\t\treturn Promise.reject( new CKEditorError( errorMsg, context, { plugins: missingPlugins } ) );\n\t\t}\n\n\t\treturn Promise.all( pluginConstructors.map( loadPlugin ) )\n\t\t\t.then( () => initPlugins( loaded, 'init' ) )\n\t\t\t.then( () => initPlugins( loaded, 'afterInit' ) )\n\t\t\t.then( () => loaded );\n\n\t\tfunction loadPlugin( PluginConstructor ) {\n\t\t\tif ( removePluginConstructors.includes( PluginConstructor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The plugin is already loaded or being loaded - do nothing.\n\t\t\tif ( that._plugins.has( PluginConstructor ) || loading.has( PluginConstructor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn instantiatePlugin( PluginConstructor )\n\t\t\t\t.catch( err => {\n\t\t\t\t\t/**\n\t\t\t\t\t * It was not possible to load the plugin.\n\t\t\t\t\t *\n\t\t\t\t\t * This is a generic error logged to the console when a JavaSript error is thrown during the initialization\n\t\t\t\t\t * of one of the plugins.\n\t\t\t\t\t *\n\t\t\t\t\t * If you correctly handled the promise returned by the editor's `create()` method (like shown below),\n\t\t\t\t\t * you will find the original error logged to the console, too:\n\t\t\t\t\t *\n\t\t\t\t\t *\t\tClassicEditor.create( document.getElementById( 'editor' ) )\n\t\t\t\t\t *\t\t\t.then( editor => {\n\t\t\t\t\t *\t\t\t\t// ...\n\t\t\t\t\t * \t\t\t} )\n\t\t\t\t\t *\t\t\t.catch( error => {\n\t\t\t\t\t *\t\t\t\tconsole.error( error );\n\t\t\t\t\t *\t\t\t} );\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-load\n\t\t\t\t\t * @param {String} plugin The name of the plugin that could not be loaded.\n\t\t\t\t\t */\n\t\t\t\t\tconsole.error( attachLinkToDocumentation(\n\t\t\t\t\t\t'plugincollection-load: It was not possible to load the plugin.'\n\t\t\t\t\t), { plugin: PluginConstructor } );\n\n\t\t\t\t\tthrow err;\n\t\t\t\t} );\n\t\t}\n\n\t\tfunction initPlugins( loadedPlugins, method ) {\n\t\t\treturn loadedPlugins.reduce( ( promise, plugin ) => {\n\t\t\t\tif ( !plugin[ method ] ) {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\n\t\t\t\tif ( that._contextPlugins.has( plugin ) ) {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\n\t\t\t\treturn promise.then( plugin[ method ].bind( plugin ) );\n\t\t\t}, Promise.resolve() );\n\t\t}\n\n\t\tfunction instantiatePlugin( PluginConstructor ) {\n\t\t\treturn new Promise( resolve => {\n\t\t\t\tloading.add( PluginConstructor );\n\n\t\t\t\tif ( PluginConstructor.requires ) {\n\t\t\t\t\tPluginConstructor.requires.forEach( RequiredPluginConstructorOrName => {\n\t\t\t\t\t\tconst RequiredPluginConstructor = getPluginConstructor( RequiredPluginConstructorOrName );\n\n\t\t\t\t\t\tif ( PluginConstructor.isContextPlugin && !RequiredPluginConstructor.isContextPlugin ) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * If a plugin is a context plugin, all plugins it requires should also be context plugins\n\t\t\t\t\t\t\t * instead of plugins. In other words, if one plugin can be used in the context,\n\t\t\t\t\t\t\t * all its requirements should also be ready to be used in the context. Note that the context\n\t\t\t\t\t\t\t * provides only a part of the API provided by the editor. If one plugin needs a full\n\t\t\t\t\t\t\t * editor API, all plugins which require it are considered as plugins that need a full\n\t\t\t\t\t\t\t * editor API.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * @error plugincollection-context-required\n\t\t\t\t\t\t\t * @param {String} plugin The name of the required plugin.\n\t\t\t\t\t\t\t * @param {String} requiredBy The name of the parent plugin.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t\t\t'plugincollection-context-required: Context plugin can not require plugin which is not a context plugin',\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t{ plugin: RequiredPluginConstructor.name, requiredBy: PluginConstructor.name }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( removePlugins.includes( RequiredPluginConstructor ) ) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * @error plugincollection-required\n\t\t\t\t\t\t\t * @param {String} plugin The name of the required plugin.\n\t\t\t\t\t\t\t * @param {String} requiredBy The name of the parent plugin.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t\t\t'plugincollection-required: Cannot load a plugin because one of its dependencies is listed in' +\n\t\t\t\t\t\t\t\t'the `removePlugins` option.',\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t{ plugin: RequiredPluginConstructor.name, requiredBy: PluginConstructor.name }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadPlugin( RequiredPluginConstructor );\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\tconst plugin = that._contextPlugins.get( PluginConstructor ) || new PluginConstructor( context );\n\t\t\t\tthat._add( PluginConstructor, plugin );\n\t\t\t\tloaded.push( plugin );\n\n\t\t\t\tresolve();\n\t\t\t} );\n\t\t}\n\n\t\tfunction getPluginConstructor( PluginConstructorOrName ) {\n\t\t\tif ( typeof PluginConstructorOrName == 'function' ) {\n\t\t\t\treturn PluginConstructorOrName;\n\t\t\t}\n\n\t\t\treturn that._availablePlugins.get( PluginConstructorOrName );\n\t\t}\n\n\t\tfunction getMissingPluginNames( plugins ) {\n\t\t\tconst missingPlugins = [];\n\n\t\t\tfor ( const pluginNameOrConstructor of plugins ) {\n\t\t\t\tif ( !getPluginConstructor( pluginNameOrConstructor ) ) {\n\t\t\t\t\tmissingPlugins.push( pluginNameOrConstructor );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn missingPlugins.length ? missingPlugins : null;\n\t\t}\n\n\t\tfunction mapToAvailableConstructors( plugins ) {\n\t\t\treturn plugins\n\t\t\t\t.map( pluginNameOrConstructor => getPluginConstructor( pluginNameOrConstructor ) )\n\t\t\t\t.filter( PluginConstructor => !!PluginConstructor );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys all loaded plugins.\n\t *\n\t * @returns {Promise}\n\t */\n\tdestroy() {\n\t\tconst promises = [];\n\n\t\tfor ( const [ , pluginInstance ] of this ) {\n\t\t\tif ( typeof pluginInstance.destroy == 'function' && !this._contextPlugins.has( pluginInstance ) ) {\n\t\t\t\tpromises.push( pluginInstance.destroy() );\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.all( promises );\n\t}\n\n\t/**\n\t * Adds the plugin to the collection. Exposed mainly for testing purposes.\n\t *\n\t * @protected\n\t * @param {Function} PluginConstructor The plugin constructor.\n\t * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n\t */\n\t_add( PluginConstructor, plugin ) {\n\t\tthis._plugins.set( PluginConstructor, plugin );\n\n\t\tconst pluginName = PluginConstructor.pluginName;\n\n\t\tif ( !pluginName ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._plugins.has( pluginName ) ) {\n\t\t\t/**\n\t\t\t * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n\t\t\t * This will lead to runtime conflicts between these plugins.\n\t\t\t *\n\t\t\t * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n\t\t\t * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n\t\t\t * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n\t\t\t *\n\t\t\t * Check your import paths and the list of plugins passed to\n\t\t\t * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n\t\t\t * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n\t\t\t *\n\t\t\t * The second option is that your `node_modules/` directory contains duplicated versions of the same\n\t\t\t * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n\t\t\t * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n\t\t\t * of packages, their dependencies may need to be installed in more than one version which may lead to this\n\t\t\t * warning.\n\t\t\t *\n\t\t\t * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n\t\t\t * dependencies of this plugin are being duplicated.\n\t\t\t * They are already built into that editor build and now get added for the second time as dependencies\n\t\t\t * of the plugin you are installing.\n\t\t\t *\n\t\t\t * Read more about {@glink builds/guides/integration/installing-plugins installing plugins}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-name-conflict\n\t\t\t * @param {String} pluginName The duplicated plugin name.\n\t\t\t * @param {Function} plugin1 The first plugin constructor.\n\t\t\t * @param {Function} plugin2 The second plugin constructor.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.',\n\t\t\t\tnull,\n\t\t\t\t{ pluginName, plugin1: this._plugins.get( pluginName ).constructor, plugin2: PluginConstructor }\n\t\t\t);\n\t\t}\n\n\t\tthis._plugins.set( pluginName, plugin );\n\t}\n}\n\nmix( PluginCollection, EmitterMixin );\n"]},"metadata":{},"sourceType":"module"}