{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { extend } from 'lodash-es';\n/**\n * `DowncastDispatcher` is a central point of downcasting (conversion from model to view), which is a process of reacting to changes\n * in the model and firing a set of events. Callbacks listening to those events are called converters. Those\n * converters role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During conversion process, `DowncastDispatcher` fires events, basing on state of the model and prepares\n * data for those events. It is important to understand that those events are connected with changes done on model,\n * for example: \"node has been inserted\" or \"attribute has changed\". This is in a contrary to upcasting (view to model conversion),\n * where we convert view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to `DowncastDispatcher` as a diff between old model state and new model state.\n *\n * Note, that because changes are converted there is a need to have a mapping between model structure and view structure.\n * To map positions and elements during downcast (model to view conversion) use {@link module:engine/conversion/mapper~Mapper}.\n *\n * `DowncastDispatcher` fires following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}\n * if a range of nodes has been inserted to the model tree,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove remove}\n * if a range of nodes has been removed from the model tree,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute}\n * if attribute has been added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute},\n * `DowncastDispatcher` generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have a control over which changes has been already consumed. It is useful when some converters\n * overwrite other or converts multiple changes (for example converts insertion of an element and also converts that\n * element's attributes during insertion).\n *\n * Additionally, `DowncastDispatcher` fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} if a marker has been added,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} if a marker has been removed.\n *\n * Note, that changing a marker is done through removing the marker from the old range, and adding on the new range,\n * so both those events are fired.\n *\n * Finally, `DowncastDispatcher` also handles firing events for {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection}\n * which converts selection from model to view,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute}\n * which is fired for every selection attribute,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}\n * which is fired for every marker which contains selection.\n *\n * Unlike model tree and markers, events for selection are not fired for changes but for selection state.\n *\n * When providing custom listeners for `DowncastDispatcher` remember to check whether given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for `DowncastDispatcher` keep in mind that any callback that had\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} a value from a consumable and\n * converted the change should also stop the event (for efficiency purposes).\n *\n * When providing custom listeners for `DowncastDispatcher` remember to use provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * Example of a custom converter for `DowncastDispatcher`:\n *\n *\t\t// We will convert inserting \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate position in model to position in view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create <p> element that will be inserted in view at `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to model element so positions will map accordingly in future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\n *\t\t\t// Remember to stop the event propagation.\n *\t\t\tevt.stop();\n *\t\t} );\n */\n\nexport default class DowncastDispatcher {\n  /**\n   * Creates a `DowncastDispatcher` instance.\n   *\n   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n   * @param {Object} conversionApi Additional properties for interface that will be passed to events fired\n   * by `DowncastDispatcher`.\n   */\n  constructor(conversionApi) {\n    /**\n     * Interface passed by dispatcher to the events callbacks.\n     *\n     * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n     */\n    this.conversionApi = extend({\n      dispatcher: this\n    }, conversionApi);\n  }\n  /**\n   * Takes {@link module:engine/model/differ~Differ model differ} object with buffered changes and fires conversion basing on it.\n   *\n   * @param {module:engine/model/differ~Differ} differ Differ object with buffered changes.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with converted model.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertChanges(differ, markers, writer) {\n    // Before the view is updated, remove markers which have changed.\n    for (const change of differ.getMarkersToRemove()) {\n      this.convertMarkerRemove(change.name, change.range, writer);\n    } // Convert changes that happened on model tree.\n\n\n    for (const entry of differ.getChanges()) {\n      if (entry.type == 'insert') {\n        this.convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), writer);\n      } else if (entry.type == 'remove') {\n        this.convertRemove(entry.position, entry.length, entry.name, writer);\n      } else {\n        // entry.type == 'attribute'.\n        this.convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, writer);\n      }\n    }\n\n    for (const markerName of this.conversionApi.mapper.flushUnboundMarkerNames()) {\n      const markerRange = markers.get(markerName).getRange();\n      this.convertMarkerRemove(markerName, markerRange, writer);\n      this.convertMarkerAdd(markerName, markerRange, writer);\n    } // After the view is updated, convert markers which have changed.\n\n\n    for (const change of differ.getMarkersToAdd()) {\n      this.convertMarkerAdd(change.name, change.range, writer);\n    }\n  }\n  /**\n   * Starts conversion of a range insertion.\n   *\n   * For each node in the range, {@link #event:insert insert event is fired}. For each attribute on each node,\n   * {@link #event:attribute attribute event is fired}.\n   *\n   * @fires insert\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range Inserted range.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertInsert(range, writer) {\n    this.conversionApi.writer = writer; // Create a list of things that can be consumed, consisting of nodes and their attributes.\n\n    this.conversionApi.consumable = this._createInsertConsumable(range); // Fire a separate insert event for each node and text fragment contained in the range.\n\n    for (const value of range) {\n      const item = value.item;\n\n      const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n\n      const data = {\n        item,\n        range: itemRange\n      };\n\n      this._testAndFire('insert', data); // Fire a separate addAttribute event for each attribute that was set on inserted items.\n      // This is important because most attributes converters will listen only to add/change/removeAttribute events.\n      // If we would not add this part, attributes on inserted nodes would not be converted.\n\n\n      for (const key of item.getAttributeKeys()) {\n        data.attributeKey = key;\n        data.attributeOldValue = null;\n        data.attributeNewValue = item.getAttribute(key);\n\n        this._testAndFire(`attribute:${key}`, data);\n      }\n    }\n\n    this._clearConversionApi();\n  }\n  /**\n   * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n   *\n   * @param {module:engine/model/position~Position} position Position from which node was removed.\n   * @param {Number} length Offset size of removed node.\n   * @param {String} name Name of removed node.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertRemove(position, length, name, writer) {\n    this.conversionApi.writer = writer;\n    this.fire('remove:' + name, {\n      position,\n      length\n    }, this.conversionApi);\n\n    this._clearConversionApi();\n  }\n  /**\n   * Starts conversion of attribute change on given `range`.\n   *\n   * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n   *\n   * @fires attribute\n   * @param {module:engine/model/range~Range} range Changed range.\n   * @param {String} key Key of the attribute that has changed.\n   * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n   * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertAttribute(range, key, oldValue, newValue, writer) {\n    this.conversionApi.writer = writer; // Create a list with attributes to consume.\n\n    this.conversionApi.consumable = this._createConsumableForRange(range, `attribute:${key}`); // Create a separate attribute event for each node in the range.\n\n    for (const value of range) {\n      const item = value.item;\n\n      const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);\n\n      const data = {\n        item,\n        range: itemRange,\n        attributeKey: key,\n        attributeOldValue: oldValue,\n        attributeNewValue: newValue\n      };\n\n      this._testAndFire(`attribute:${key}`, data);\n    }\n\n    this._clearConversionApi();\n  }\n  /**\n   * Starts model selection conversion.\n   *\n   * Fires events for given {@link module:engine/model/selection~Selection selection} to start selection conversion.\n   *\n   * @fires selection\n   * @fires addMarker\n   * @fires attribute\n   * @param {module:engine/model/selection~Selection} selection Selection to convert.\n   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with converted model.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertSelection(selection, markers, writer) {\n    const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));\n    this.conversionApi.writer = writer;\n    this.conversionApi.consumable = this._createSelectionConsumable(selection, markersAtSelection);\n    this.fire('selection', {\n      selection\n    }, this.conversionApi);\n\n    if (!selection.isCollapsed) {\n      return;\n    }\n\n    for (const marker of markersAtSelection) {\n      const markerRange = marker.getRange();\n\n      if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, this.conversionApi.mapper)) {\n        continue;\n      }\n\n      const data = {\n        item: selection,\n        markerName: marker.name,\n        markerRange\n      };\n\n      if (this.conversionApi.consumable.test(selection, 'addMarker:' + marker.name)) {\n        this.fire('addMarker:' + marker.name, data, this.conversionApi);\n      }\n    }\n\n    for (const key of selection.getAttributeKeys()) {\n      const data = {\n        item: selection,\n        range: selection.getFirstRange(),\n        attributeKey: key,\n        attributeOldValue: null,\n        attributeNewValue: selection.getAttribute(key)\n      }; // Do not fire event if the attribute has been consumed.\n\n      if (this.conversionApi.consumable.test(selection, 'attribute:' + data.attributeKey)) {\n        this.fire('attribute:' + data.attributeKey + ':$text', data, this.conversionApi);\n      }\n    }\n\n    this._clearConversionApi();\n  }\n  /**\n   * Converts added marker. Fires {@link #event:addMarker addMarker} event for each item\n   * in marker's range. If range is collapsed single event is dispatched. See event description for more details.\n   *\n   * @fires addMarker\n   * @param {String} markerName Marker name.\n   * @param {module:engine/model/range~Range} markerRange Marker range.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertMarkerAdd(markerName, markerRange, writer) {\n    // Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).\n    if (!markerRange.root.document || markerRange.root.rootName == '$graveyard') {\n      return;\n    }\n\n    this.conversionApi.writer = writer; // In markers' case, event name == consumable name.\n\n    const eventName = 'addMarker:' + markerName; //\n    // First, fire an event for the whole marker.\n    //\n\n    const consumable = new Consumable();\n    consumable.add(markerRange, eventName);\n    this.conversionApi.consumable = consumable;\n    this.fire(eventName, {\n      markerName,\n      markerRange\n    }, this.conversionApi); //\n    // Do not fire events for each item inside the range if the range got consumed.\n    //\n\n    if (!consumable.test(markerRange, eventName)) {\n      return;\n    } //\n    // Then, fire an event for each item inside the marker range.\n    //\n\n\n    this.conversionApi.consumable = this._createConsumableForRange(markerRange, eventName);\n\n    for (const item of markerRange.getItems()) {\n      // Do not fire event for already consumed items.\n      if (!this.conversionApi.consumable.test(item, eventName)) {\n        continue;\n      }\n\n      const data = {\n        item,\n        range: Range._createOn(item),\n        markerName,\n        markerRange\n      };\n      this.fire(eventName, data, this.conversionApi);\n    }\n\n    this._clearConversionApi();\n  }\n  /**\n   * Fires conversion of marker removal. Fires {@link #event:removeMarker removeMarker} event with provided data.\n   *\n   * @fires removeMarker\n   * @param {String} markerName Marker name.\n   * @param {module:engine/model/range~Range} markerRange Marker range.\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n   */\n\n\n  convertMarkerRemove(markerName, markerRange, writer) {\n    // Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).\n    if (!markerRange.root.document || markerRange.root.rootName == '$graveyard') {\n      return;\n    }\n\n    this.conversionApi.writer = writer;\n    this.fire('removeMarker:' + markerName, {\n      markerName,\n      markerRange\n    }, this.conversionApi);\n\n    this._clearConversionApi();\n  }\n  /**\n   * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from given range,\n   * assuming that the range has just been inserted to the model.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range Inserted range.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n   */\n\n\n  _createInsertConsumable(range) {\n    const consumable = new Consumable();\n\n    for (const value of range) {\n      const item = value.item;\n      consumable.add(item, 'insert');\n\n      for (const key of item.getAttributeKeys()) {\n        consumable.add(item, 'attribute:' + key);\n      }\n    }\n\n    return consumable;\n  }\n  /**\n   * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for given range.\n   *\n   * @private\n   * @param {module:engine/model/range~Range} range Affected range.\n   * @param {String} type Consumable type.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n   */\n\n\n  _createConsumableForRange(range, type) {\n    const consumable = new Consumable();\n\n    for (const item of range.getItems()) {\n      consumable.add(item, type);\n    }\n\n    return consumable;\n  }\n  /**\n   * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n   *\n   * @private\n   * @param {module:engine/model/selection~Selection} selection Selection to create consumable from.\n   * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers which contains selection.\n   * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n   */\n\n\n  _createSelectionConsumable(selection, markers) {\n    const consumable = new Consumable();\n    consumable.add(selection, 'selection');\n\n    for (const marker of markers) {\n      consumable.add(selection, 'addMarker:' + marker.name);\n    }\n\n    for (const key of selection.getAttributeKeys()) {\n      consumable.add(selection, 'attribute:' + key);\n    }\n\n    return consumable;\n  }\n  /**\n   * Tests passed `consumable` to check whether given event can be fired and if so, fires it.\n   *\n   * @private\n   * @fires insert\n   * @fires attribute\n   * @param {String} type Event type.\n   * @param {Object} data Event data.\n   */\n\n\n  _testAndFire(type, data) {\n    if (!this.conversionApi.consumable.test(data.item, type)) {\n      // Do not fire event if the item was consumed.\n      return;\n    }\n\n    const name = data.item.name || '$text';\n    this.fire(type + ':' + name, data, this.conversionApi);\n  }\n  /**\n   * Clears conversion API object.\n   *\n   * @private\n   */\n\n\n  _clearConversionApi() {\n    delete this.conversionApi.writer;\n    delete this.conversionApi.consumable;\n  }\n  /**\n   * Fired for inserted nodes.\n   *\n   * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n   * or {@link module:engine/model/element~Element#name name} of inserted element.\n   *\n   * This way listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n   *\n   * @event insert\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item} data.item Inserted item.\n   * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired for removed nodes.\n   *\n   * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `remove:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been removed,\n   * or the {@link module:engine/model/element~Element#name name} of removed element.\n   *\n   * This way listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n   *\n   * @event remove\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.\n   * @param {Number} data.length Offset size of the removed node.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired in the following cases:\n   *\n   * * when an attribute has been added, changed, or removed from a node,\n   * * when a node with an attribute is inserted,\n   * * when collapsed model selection attribute is converted.\n   *\n   * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n   * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n   * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n   *\n   * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:image`).\n   *\n   * @event attribute\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n   * or converted selection.\n   * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n   * @param {String} data.attributeKey Attribute key.\n   * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n   * @param {*} data.attributeNewValue New attribute value.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired for {@link module:engine/model/selection~Selection selection} changes.\n   *\n   * @event selection\n   * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired when a new marker is added to the model. Also fired when collapsed model selection that is inside marker is converted.\n   *\n   * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n   * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n   * `addMarker:foo:bar` events.\n   *\n   * If the marker range is not collapsed:\n   *\n   * * the event is fired for each item in the marker range one by one,\n   * * `conversionApi.consumable` includes each item of the marker range and the consumable value is same as event name.\n   *\n   * If the marker range is collapsed:\n   *\n   * * there is only one event,\n   * * `conversionApi.consumable` includes marker range with event name.\n   *\n   * If selection inside a marker is converted:\n   *\n   * * there is only one event,\n   * * `conversionApi.consumable` includes selection instance with event name.\n   *\n   * @event addMarker\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n   * the selection that is being converted.\n   * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n   * the marker range was not collapsed.\n   * @param {module:engine/model/range~Range} data.markerRange Marker range.\n   * @param {String} data.markerName Marker name.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n  /**\n   * Fired when marker is removed from the model.\n   *\n   * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n   * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n   * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n   * `removeMarker:foo:bar` events.\n   *\n   * @event removeMarker\n   * @param {Object} data Additional information about the change.\n   * @param {module:engine/model/range~Range} data.markerRange Marker range.\n   * @param {String} data.markerName Marker name.\n   * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n   * to be used by callback, passed in `DowncastDispatcher` constructor.\n   */\n\n\n}\nmix(DowncastDispatcher, EmitterMixin); // Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\n\nfunction shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {\n  const range = marker.getRange();\n  const ancestors = Array.from(modelPosition.getAncestors());\n  ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\n  ancestors.reverse();\n  const hasCustomHandling = ancestors.some(element => {\n    if (range.containsItem(element)) {\n      const viewElement = mapper.toViewElement(element);\n      return !!viewElement.getCustomProperty('addHighlight');\n    }\n  });\n  return !hasCustomHandling;\n}\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi\n */\n\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n\n/**\n * Stores information about what parts of processed model item are still waiting to be handled. After a piece of model item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js"],"names":["Consumable","Range","EmitterMixin","mix","extend","DowncastDispatcher","constructor","conversionApi","dispatcher","convertChanges","differ","markers","writer","change","getMarkersToRemove","convertMarkerRemove","name","range","entry","getChanges","type","convertInsert","_createFromPositionAndShift","position","length","convertRemove","convertAttribute","attributeKey","attributeOldValue","attributeNewValue","markerName","mapper","flushUnboundMarkerNames","markerRange","get","getRange","convertMarkerAdd","getMarkersToAdd","consumable","_createInsertConsumable","value","item","itemRange","previousPosition","data","_testAndFire","key","getAttributeKeys","getAttribute","_clearConversionApi","fire","oldValue","newValue","_createConsumableForRange","convertSelection","selection","markersAtSelection","Array","from","getMarkersAtPosition","getFirstPosition","_createSelectionConsumable","isCollapsed","marker","shouldMarkerChangeBeConverted","test","getFirstRange","root","document","rootName","eventName","add","getItems","_createOn","modelPosition","ancestors","getAncestors","shift","reverse","hasCustomHandling","some","element","containsItem","viewElement","toViewElement","getCustomProperty"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/downcastdispatcher\n */\n\nimport Consumable from './modelconsumable';\nimport Range from '../model/range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { extend } from 'lodash-es';\n\n/**\n * `DowncastDispatcher` is a central point of downcasting (conversion from model to view), which is a process of reacting to changes\n * in the model and firing a set of events. Callbacks listening to those events are called converters. Those\n * converters role is to convert the model changes to changes in view (for example, adding view nodes or\n * changing attributes on view elements).\n *\n * During conversion process, `DowncastDispatcher` fires events, basing on state of the model and prepares\n * data for those events. It is important to understand that those events are connected with changes done on model,\n * for example: \"node has been inserted\" or \"attribute has changed\". This is in a contrary to upcasting (view to model conversion),\n * where we convert view state (view nodes) to a model tree.\n *\n * The events are prepared basing on a diff created by {@link module:engine/model/differ~Differ Differ}, which buffers them\n * and then passes to `DowncastDispatcher` as a diff between old model state and new model state.\n *\n * Note, that because changes are converted there is a need to have a mapping between model structure and view structure.\n * To map positions and elements during downcast (model to view conversion) use {@link module:engine/conversion/mapper~Mapper}.\n *\n * `DowncastDispatcher` fires following events for model tree changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}\n * if a range of nodes has been inserted to the model tree,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove remove}\n * if a range of nodes has been removed from the model tree,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute}\n * if attribute has been added, changed or removed from a model node.\n *\n * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}\n * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute},\n * `DowncastDispatcher` generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.\n * These are used to have a control over which changes has been already consumed. It is useful when some converters\n * overwrite other or converts multiple changes (for example converts insertion of an element and also converts that\n * element's attributes during insertion).\n *\n * Additionally, `DowncastDispatcher` fires events for {@link module:engine/model/markercollection~Marker marker} changes:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} if a marker has been added,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} if a marker has been removed.\n *\n * Note, that changing a marker is done through removing the marker from the old range, and adding on the new range,\n * so both those events are fired.\n *\n * Finally, `DowncastDispatcher` also handles firing events for {@link module:engine/model/selection model selection}\n * conversion:\n *\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection}\n * which converts selection from model to view,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute}\n * which is fired for every selection attribute,\n * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}\n * which is fired for every marker which contains selection.\n *\n * Unlike model tree and markers, events for selection are not fired for changes but for selection state.\n *\n * When providing custom listeners for `DowncastDispatcher` remember to check whether given change has not been\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.\n *\n * When providing custom listeners for `DowncastDispatcher` keep in mind that any callback that had\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} a value from a consumable and\n * converted the change should also stop the event (for efficiency purposes).\n *\n * When providing custom listeners for `DowncastDispatcher` remember to use provided\n * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.\n *\n * Example of a custom converter for `DowncastDispatcher`:\n *\n *\t\t// We will convert inserting \"paragraph\" model element into the model.\n *\t\tdowncastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {\n *\t\t\t// Remember to check whether the change has not been consumed yet and consume it.\n *\t\t\tif ( conversionApi.consumable.consume( data.item, 'insert' ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\t// Translate position in model to position in view.\n *\t\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\n *\t\t\t// Create <p> element that will be inserted in view at `viewPosition`.\n *\t\t\tconst viewElement = conversionApi.writer.createContainerElement( 'p' );\n *\n *\t\t\t// Bind the newly created view element to model element so positions will map accordingly in future.\n *\t\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n *\n *\t\t\t// Add the newly created view element to the view.\n *\t\t\tconversionApi.writer.insert( viewPosition, viewElement );\n *\n *\t\t\t// Remember to stop the event propagation.\n *\t\t\tevt.stop();\n *\t\t} );\n */\nexport default class DowncastDispatcher {\n\t/**\n\t * Creates a `DowncastDispatcher` instance.\n\t *\n\t * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi\n\t * @param {Object} conversionApi Additional properties for interface that will be passed to events fired\n\t * by `DowncastDispatcher`.\n\t */\n\tconstructor( conversionApi ) {\n\t\t/**\n\t\t * Interface passed by dispatcher to the events callbacks.\n\t\t *\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}\n\t\t */\n\t\tthis.conversionApi = extend( { dispatcher: this }, conversionApi );\n\t}\n\n\t/**\n\t * Takes {@link module:engine/model/differ~Differ model differ} object with buffered changes and fires conversion basing on it.\n\t *\n\t * @param {module:engine/model/differ~Differ} differ Differ object with buffered changes.\n\t * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with converted model.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertChanges( differ, markers, writer ) {\n\t\t// Before the view is updated, remove markers which have changed.\n\t\tfor ( const change of differ.getMarkersToRemove() ) {\n\t\t\tthis.convertMarkerRemove( change.name, change.range, writer );\n\t\t}\n\n\t\t// Convert changes that happened on model tree.\n\t\tfor ( const entry of differ.getChanges() ) {\n\t\t\tif ( entry.type == 'insert' ) {\n\t\t\t\tthis.convertInsert( Range._createFromPositionAndShift( entry.position, entry.length ), writer );\n\t\t\t} else if ( entry.type == 'remove' ) {\n\t\t\t\tthis.convertRemove( entry.position, entry.length, entry.name, writer );\n\t\t\t} else {\n\t\t\t\t// entry.type == 'attribute'.\n\t\t\t\tthis.convertAttribute( entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, writer );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const markerName of this.conversionApi.mapper.flushUnboundMarkerNames() ) {\n\t\t\tconst markerRange = markers.get( markerName ).getRange();\n\n\t\t\tthis.convertMarkerRemove( markerName, markerRange, writer );\n\t\t\tthis.convertMarkerAdd( markerName, markerRange, writer );\n\t\t}\n\n\t\t// After the view is updated, convert markers which have changed.\n\t\tfor ( const change of differ.getMarkersToAdd() ) {\n\t\t\tthis.convertMarkerAdd( change.name, change.range, writer );\n\t\t}\n\t}\n\n\t/**\n\t * Starts conversion of a range insertion.\n\t *\n\t * For each node in the range, {@link #event:insert insert event is fired}. For each attribute on each node,\n\t * {@link #event:attribute attribute event is fired}.\n\t *\n\t * @fires insert\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range Inserted range.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertInsert( range, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create a list of things that can be consumed, consisting of nodes and their attributes.\n\t\tthis.conversionApi.consumable = this._createInsertConsumable( range );\n\n\t\t// Fire a separate insert event for each node and text fragment contained in the range.\n\t\tfor ( const value of range ) {\n\t\t\tconst item = value.item;\n\t\t\tconst itemRange = Range._createFromPositionAndShift( value.previousPosition, value.length );\n\t\t\tconst data = {\n\t\t\t\titem,\n\t\t\t\trange: itemRange\n\t\t\t};\n\n\t\t\tthis._testAndFire( 'insert', data );\n\n\t\t\t// Fire a separate addAttribute event for each attribute that was set on inserted items.\n\t\t\t// This is important because most attributes converters will listen only to add/change/removeAttribute events.\n\t\t\t// If we would not add this part, attributes on inserted nodes would not be converted.\n\t\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\t\tdata.attributeKey = key;\n\t\t\t\tdata.attributeOldValue = null;\n\t\t\t\tdata.attributeNewValue = item.getAttribute( key );\n\n\t\t\t\tthis._testAndFire( `attribute:${ key }`, data );\n\t\t\t}\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.\n\t *\n\t * @param {module:engine/model/position~Position} position Position from which node was removed.\n\t * @param {Number} length Offset size of removed node.\n\t * @param {String} name Name of removed node.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertRemove( position, length, name, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\tthis.fire( 'remove:' + name, { position, length }, this.conversionApi );\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Starts conversion of attribute change on given `range`.\n\t *\n\t * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.\n\t *\n\t * @fires attribute\n\t * @param {module:engine/model/range~Range} range Changed range.\n\t * @param {String} key Key of the attribute that has changed.\n\t * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.\n\t * @param {*} newValue New attribute value or `null` if the attribute has been removed.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertAttribute( range, key, oldValue, newValue, writer ) {\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create a list with attributes to consume.\n\t\tthis.conversionApi.consumable = this._createConsumableForRange( range, `attribute:${ key }` );\n\n\t\t// Create a separate attribute event for each node in the range.\n\t\tfor ( const value of range ) {\n\t\t\tconst item = value.item;\n\t\t\tconst itemRange = Range._createFromPositionAndShift( value.previousPosition, value.length );\n\t\t\tconst data = {\n\t\t\t\titem,\n\t\t\t\trange: itemRange,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\tattributeNewValue: newValue\n\t\t\t};\n\n\t\t\tthis._testAndFire( `attribute:${ key }`, data );\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Starts model selection conversion.\n\t *\n\t * Fires events for given {@link module:engine/model/selection~Selection selection} to start selection conversion.\n\t *\n\t * @fires selection\n\t * @fires addMarker\n\t * @fires attribute\n\t * @param {module:engine/model/selection~Selection} selection Selection to convert.\n\t * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with converted model.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertSelection( selection, markers, writer ) {\n\t\tconst markersAtSelection = Array.from( markers.getMarkersAtPosition( selection.getFirstPosition() ) );\n\n\t\tthis.conversionApi.writer = writer;\n\t\tthis.conversionApi.consumable = this._createSelectionConsumable( selection, markersAtSelection );\n\n\t\tthis.fire( 'selection', { selection }, this.conversionApi );\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const marker of markersAtSelection ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tif ( !shouldMarkerChangeBeConverted( selection.getFirstPosition(), marker, this.conversionApi.mapper ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = {\n\t\t\t\titem: selection,\n\t\t\t\tmarkerName: marker.name,\n\t\t\t\tmarkerRange\n\t\t\t};\n\n\t\t\tif ( this.conversionApi.consumable.test( selection, 'addMarker:' + marker.name ) ) {\n\t\t\t\tthis.fire( 'addMarker:' + marker.name, data, this.conversionApi );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of selection.getAttributeKeys() ) {\n\t\t\tconst data = {\n\t\t\t\titem: selection,\n\t\t\t\trange: selection.getFirstRange(),\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: selection.getAttribute( key )\n\t\t\t};\n\n\t\t\t// Do not fire event if the attribute has been consumed.\n\t\t\tif ( this.conversionApi.consumable.test( selection, 'attribute:' + data.attributeKey ) ) {\n\t\t\t\tthis.fire( 'attribute:' + data.attributeKey + ':$text', data, this.conversionApi );\n\t\t\t}\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Converts added marker. Fires {@link #event:addMarker addMarker} event for each item\n\t * in marker's range. If range is collapsed single event is dispatched. See event description for more details.\n\t *\n\t * @fires addMarker\n\t * @param {String} markerName Marker name.\n\t * @param {module:engine/model/range~Range} markerRange Marker range.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertMarkerAdd( markerName, markerRange, writer ) {\n\t\t// Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).\n\t\tif ( !markerRange.root.document || markerRange.root.rootName == '$graveyard' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// In markers' case, event name == consumable name.\n\t\tconst eventName = 'addMarker:' + markerName;\n\n\t\t//\n\t\t// First, fire an event for the whole marker.\n\t\t//\n\t\tconst consumable = new Consumable();\n\t\tconsumable.add( markerRange, eventName );\n\n\t\tthis.conversionApi.consumable = consumable;\n\n\t\tthis.fire( eventName, { markerName, markerRange }, this.conversionApi );\n\n\t\t//\n\t\t// Do not fire events for each item inside the range if the range got consumed.\n\t\t//\n\t\tif ( !consumable.test( markerRange, eventName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t//\n\t\t// Then, fire an event for each item inside the marker range.\n\t\t//\n\t\tthis.conversionApi.consumable = this._createConsumableForRange( markerRange, eventName );\n\n\t\tfor ( const item of markerRange.getItems() ) {\n\t\t\t// Do not fire event for already consumed items.\n\t\t\tif ( !this.conversionApi.consumable.test( item, eventName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = { item, range: Range._createOn( item ), markerName, markerRange };\n\n\t\t\tthis.fire( eventName, data, this.conversionApi );\n\t\t}\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Fires conversion of marker removal. Fires {@link #event:removeMarker removeMarker} event with provided data.\n\t *\n\t * @fires removeMarker\n\t * @param {String} markerName Marker name.\n\t * @param {module:engine/model/range~Range} markerRange Marker range.\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.\n\t */\n\tconvertMarkerRemove( markerName, markerRange, writer ) {\n\t\t// Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).\n\t\tif ( !markerRange.root.document || markerRange.root.rootName == '$graveyard' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.conversionApi.writer = writer;\n\n\t\tthis.fire( 'removeMarker:' + markerName, { markerName, markerRange }, this.conversionApi );\n\n\t\tthis._clearConversionApi();\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from given range,\n\t * assuming that the range has just been inserted to the model.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range Inserted range.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n\t */\n\t_createInsertConsumable( range ) {\n\t\tconst consumable = new Consumable();\n\n\t\tfor ( const value of range ) {\n\t\t\tconst item = value.item;\n\n\t\t\tconsumable.add( item, 'insert' );\n\n\t\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\t\tconsumable.add( item, 'attribute:' + key );\n\t\t\t}\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for given range.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range Affected range.\n\t * @param {String} type Consumable type.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n\t */\n\t_createConsumableForRange( range, type ) {\n\t\tconst consumable = new Consumable();\n\n\t\tfor ( const item of range.getItems() ) {\n\t\t\tconsumable.add( item, type );\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.\n\t *\n\t * @private\n\t * @param {module:engine/model/selection~Selection} selection Selection to create consumable from.\n\t * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers which contains selection.\n\t * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.\n\t */\n\t_createSelectionConsumable( selection, markers ) {\n\t\tconst consumable = new Consumable();\n\n\t\tconsumable.add( selection, 'selection' );\n\n\t\tfor ( const marker of markers ) {\n\t\t\tconsumable.add( selection, 'addMarker:' + marker.name );\n\t\t}\n\n\t\tfor ( const key of selection.getAttributeKeys() ) {\n\t\t\tconsumable.add( selection, 'attribute:' + key );\n\t\t}\n\n\t\treturn consumable;\n\t}\n\n\t/**\n\t * Tests passed `consumable` to check whether given event can be fired and if so, fires it.\n\t *\n\t * @private\n\t * @fires insert\n\t * @fires attribute\n\t * @param {String} type Event type.\n\t * @param {Object} data Event data.\n\t */\n\t_testAndFire( type, data ) {\n\t\tif ( !this.conversionApi.consumable.test( data.item, type ) ) {\n\t\t\t// Do not fire event if the item was consumed.\n\t\t\treturn;\n\t\t}\n\n\t\tconst name = data.item.name || '$text';\n\n\t\tthis.fire( type + ':' + name, data, this.conversionApi );\n\t}\n\n\t/**\n\t * Clears conversion API object.\n\t *\n\t * @private\n\t */\n\t_clearConversionApi() {\n\t\tdelete this.conversionApi.writer;\n\t\tdelete this.conversionApi.consumable;\n\t}\n\n\t/**\n\t * Fired for inserted nodes.\n\t *\n\t * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,\n\t * or {@link module:engine/model/element~Element#name name} of inserted element.\n\t *\n\t * This way listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).\n\t *\n\t * @event insert\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item} data.item Inserted item.\n\t * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired for removed nodes.\n\t *\n\t * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `remove:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been removed,\n\t * or the {@link module:engine/model/element~Element#name name} of removed element.\n\t *\n\t * This way listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).\n\t *\n\t * @event remove\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.\n\t * @param {Number} data.length Offset size of the removed node.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired in the following cases:\n\t *\n\t * * when an attribute has been added, changed, or removed from a node,\n\t * * when a node with an attribute is inserted,\n\t * * when collapsed model selection attribute is converted.\n\t *\n\t * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.\n\t * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},\n\t * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.\n\t *\n\t * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:image`).\n\t *\n\t * @event attribute\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item\n\t * or converted selection.\n\t * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.\n\t * @param {String} data.attributeKey Attribute key.\n\t * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.\n\t * @param {*} data.attributeNewValue New attribute value.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired for {@link module:engine/model/selection~Selection selection} changes.\n\t *\n\t * @event selection\n\t * @param {module:engine/model/selection~Selection} selection Selection that is converted.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when a new marker is added to the model. Also fired when collapsed model selection that is inside marker is converted.\n\t *\n\t * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n\t * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and\n\t * `addMarker:foo:bar` events.\n\t *\n\t * If the marker range is not collapsed:\n\t *\n\t * * the event is fired for each item in the marker range one by one,\n\t * * `conversionApi.consumable` includes each item of the marker range and the consumable value is same as event name.\n\t *\n\t * If the marker range is collapsed:\n\t *\n\t * * there is only one event,\n\t * * `conversionApi.consumable` includes marker range with event name.\n\t *\n\t * If selection inside a marker is converted:\n\t *\n\t * * there is only one event,\n\t * * `conversionApi.consumable` includes selection instance with event name.\n\t *\n\t * @event addMarker\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or\n\t * the selection that is being converted.\n\t * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if\n\t * the marker range was not collapsed.\n\t * @param {module:engine/model/range~Range} data.markerRange Marker range.\n\t * @param {String} data.markerName Marker name.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n\n\t/**\n\t * Fired when marker is removed from the model.\n\t *\n\t * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:\n\t * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,\n\t * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and\n\t * `removeMarker:foo:bar` events.\n\t *\n\t * @event removeMarker\n\t * @param {Object} data Additional information about the change.\n\t * @param {module:engine/model/range~Range} data.markerRange Marker range.\n\t * @param {String} data.markerName Marker name.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface\n\t * to be used by callback, passed in `DowncastDispatcher` constructor.\n\t */\n}\n\nmix( DowncastDispatcher, EmitterMixin );\n\n// Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not\n// converted if they happen inside an element with custom conversion method.\n//\n// @param {module:engine/model/position~Position} modelPosition\n// @param {module:engine/model/markercollection~Marker} marker\n// @param {module:engine/conversion/mapper~Mapper} mapper\n// @returns {Boolean}\nfunction shouldMarkerChangeBeConverted( modelPosition, marker, mapper ) {\n\tconst range = marker.getRange();\n\tconst ancestors = Array.from( modelPosition.getAncestors() );\n\tancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.\n\tancestors.reverse();\n\n\tconst hasCustomHandling = ancestors.some( element => {\n\t\tif ( range.containsItem( element ) ) {\n\t\t\tconst viewElement = mapper.toViewElement( element );\n\n\t\t\treturn !!viewElement.getCustomProperty( 'addHighlight' );\n\t\t}\n\t} );\n\n\treturn !hasCustomHandling;\n}\n\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi\n */\n\n/**\n * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.\n *\n * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher\n */\n\n/**\n * Stores information about what parts of processed model item are still waiting to be handled. After a piece of model item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable\n */\n\n/**\n * The {@link module:engine/conversion/mapper~Mapper} instance.\n *\n * @member {module:engine/conversion/mapper~Mapper} #mapper\n */\n\n/**\n * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate data during conversion.\n *\n * @member {module:engine/view/downcastwriter~DowncastWriter} #writer\n */\n"]},"metadata":{},"sourceType":"module"}