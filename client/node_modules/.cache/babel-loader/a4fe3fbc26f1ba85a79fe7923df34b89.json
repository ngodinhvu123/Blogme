{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { BR_FILLER, getDataWithoutFiller, INLINE_FILLER_LENGTH, isInlineFiller, NBSP_FILLER, startsWithFiller } from './filler';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport { isElement } from 'lodash-es'; // eslint-disable-next-line new-cap\n\nconst BR_FILLER_REF = BR_FILLER(document);\n/**\n * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.\n *\n * The instance of DOMConverter is available in {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a\n * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).\n *\n * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will\n * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\n\nexport default class DomConverter {\n  /**\n   * Creates DOM converter.\n   *\n   * @param {module:engine/view/document~Document} document The view document instance.\n   * @param {Object} options Object with configuration options.\n   * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode='br'] The type of the block filler to use.\n   */\n  constructor(document, options = {}) {\n    /**\n     * @readonly\n     * @type {module:engine/view/document~Document}\n     */\n    this.document = document;\n    /**\n     * The mode of a block filler used by DOM converter.\n     *\n     * @readonly\n     * @member {'br'|'nbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n     */\n\n    this.blockFillerMode = options.blockFillerMode || 'br';\n    /**\n     * Elements which are considered pre-formatted elements.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n     */\n\n    this.preElements = ['pre'];\n    /**\n     * Elements which are considered block elements (and hence should be filled with a\n     * {@link #isBlockFiller block filler}).\n     *\n     * Whether an element is considered a block element also affects handling of trailing whitespaces.\n     *\n     * You can extend this array if you introduce support for block elements which are not yet recognized here.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n     */\n\n    this.blockElements = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'dd', 'dt', 'figcaption'];\n    /**\n     * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the\n     * view to DOM conversion and to recognize block fillers during the DOM to view conversion.\n     *\n     * @readonly\n     * @private\n     * @member {Function} module:engine/view/domconverter~DomConverter#_blockFiller\n     */\n\n    this._blockFiller = this.blockFillerMode == 'br' ? BR_FILLER : NBSP_FILLER;\n    /**\n     * DOM to View mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n     */\n\n    this._domToViewMapping = new WeakMap();\n    /**\n     * View to DOM mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n     */\n\n    this._viewToDomMapping = new WeakMap();\n    /**\n     * Holds mapping between fake selection containers and corresponding view selections.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n     */\n\n    this._fakeSelectionMapping = new WeakMap();\n  }\n  /**\n   * Binds given DOM element that represents fake selection to a **position** of a\n   * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n   * Document selection copy is stored and can be retrieved by\n   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n   *\n   * @param {HTMLElement} domElement\n   * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n   */\n\n\n  bindFakeSelection(domElement, viewDocumentSelection) {\n    this._fakeSelectionMapping.set(domElement, new ViewSelection(viewDocumentSelection));\n  }\n  /**\n   * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to\n   * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.\n   *\n   * @param {HTMLElement} domElement\n   * @returns {module:engine/view/selection~Selection|undefined}\n   */\n\n\n  fakeSelectionToView(domElement) {\n    return this._fakeSelectionMapping.get(domElement);\n  }\n  /**\n   * Binds DOM and View elements, so it will be possible to get corresponding elements using\n   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n   *\n   * @param {HTMLElement} domElement DOM element to bind.\n   * @param {module:engine/view/element~Element} viewElement View element to bind.\n   */\n\n\n  bindElements(domElement, viewElement) {\n    this._domToViewMapping.set(domElement, viewElement);\n\n    this._viewToDomMapping.set(viewElement, domElement);\n  }\n  /**\n   * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of\n   * `domElement` will be unbound too.\n   *\n   * @param {HTMLElement} domElement DOM element to unbind.\n   */\n\n\n  unbindDomElement(domElement) {\n    const viewElement = this._domToViewMapping.get(domElement);\n\n    if (viewElement) {\n      this._domToViewMapping.delete(domElement);\n\n      this._viewToDomMapping.delete(viewElement);\n\n      for (const child of domElement.childNodes) {\n        this.unbindDomElement(child);\n      }\n    }\n  }\n  /**\n   * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using\n   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n   *\n   * @param {DocumentFragment} domFragment DOM document fragment to bind.\n   * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.\n   */\n\n\n  bindDocumentFragments(domFragment, viewFragment) {\n    this._domToViewMapping.set(domFragment, viewFragment);\n\n    this._viewToDomMapping.set(viewFragment, domFragment);\n  }\n  /**\n   * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will\n   * be created. For bound elements and document fragments function will return corresponding items.\n   *\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n   * View node or document fragment to transform.\n   * @param {Document} domDocument Document which will be used to create DOM nodes.\n   * @param {Object} [options] Conversion options.\n   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n   * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n   */\n\n\n  viewToDom(viewNode, domDocument, options = {}) {\n    if (viewNode.is('text')) {\n      const textData = this._processDataFromViewText(viewNode);\n\n      return domDocument.createTextNode(textData);\n    } else {\n      if (this.mapViewToDom(viewNode)) {\n        return this.mapViewToDom(viewNode);\n      }\n\n      let domElement;\n\n      if (viewNode.is('documentFragment')) {\n        // Create DOM document fragment.\n        domElement = domDocument.createDocumentFragment();\n\n        if (options.bind) {\n          this.bindDocumentFragments(domElement, viewNode);\n        }\n      } else if (viewNode.is('uiElement')) {\n        // UIElement has its own render() method (see #799).\n        domElement = viewNode.render(domDocument);\n\n        if (options.bind) {\n          this.bindElements(domElement, viewNode);\n        }\n\n        return domElement;\n      } else {\n        // Create DOM element.\n        if (viewNode.hasAttribute('xmlns')) {\n          domElement = domDocument.createElementNS(viewNode.getAttribute('xmlns'), viewNode.name);\n        } else {\n          domElement = domDocument.createElement(viewNode.name);\n        }\n\n        if (options.bind) {\n          this.bindElements(domElement, viewNode);\n        } // Copy element's attributes.\n\n\n        for (const key of viewNode.getAttributeKeys()) {\n          domElement.setAttribute(key, viewNode.getAttribute(key));\n        }\n      }\n\n      if (options.withChildren || options.withChildren === undefined) {\n        for (const child of this.viewChildrenToDom(viewNode, domDocument, options)) {\n          domElement.appendChild(child);\n        }\n      }\n\n      return domElement;\n    }\n  }\n  /**\n   * Converts children of the view element to DOM using the\n   * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n   * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n   * @param {Document} domDocument Document which will be used to create DOM nodes.\n   * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n   * @returns {Iterable.<Node>} DOM nodes.\n   */\n\n\n  *viewChildrenToDom(viewElement, domDocument, options = {}) {\n    const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n    let offset = 0;\n\n    for (const childView of viewElement.getChildren()) {\n      if (fillerPositionOffset === offset) {\n        yield this._blockFiller(domDocument);\n      }\n\n      yield this.viewToDom(childView, domDocument, options);\n      offset++;\n    }\n\n    if (fillerPositionOffset === offset) {\n      yield this._blockFiller(domDocument);\n    }\n  }\n  /**\n   * Converts view {@link module:engine/view/range~Range} to DOM range.\n   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n   *\n   * @param {module:engine/view/range~Range} viewRange View range.\n   * @returns {Range} DOM range.\n   */\n\n\n  viewRangeToDom(viewRange) {\n    const domStart = this.viewPositionToDom(viewRange.start);\n    const domEnd = this.viewPositionToDom(viewRange.end);\n    const domRange = document.createRange();\n    domRange.setStart(domStart.parent, domStart.offset);\n    domRange.setEnd(domEnd.parent, domEnd.offset);\n    return domRange;\n  }\n  /**\n   * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n   *\n   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n   * If the converted position is directly before inline filler it is moved inside the filler.\n   *\n   * @param {module:engine/view/position~Position} viewPosition View position.\n   * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n   * @returns {Node} position.parent DOM position parent.\n   * @returns {Number} position.offset DOM position offset.\n   */\n\n\n  viewPositionToDom(viewPosition) {\n    const viewParent = viewPosition.parent;\n\n    if (viewParent.is('text')) {\n      const domParent = this.findCorrespondingDomText(viewParent);\n\n      if (!domParent) {\n        // Position is in a view text node that has not been rendered to DOM yet.\n        return null;\n      }\n\n      let offset = viewPosition.offset;\n\n      if (startsWithFiller(domParent)) {\n        offset += INLINE_FILLER_LENGTH;\n      }\n\n      return {\n        parent: domParent,\n        offset\n      };\n    } else {\n      // viewParent is instance of ViewElement.\n      let domParent, domBefore, domAfter;\n\n      if (viewPosition.offset === 0) {\n        domParent = this.mapViewToDom(viewParent);\n\n        if (!domParent) {\n          // Position is in a view element that has not been rendered to DOM yet.\n          return null;\n        }\n\n        domAfter = domParent.childNodes[0];\n      } else {\n        const nodeBefore = viewPosition.nodeBefore;\n        domBefore = nodeBefore.is('text') ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(viewPosition.nodeBefore);\n\n        if (!domBefore) {\n          // Position is after a view element that has not been rendered to DOM yet.\n          return null;\n        }\n\n        domParent = domBefore.parentNode;\n        domAfter = domBefore.nextSibling;\n      } // If there is an inline filler at position return position inside the filler. We should never return\n      // the position before the inline filler.\n\n\n      if (isText(domAfter) && startsWithFiller(domAfter)) {\n        return {\n          parent: domAfter,\n          offset: INLINE_FILLER_LENGTH\n        };\n      }\n\n      const offset = domBefore ? indexOf(domBefore) + 1 : 0;\n      return {\n        parent: domParent,\n        offset\n      };\n    }\n  }\n  /**\n   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n   * be created. For bound elements and document fragments function will return corresponding items. For\n   * {@link module:engine/view/filler fillers} `null` will be returned.\n   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n   *\n   * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n   * @param {Object} [options] Conversion options.\n   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n   * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n   * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n   * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n   */\n\n\n  domToView(domNode, options = {}) {\n    if (this.isBlockFiller(domNode, this.blockFillerMode)) {\n      return null;\n    } // When node is inside UIElement return that UIElement as it's view representation.\n\n\n    const uiElement = this.getParentUIElement(domNode, this._domToViewMapping);\n\n    if (uiElement) {\n      return uiElement;\n    }\n\n    if (isText(domNode)) {\n      if (isInlineFiller(domNode)) {\n        return null;\n      } else {\n        const textData = this._processDataFromDomText(domNode);\n\n        return textData === '' ? null : new ViewText(this.document, textData);\n      }\n    } else if (this.isComment(domNode)) {\n      return null;\n    } else {\n      if (this.mapDomToView(domNode)) {\n        return this.mapDomToView(domNode);\n      }\n\n      let viewElement;\n\n      if (this.isDocumentFragment(domNode)) {\n        // Create view document fragment.\n        viewElement = new ViewDocumentFragment(this.document);\n\n        if (options.bind) {\n          this.bindDocumentFragments(domNode, viewElement);\n        }\n      } else {\n        // Create view element.\n        const viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n        viewElement = new ViewElement(this.document, viewName);\n\n        if (options.bind) {\n          this.bindElements(domNode, viewElement);\n        } // Copy element's attributes.\n\n\n        const attrs = domNode.attributes;\n\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          viewElement._setAttribute(attrs[i].name, attrs[i].value);\n        }\n      }\n\n      if (options.withChildren || options.withChildren === undefined) {\n        for (const child of this.domChildrenToView(domNode, options)) {\n          viewElement._appendChild(child);\n        }\n      }\n\n      return viewElement;\n    }\n  }\n  /**\n   * Converts children of the DOM element to view nodes using\n   * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n   * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n   *\n   * @param {HTMLElement} domElement Parent DOM element.\n   * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n   * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n   */\n\n\n  *domChildrenToView(domElement, options = {}) {\n    for (let i = 0; i < domElement.childNodes.length; i++) {\n      const domChild = domElement.childNodes[i];\n      const viewChild = this.domToView(domChild, options);\n\n      if (viewChild !== null) {\n        yield viewChild;\n      }\n    }\n  }\n  /**\n   * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n   * Ranges which cannot be converted will be omitted.\n   *\n   * @param {Selection} domSelection DOM selection.\n   * @returns {module:engine/view/selection~Selection} View selection.\n   */\n\n\n  domSelectionToView(domSelection) {\n    // DOM selection might be placed in fake selection container.\n    // If container contains fake selection - return corresponding view selection.\n    if (domSelection.rangeCount === 1) {\n      let container = domSelection.getRangeAt(0).startContainer; // The DOM selection might be moved to the text node inside the fake selection container.\n\n      if (isText(container)) {\n        container = container.parentNode;\n      }\n\n      const viewSelection = this.fakeSelectionToView(container);\n\n      if (viewSelection) {\n        return viewSelection;\n      }\n    }\n\n    const isBackward = this.isDomSelectionBackward(domSelection);\n    const viewRanges = [];\n\n    for (let i = 0; i < domSelection.rangeCount; i++) {\n      // DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n      const domRange = domSelection.getRangeAt(i);\n      const viewRange = this.domRangeToView(domRange);\n\n      if (viewRange) {\n        viewRanges.push(viewRange);\n      }\n    }\n\n    return new ViewSelection(viewRanges, {\n      backward: isBackward\n    });\n  }\n  /**\n   * Converts DOM Range to view {@link module:engine/view/range~Range}.\n   * If the start or end position can not be converted `null` is returned.\n   *\n   * @param {Range} domRange DOM range.\n   * @returns {module:engine/view/range~Range|null} View range.\n   */\n\n\n  domRangeToView(domRange) {\n    const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);\n    const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);\n\n    if (viewStart && viewEnd) {\n      return new ViewRange(viewStart, viewEnd);\n    }\n\n    return null;\n  }\n  /**\n   * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n   *\n   * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n   * position of the filler will be converted and returned.\n   *\n   * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n   * that position will be converted to view position before that UIElement.\n   *\n   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n   *\n   * @param {Node} domParent DOM position parent.\n   * @param {Number} domOffset DOM position offset.\n   * @returns {module:engine/view/position~Position} viewPosition View position.\n   */\n\n\n  domPositionToView(domParent, domOffset) {\n    if (this.isBlockFiller(domParent, this.blockFillerMode)) {\n      return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n    } // If position is somewhere inside UIElement - return position before that element.\n\n\n    const viewElement = this.mapDomToView(domParent);\n\n    if (viewElement && viewElement.is('uiElement')) {\n      return ViewPosition._createBefore(viewElement);\n    }\n\n    if (isText(domParent)) {\n      if (isInlineFiller(domParent)) {\n        return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n      }\n\n      const viewParent = this.findCorrespondingViewText(domParent);\n      let offset = domOffset;\n\n      if (!viewParent) {\n        return null;\n      }\n\n      if (startsWithFiller(domParent)) {\n        offset -= INLINE_FILLER_LENGTH;\n        offset = offset < 0 ? 0 : offset;\n      }\n\n      return new ViewPosition(viewParent, offset);\n    } // domParent instanceof HTMLElement.\n    else {\n        if (domOffset === 0) {\n          const viewParent = this.mapDomToView(domParent);\n\n          if (viewParent) {\n            return new ViewPosition(viewParent, 0);\n          }\n        } else {\n          const domBefore = domParent.childNodes[domOffset - 1];\n          const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore); // TODO #663\n\n          if (viewBefore && viewBefore.parent) {\n            return new ViewPosition(viewBefore.parent, viewBefore.index + 1);\n          }\n        }\n\n        return null;\n      }\n  }\n  /**\n   * Returns corresponding view {@link module:engine/view/element~Element Element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n   * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * to the given DOM - `undefined` is returned.\n   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n   *\n   * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n   * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n   * Corresponding view element, document fragment or `undefined` if no element was bound.\n   */\n\n\n  mapDomToView(domElementOrDocumentFragment) {\n    return this.getParentUIElement(domElementOrDocumentFragment) || this._domToViewMapping.get(domElementOrDocumentFragment);\n  }\n  /**\n   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n   * corresponding text node is returned based on the sibling or parent.\n   *\n   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n   * to find the corresponding text node.\n   *\n   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * element, it is used to find the corresponding text node.\n   *\n   * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n   *\n   * Otherwise `null` is returned.\n   *\n   * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n   *\n   * @param {Text} domText DOM text node.\n   * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n   * corresponding node.\n   */\n\n\n  findCorrespondingViewText(domText) {\n    if (isInlineFiller(domText)) {\n      return null;\n    } // If DOM text was rendered by UIElement - return that element.\n\n\n    const uiElement = this.getParentUIElement(domText);\n\n    if (uiElement) {\n      return uiElement;\n    }\n\n    const previousSibling = domText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n    if (previousSibling) {\n      if (!this.isElement(previousSibling)) {\n        // The previous is text or comment.\n        return null;\n      }\n\n      const viewElement = this.mapDomToView(previousSibling);\n\n      if (viewElement) {\n        const nextSibling = viewElement.nextSibling; // It might be filler which has no corresponding view node.\n\n        if (nextSibling instanceof ViewText) {\n          return viewElement.nextSibling;\n        } else {\n          return null;\n        }\n      }\n    } // Try to use parent to find the corresponding text node.\n    else {\n        const viewElement = this.mapDomToView(domText.parentNode);\n\n        if (viewElement) {\n          const firstChild = viewElement.getChild(0); // It might be filler which has no corresponding view node.\n\n          if (firstChild instanceof ViewText) {\n            return firstChild;\n          } else {\n            return null;\n          }\n        }\n      }\n\n    return null;\n  }\n  /**\n   * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n   * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n   * use {@link #findCorrespondingDomText}.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n   * View element or document fragment.\n   * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n   */\n\n\n  mapViewToDom(documentFragmentOrElement) {\n    return this._viewToDomMapping.get(documentFragmentOrElement);\n  }\n  /**\n   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n   * corresponding text node is returned based on the sibling or parent.\n   *\n   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n   * to find the corresponding text node.\n   *\n   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * element, it is used to find the corresponding text node.\n   *\n   * Otherwise `null` is returned.\n   *\n   * @param {module:engine/view/text~Text} viewText View text node.\n   * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n   */\n\n\n  findCorrespondingDomText(viewText) {\n    const previousSibling = viewText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n    if (previousSibling && this.mapViewToDom(previousSibling)) {\n      return this.mapViewToDom(previousSibling).nextSibling;\n    } // If this is a first node, try to use parent to find the corresponding text node.\n\n\n    if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {\n      return this.mapViewToDom(viewText.parent).childNodes[0];\n    }\n\n    return null;\n  }\n  /**\n   * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n   *\n   * @param {module:engine/view/editableelement~EditableElement} viewEditable\n   */\n\n\n  focus(viewEditable) {\n    const domEditable = this.mapViewToDom(viewEditable);\n\n    if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {\n      // Save the scrollX and scrollY positions before the focus.\n      const {\n        scrollX,\n        scrollY\n      } = global.window;\n      const scrollPositions = []; // Save all scrollLeft and scrollTop values starting from domEditable up to\n      // document#documentElement.\n\n      forEachDomNodeAncestor(domEditable, node => {\n        const {\n          scrollLeft,\n          scrollTop\n        } = node;\n        scrollPositions.push([scrollLeft, scrollTop]);\n      });\n      domEditable.focus(); // Restore scrollLeft and scrollTop values starting from domEditable up to\n      // document#documentElement.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/951\n      // https://github.com/ckeditor/ckeditor5-engine/issues/957\n\n      forEachDomNodeAncestor(domEditable, node => {\n        const [scrollLeft, scrollTop] = scrollPositions.shift();\n        node.scrollLeft = scrollLeft;\n        node.scrollTop = scrollTop;\n      }); // Restore the scrollX and scrollY positions after the focus.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/951\n\n      global.window.scrollTo(scrollX, scrollY);\n    }\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isElement(node) {\n    return node && node.nodeType == Node.ELEMENT_NODE;\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isDocumentFragment(node) {\n    return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isComment(node) {\n    return node && node.nodeType == Node.COMMENT_NODE;\n  }\n  /**\n   * Checks if the node is an instance of the block filler for this DOM converter.\n   *\n   *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n   *\n   *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n   *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n   *\n   * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n   *\n   * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n   *\n   * @param {Node} domNode DOM node to check.\n   * @returns {Boolean} True if a node is considered a block filler for given mode.\n   */\n\n\n  isBlockFiller(domNode) {\n    if (this.blockFillerMode == 'br') {\n      return domNode.isEqualNode(BR_FILLER_REF);\n    } // Special case for <p><br></p> in which case the <br> should be treated as filler even\n    // when we're in the 'nbsp' mode. See ckeditor5#5564.\n\n\n    if (domNode.tagName === 'BR' && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {\n      return true;\n    }\n\n    return isNbspBlockFiller(domNode, this.blockElements);\n  }\n  /**\n   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n   *\n   * @param {Selection} DOM Selection instance to check.\n   * @returns {Boolean}\n   */\n\n\n  isDomSelectionBackward(selection) {\n    if (selection.isCollapsed) {\n      return false;\n    } // Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n    // we will use the fact that range will collapse if it's end is before it's start.\n\n\n    const range = document.createRange();\n    range.setStart(selection.anchorNode, selection.anchorOffset);\n    range.setEnd(selection.focusNode, selection.focusOffset);\n    const backward = range.collapsed;\n    range.detach();\n    return backward;\n  }\n  /**\n   * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no\n   * parent UIElement.\n   *\n   * @param {Node} domNode\n   * @returns {module:engine/view/uielement~UIElement|null}\n   */\n\n\n  getParentUIElement(domNode) {\n    const ancestors = getAncestors(domNode); // Remove domNode from the list.\n\n    ancestors.pop();\n\n    while (ancestors.length) {\n      const domNode = ancestors.pop();\n\n      const viewNode = this._domToViewMapping.get(domNode);\n\n      if (viewNode && viewNode.is('uiElement')) {\n        return viewNode;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Checks if given selection's boundaries are at correct places.\n   *\n   * The following places are considered as incorrect for selection boundaries:\n   * * before or in the middle of the inline filler sequence,\n   * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.\n   *\n   * @param {Selection} domSelection DOM Selection object to be checked.\n   * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n   */\n\n\n  isDomSelectionCorrect(domSelection) {\n    return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);\n  }\n  /**\n   * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n   *\n   * @private\n   * @param {Element} domParent Position parent.\n   * @param {Number} offset Position offset.\n   * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n   */\n\n\n  _isDomSelectionPositionCorrect(domParent, offset) {\n    // If selection is before or in the middle of inline filler string, it is incorrect.\n    if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {\n      // Selection in a text node, at wrong position (before or in the middle of filler).\n      return false;\n    }\n\n    if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {\n      // Selection in an element node, before filler text node.\n      return false;\n    }\n\n    const viewParent = this.mapDomToView(domParent); // If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`\n    // also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).\n\n    if (viewParent && viewParent.is('uiElement')) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n   * it is correctly displayed in the DOM.\n   *\n   * Following changes are done:\n   *\n   * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n   * element or if a previous text node ends with a space character,\n   * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n   * starts with a space or if it is the last text node in its container,\n   * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n   *\n   * Content of {@link #preElements} is not processed.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node View text node to process.\n   * @returns {String} Processed text data.\n   */\n\n\n  _processDataFromViewText(node) {\n    let data = node.data; // If any of node ancestors has a name which is in `preElements` array, then currently processed\n    // view text node is (will be) in preformatted element. We should not change whitespaces then.\n\n    if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n      return data;\n    } // 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n    // (container element boundary).\n\n\n    if (data.charAt(0) == ' ') {\n      const prevNode = this._getTouchingViewTextNode(node, false);\n\n      const prevEndsWithSpace = prevNode && this._nodeEndsWithSpace(prevNode);\n\n      if (prevEndsWithSpace || !prevNode) {\n        data = '\\u00A0' + data.substr(1);\n      }\n    } // 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n    // next node (container element boundary).\n    //\n    // Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n    //\n    // Foo <span>&nbsp;bar</span>  <-- bad.\n    // Foo&nbsp;<span> bar</span>  <-- good.\n    //\n    // More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\n\n    if (data.charAt(data.length - 1) == ' ') {\n      const nextNode = this._getTouchingViewTextNode(node, true);\n\n      if (data.charAt(data.length - 2) == ' ' || !nextNode || nextNode.data.charAt(0) == ' ') {\n        data = data.substr(0, data.length - 1) + '\\u00A0';\n      }\n    } // 3. Create space+nbsp pairs.\n\n\n    return data.replace(/ {2}/g, ' \\u00A0');\n  }\n  /**\n   * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node Node to check.\n   * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n   */\n\n\n  _nodeEndsWithSpace(node) {\n    if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n      return false;\n    }\n\n    const data = this._processDataFromViewText(node);\n\n    return data.charAt(data.length - 1) == ' ';\n  }\n  /**\n   * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n   *\n   * Following changes are done:\n   *\n   * * multiple whitespaces are replaced to a single space,\n   * * space at the beginning of a text node is removed if it is the first text node in its container\n   * element or if the previous text node ends with a space character,\n   * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n   * starts with a space or if it is the last text node in its container\n   * * nbsps are converted to spaces.\n   *\n   * @param {Node} node DOM text node to process.\n   * @returns {String} Processed data.\n   * @private\n   */\n\n\n  _processDataFromDomText(node) {\n    let data = node.data;\n\n    if (_hasDomParentOfType(node, this.preElements)) {\n      return getDataWithoutFiller(node);\n    } // Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n    // see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n    // That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n    // We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\n\n    data = data.replace(/[ \\n\\t\\r]{1,}/g, ' ');\n\n    const prevNode = this._getTouchingInlineDomNode(node, false);\n\n    const nextNode = this._getTouchingInlineDomNode(node, true);\n\n    const shouldLeftTrim = this._checkShouldLeftTrimDomText(prevNode);\n\n    const shouldRightTrim = this._checkShouldRightTrimDomText(node, nextNode); // If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n    // of this text node. Such space character is treated as a whitespace.\n\n\n    if (shouldLeftTrim) {\n      data = data.replace(/^ /, '');\n    } // If the next text node does not exist remove space character from the end of this text node.\n\n\n    if (shouldRightTrim) {\n      data = data.replace(/ $/, '');\n    } // At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n    // This means that the text node starts/end with normal space instead of non-breaking space.\n    // This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n    // the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\n\n    data = getDataWithoutFiller(new Text(data)); // At this point we should have removed all whitespaces from DOM text data.\n    //\n    // Now, We will reverse the process that happens in `_processDataFromViewText`.\n    //\n    // We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n    // First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n    // ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\n    data = data.replace(/ \\u00A0/g, '  '); // Then, let's change the last nbsp to a space.\n\n    if (/( |\\u00A0)\\u00A0$/.test(data) || !nextNode || nextNode.data && nextNode.data.charAt(0) == ' ') {\n      data = data.replace(/\\u00A0$/, ' ');\n    } // Then, change &nbsp; character that is at the beginning of the text node to space character.\n    // We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\n\n    if (shouldLeftTrim) {\n      data = data.replace(/^\\u00A0/, ' ');\n    } // At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n    // changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\n\n    return data;\n  }\n  /**\n   * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n   * be trimmed from the left side.\n   *\n   * @param {Node} prevNode\n   */\n\n\n  _checkShouldLeftTrimDomText(prevNode) {\n    if (!prevNode) {\n      return true;\n    }\n\n    if (isElement(prevNode)) {\n      return true;\n    }\n\n    return /[^\\S\\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1));\n  }\n  /**\n   * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n   * be trimmed from the right side.\n   *\n   * @param {Node} node\n   * @param {Node} nextNode\n   */\n\n\n  _checkShouldRightTrimDomText(node, nextNode) {\n    if (nextNode) {\n      return false;\n    }\n\n    return !startsWithFiller(node);\n  }\n  /**\n   * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n   * that is contained in the same container element. If there is no such sibling, `null` is returned.\n   *\n   * @param {module:engine/view/text~Text} node Reference node.\n   * @param {Boolean} getNext\n   * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n   */\n\n\n  _getTouchingViewTextNode(node, getNext) {\n    const treeWalker = new ViewTreeWalker({\n      startPosition: getNext ? ViewPosition._createAfter(node) : ViewPosition._createBefore(node),\n      direction: getNext ? 'forward' : 'backward'\n    });\n\n    for (const value of treeWalker) {\n      // ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n      // text node in its container element.\n      if (value.item.is('containerElement')) {\n        return null;\n      } // <br> found – it works like a block boundary, so do not scan further.\n      else if (value.item.is('br')) {\n          return null;\n        } // Found a text node in the same container element.\n        else if (value.item.is('textProxy')) {\n            return value.item;\n          }\n    }\n\n    return null;\n  }\n  /**\n   * Helper function. For the given text node, it finds the closest touching node which is either\n   * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n   * wasn't found so far, `null` is returned.\n   *\n   * In the following DOM structure:\n   *\n   *\t\t<p>foo<b>bar</b><br>bom</p>\n   *\n   * * `foo` doesn't have its previous touching inline node (`null` is returned),\n   * * `foo`'s next touching inline node is `bar`\n   * * `bar`'s next touching inline node is `<br>`\n   *\n   * This method returns text nodes and `<br>` elements because these types of nodes affect how\n   * spaces in the given text node need to be converted.\n   *\n   * @private\n   * @param {Text} node\n   * @param {Boolean} getNext\n   * @returns {Text|Element|null}\n   */\n\n\n  _getTouchingInlineDomNode(node, getNext) {\n    if (!node.parentNode) {\n      return null;\n    }\n\n    const direction = getNext ? 'nextNode' : 'previousNode';\n    const document = node.ownerDocument;\n    const topmostParent = getAncestors(node)[0];\n    const treeWalker = document.createTreeWalker(topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n      acceptNode(node) {\n        if (isText(node)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        if (node.tagName == 'BR') {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n\n    });\n    treeWalker.currentNode = node;\n    const touchingNode = treeWalker[direction]();\n\n    if (touchingNode !== null) {\n      const lca = getCommonAncestor(node, touchingNode); // If there is common ancestor between the text node and next/prev text node,\n      // and there are no block elements on a way from the text node to that ancestor,\n      // and there are no block elements on a way from next/prev text node to that ancestor...\n\n      if (lca && !_hasDomParentOfType(node, this.blockElements, lca) && !_hasDomParentOfType(touchingNode, this.blockElements, lca)) {\n        // Then they are in the same container element.\n        return touchingNode;\n      }\n    }\n\n    return null;\n  }\n\n} // Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\n\nfunction _hasDomParentOfType(node, types, boundaryParent) {\n  let parents = getAncestors(node);\n\n  if (boundaryParent) {\n    parents = parents.slice(parents.indexOf(boundaryParent) + 1);\n  }\n\n  return parents.some(parent => parent.tagName && types.includes(parent.tagName.toLowerCase()));\n} // A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\n\n\nfunction forEachDomNodeAncestor(node, callback) {\n  while (node && node != global.document) {\n    callback(node);\n    node = node.parentNode;\n  }\n} // Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\n\n\nfunction isNbspBlockFiller(domNode, blockElements) {\n  const isNBSP = isText(domNode) && domNode.data == '\\u00A0';\n  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;\n} // Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\n\n\nfunction hasBlockParent(domNode, blockElements) {\n  const parent = domNode.parentNode;\n  return parent && parent.tagName && blockElements.includes(parent.tagName.toLowerCase());\n}\n/**\n * Enum representing type of the block filler.\n *\n * Possible values:\n *\n * * `br` - for `<br>` block filler used in editing view,\n * * `nbsp` - for `&nbsp;` block fillers used in the data.\n *\n * @typedef {String} module:engine/view/filler~BlockFillerMode\n */","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js"],"names":["ViewText","ViewElement","ViewPosition","ViewRange","ViewSelection","ViewDocumentFragment","ViewTreeWalker","BR_FILLER","getDataWithoutFiller","INLINE_FILLER_LENGTH","isInlineFiller","NBSP_FILLER","startsWithFiller","global","indexOf","getAncestors","getCommonAncestor","isText","isElement","BR_FILLER_REF","document","DomConverter","constructor","options","blockFillerMode","preElements","blockElements","_blockFiller","_domToViewMapping","WeakMap","_viewToDomMapping","_fakeSelectionMapping","bindFakeSelection","domElement","viewDocumentSelection","set","fakeSelectionToView","get","bindElements","viewElement","unbindDomElement","delete","child","childNodes","bindDocumentFragments","domFragment","viewFragment","viewToDom","viewNode","domDocument","is","textData","_processDataFromViewText","createTextNode","mapViewToDom","createDocumentFragment","bind","render","hasAttribute","createElementNS","getAttribute","name","createElement","key","getAttributeKeys","setAttribute","withChildren","undefined","viewChildrenToDom","appendChild","fillerPositionOffset","getFillerOffset","offset","childView","getChildren","viewRangeToDom","viewRange","domStart","viewPositionToDom","start","domEnd","end","domRange","createRange","setStart","parent","setEnd","viewPosition","viewParent","domParent","findCorrespondingDomText","domBefore","domAfter","nodeBefore","parentNode","nextSibling","domToView","domNode","isBlockFiller","uiElement","getParentUIElement","_processDataFromDomText","isComment","mapDomToView","isDocumentFragment","viewName","keepOriginalCase","tagName","toLowerCase","attrs","attributes","i","length","_setAttribute","value","domChildrenToView","_appendChild","domChild","viewChild","domSelectionToView","domSelection","rangeCount","container","getRangeAt","startContainer","viewSelection","isBackward","isDomSelectionBackward","viewRanges","domRangeToView","push","backward","viewStart","domPositionToView","startOffset","viewEnd","endContainer","endOffset","domOffset","_createBefore","findCorrespondingViewText","viewBefore","index","domElementOrDocumentFragment","domText","previousSibling","firstChild","getChild","documentFragmentOrElement","viewText","focus","viewEditable","domEditable","ownerDocument","activeElement","scrollX","scrollY","window","scrollPositions","forEachDomNodeAncestor","node","scrollLeft","scrollTop","shift","scrollTo","nodeType","Node","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","COMMENT_NODE","isEqualNode","hasBlockParent","isNbspBlockFiller","selection","isCollapsed","range","anchorNode","anchorOffset","focusNode","focusOffset","collapsed","detach","ancestors","pop","isDomSelectionCorrect","_isDomSelectionPositionCorrect","data","some","includes","charAt","prevNode","_getTouchingViewTextNode","prevEndsWithSpace","_nodeEndsWithSpace","substr","nextNode","replace","_hasDomParentOfType","_getTouchingInlineDomNode","shouldLeftTrim","_checkShouldLeftTrimDomText","shouldRightTrim","_checkShouldRightTrimDomText","Text","test","getNext","treeWalker","startPosition","_createAfter","direction","item","topmostParent","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","acceptNode","FILTER_ACCEPT","FILTER_SKIP","currentNode","touchingNode","lca","types","boundaryParent","parents","slice","callback","isNBSP"],"mappings":"AAAA;;;;;AAKA;;;;AAIA;AAEA,OAAOA,QAAP,MAAqB,QAArB;AACA,OAAOC,WAAP,MAAwB,WAAxB;AACA,OAAOC,YAAP,MAAyB,YAAzB;AACA,OAAOC,SAAP,MAAsB,SAAtB;AACA,OAAOC,aAAP,MAA0B,aAA1B;AACA,OAAOC,oBAAP,MAAiC,oBAAjC;AACA,OAAOC,cAAP,MAA2B,cAA3B;AACA,SAASC,SAAT,EAAoBC,oBAApB,EAA0CC,oBAA1C,EAAgEC,cAAhE,EAAgFC,WAAhF,EAA6FC,gBAA7F,QAAqH,UAArH;AAEA,OAAOC,MAAP,MAAmB,0CAAnB;AACA,OAAOC,OAAP,MAAoB,2CAApB;AACA,OAAOC,YAAP,MAAyB,gDAAzB;AACA,OAAOC,iBAAP,MAA8B,qDAA9B;AACA,OAAOC,MAAP,MAAmB,0CAAnB;AACA,SAASC,SAAT,QAA0B,WAA1B,C,CAEA;;AACA,MAAMC,aAAa,GAAGZ,SAAS,CAAEa,QAAF,CAA/B;AAEA;;;;;;;;;;;;;AAYA,eAAe,MAAMC,YAAN,CAAmB;AACjC;;;;;;;AAOAC,EAAAA,WAAW,CAAEF,QAAF,EAAYG,OAAO,GAAG,EAAtB,EAA2B;AACrC;;;;AAIA,SAAKH,QAAL,GAAgBA,QAAhB;AAEA;;;;;;;AAMA,SAAKI,eAAL,GAAuBD,OAAO,CAACC,eAAR,IAA2B,IAAlD;AAEA;;;;;;;AAMA,SAAKC,WAAL,GAAmB,CAAE,KAAF,CAAnB;AAEA;;;;;;;;;;;;AAWA,SAAKC,aAAL,GAAqB,CAAE,GAAF,EAAO,KAAP,EAAc,IAAd,EAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4C,IAA5C,EAAkD,IAAlD,EAAwD,IAAxD,EAA8D,IAA9D,EAAoE,YAApE,CAArB;AAEA;;;;;;;;;AAQA,SAAKC,YAAL,GAAoB,KAAKH,eAAL,IAAwB,IAAxB,GAA+BjB,SAA/B,GAA2CI,WAA/D;AAEA;;;;;;;AAMA,SAAKiB,iBAAL,GAAyB,IAAIC,OAAJ,EAAzB;AAEA;;;;;;;AAMA,SAAKC,iBAAL,GAAyB,IAAID,OAAJ,EAAzB;AAEA;;;;;;;AAMA,SAAKE,qBAAL,GAA6B,IAAIF,OAAJ,EAA7B;AACA;AAED;;;;;;;;;;;AASAG,EAAAA,iBAAiB,CAAEC,UAAF,EAAcC,qBAAd,EAAsC;AACtD,SAAKH,qBAAL,CAA2BI,GAA3B,CAAgCF,UAAhC,EAA4C,IAAI7B,aAAJ,CAAmB8B,qBAAnB,CAA5C;AACA;AAED;;;;;;;;;AAOAE,EAAAA,mBAAmB,CAAEH,UAAF,EAAe;AACjC,WAAO,KAAKF,qBAAL,CAA2BM,GAA3B,CAAgCJ,UAAhC,CAAP;AACA;AAED;;;;;;;;;;AAQAK,EAAAA,YAAY,CAAEL,UAAF,EAAcM,WAAd,EAA4B;AACvC,SAAKX,iBAAL,CAAuBO,GAAvB,CAA4BF,UAA5B,EAAwCM,WAAxC;;AACA,SAAKT,iBAAL,CAAuBK,GAAvB,CAA4BI,WAA5B,EAAyCN,UAAzC;AACA;AAED;;;;;;;;AAMAO,EAAAA,gBAAgB,CAAEP,UAAF,EAAe;AAC9B,UAAMM,WAAW,GAAG,KAAKX,iBAAL,CAAuBS,GAAvB,CAA4BJ,UAA5B,CAApB;;AAEA,QAAKM,WAAL,EAAmB;AAClB,WAAKX,iBAAL,CAAuBa,MAAvB,CAA+BR,UAA/B;;AACA,WAAKH,iBAAL,CAAuBW,MAAvB,CAA+BF,WAA/B;;AAEA,WAAM,MAAMG,KAAZ,IAAqBT,UAAU,CAACU,UAAhC,EAA6C;AAC5C,aAAKH,gBAAL,CAAuBE,KAAvB;AACA;AACD;AACD;AAED;;;;;;;;;;AAQAE,EAAAA,qBAAqB,CAAEC,WAAF,EAAeC,YAAf,EAA8B;AAClD,SAAKlB,iBAAL,CAAuBO,GAAvB,CAA4BU,WAA5B,EAAyCC,YAAzC;;AACA,SAAKhB,iBAAL,CAAuBK,GAAvB,CAA4BW,YAA5B,EAA0CD,WAA1C;AACA;AAED;;;;;;;;;;;;;;AAYAE,EAAAA,SAAS,CAAEC,QAAF,EAAYC,WAAZ,EAAyB1B,OAAO,GAAG,EAAnC,EAAwC;AAChD,QAAKyB,QAAQ,CAACE,EAAT,CAAa,MAAb,CAAL,EAA6B;AAC5B,YAAMC,QAAQ,GAAG,KAAKC,wBAAL,CAA+BJ,QAA/B,CAAjB;;AAEA,aAAOC,WAAW,CAACI,cAAZ,CAA4BF,QAA5B,CAAP;AACA,KAJD,MAIO;AACN,UAAK,KAAKG,YAAL,CAAmBN,QAAnB,CAAL,EAAqC;AACpC,eAAO,KAAKM,YAAL,CAAmBN,QAAnB,CAAP;AACA;;AAED,UAAIf,UAAJ;;AAEA,UAAKe,QAAQ,CAACE,EAAT,CAAa,kBAAb,CAAL,EAAyC;AACxC;AACAjB,QAAAA,UAAU,GAAGgB,WAAW,CAACM,sBAAZ,EAAb;;AAEA,YAAKhC,OAAO,CAACiC,IAAb,EAAoB;AACnB,eAAKZ,qBAAL,CAA4BX,UAA5B,EAAwCe,QAAxC;AACA;AACD,OAPD,MAOO,IAAKA,QAAQ,CAACE,EAAT,CAAa,WAAb,CAAL,EAAkC;AACxC;AACAjB,QAAAA,UAAU,GAAGe,QAAQ,CAACS,MAAT,CAAiBR,WAAjB,CAAb;;AAEA,YAAK1B,OAAO,CAACiC,IAAb,EAAoB;AACnB,eAAKlB,YAAL,CAAmBL,UAAnB,EAA+Be,QAA/B;AACA;;AAED,eAAOf,UAAP;AACA,OATM,MASA;AACN;AACA,YAAKe,QAAQ,CAACU,YAAT,CAAuB,OAAvB,CAAL,EAAwC;AACvCzB,UAAAA,UAAU,GAAGgB,WAAW,CAACU,eAAZ,CAA6BX,QAAQ,CAACY,YAAT,CAAuB,OAAvB,CAA7B,EAA+DZ,QAAQ,CAACa,IAAxE,CAAb;AACA,SAFD,MAEO;AACN5B,UAAAA,UAAU,GAAGgB,WAAW,CAACa,aAAZ,CAA2Bd,QAAQ,CAACa,IAApC,CAAb;AACA;;AAED,YAAKtC,OAAO,CAACiC,IAAb,EAAoB;AACnB,eAAKlB,YAAL,CAAmBL,UAAnB,EAA+Be,QAA/B;AACA,SAVK,CAYN;;;AACA,aAAM,MAAMe,GAAZ,IAAmBf,QAAQ,CAACgB,gBAAT,EAAnB,EAAiD;AAChD/B,UAAAA,UAAU,CAACgC,YAAX,CAAyBF,GAAzB,EAA8Bf,QAAQ,CAACY,YAAT,CAAuBG,GAAvB,CAA9B;AACA;AACD;;AAED,UAAKxC,OAAO,CAAC2C,YAAR,IAAwB3C,OAAO,CAAC2C,YAAR,KAAyBC,SAAtD,EAAkE;AACjE,aAAM,MAAMzB,KAAZ,IAAqB,KAAK0B,iBAAL,CAAwBpB,QAAxB,EAAkCC,WAAlC,EAA+C1B,OAA/C,CAArB,EAAgF;AAC/EU,UAAAA,UAAU,CAACoC,WAAX,CAAwB3B,KAAxB;AACA;AACD;;AAED,aAAOT,UAAP;AACA;AACD;AAED;;;;;;;;;;;;AAUA,GAAEmC,iBAAF,CAAqB7B,WAArB,EAAkCU,WAAlC,EAA+C1B,OAAO,GAAG,EAAzD,EAA8D;AAC7D,UAAM+C,oBAAoB,GAAG/B,WAAW,CAACgC,eAAZ,IAA+BhC,WAAW,CAACgC,eAAZ,EAA5D;AACA,QAAIC,MAAM,GAAG,CAAb;;AAEA,SAAM,MAAMC,SAAZ,IAAyBlC,WAAW,CAACmC,WAAZ,EAAzB,EAAqD;AACpD,UAAKJ,oBAAoB,KAAKE,MAA9B,EAAuC;AACtC,cAAM,KAAK7C,YAAL,CAAmBsB,WAAnB,CAAN;AACA;;AAED,YAAM,KAAKF,SAAL,CAAgB0B,SAAhB,EAA2BxB,WAA3B,EAAwC1B,OAAxC,CAAN;AAEAiD,MAAAA,MAAM;AACN;;AAED,QAAKF,oBAAoB,KAAKE,MAA9B,EAAuC;AACtC,YAAM,KAAK7C,YAAL,CAAmBsB,WAAnB,CAAN;AACA;AACD;AAED;;;;;;;;;AAOA0B,EAAAA,cAAc,CAAEC,SAAF,EAAc;AAC3B,UAAMC,QAAQ,GAAG,KAAKC,iBAAL,CAAwBF,SAAS,CAACG,KAAlC,CAAjB;AACA,UAAMC,MAAM,GAAG,KAAKF,iBAAL,CAAwBF,SAAS,CAACK,GAAlC,CAAf;AAEA,UAAMC,QAAQ,GAAG9D,QAAQ,CAAC+D,WAAT,EAAjB;AACAD,IAAAA,QAAQ,CAACE,QAAT,CAAmBP,QAAQ,CAACQ,MAA5B,EAAoCR,QAAQ,CAACL,MAA7C;AACAU,IAAAA,QAAQ,CAACI,MAAT,CAAiBN,MAAM,CAACK,MAAxB,EAAgCL,MAAM,CAACR,MAAvC;AAEA,WAAOU,QAAP;AACA;AAED;;;;;;;;;;;;;AAWAJ,EAAAA,iBAAiB,CAAES,YAAF,EAAiB;AACjC,UAAMC,UAAU,GAAGD,YAAY,CAACF,MAAhC;;AAEA,QAAKG,UAAU,CAACtC,EAAX,CAAe,MAAf,CAAL,EAA+B;AAC9B,YAAMuC,SAAS,GAAG,KAAKC,wBAAL,CAA+BF,UAA/B,CAAlB;;AAEA,UAAK,CAACC,SAAN,EAAkB;AACjB;AACA,eAAO,IAAP;AACA;;AAED,UAAIjB,MAAM,GAAGe,YAAY,CAACf,MAA1B;;AAEA,UAAK5D,gBAAgB,CAAE6E,SAAF,CAArB,EAAqC;AACpCjB,QAAAA,MAAM,IAAI/D,oBAAV;AACA;;AAED,aAAO;AAAE4E,QAAAA,MAAM,EAAEI,SAAV;AAAqBjB,QAAAA;AAArB,OAAP;AACA,KAfD,MAeO;AACN;AACA,UAAIiB,SAAJ,EAAeE,SAAf,EAA0BC,QAA1B;;AAEA,UAAKL,YAAY,CAACf,MAAb,KAAwB,CAA7B,EAAiC;AAChCiB,QAAAA,SAAS,GAAG,KAAKnC,YAAL,CAAmBkC,UAAnB,CAAZ;;AAEA,YAAK,CAACC,SAAN,EAAkB;AACjB;AACA,iBAAO,IAAP;AACA;;AAEDG,QAAAA,QAAQ,GAAGH,SAAS,CAAC9C,UAAV,CAAsB,CAAtB,CAAX;AACA,OATD,MASO;AACN,cAAMkD,UAAU,GAAGN,YAAY,CAACM,UAAhC;AAEAF,QAAAA,SAAS,GAAGE,UAAU,CAAC3C,EAAX,CAAe,MAAf,IACX,KAAKwC,wBAAL,CAA+BG,UAA/B,CADW,GAEX,KAAKvC,YAAL,CAAmBiC,YAAY,CAACM,UAAhC,CAFD;;AAIA,YAAK,CAACF,SAAN,EAAkB;AACjB;AACA,iBAAO,IAAP;AACA;;AAEDF,QAAAA,SAAS,GAAGE,SAAS,CAACG,UAAtB;AACAF,QAAAA,QAAQ,GAAGD,SAAS,CAACI,WAArB;AACA,OA3BK,CA6BN;AACA;;;AACA,UAAK9E,MAAM,CAAE2E,QAAF,CAAN,IAAsBhF,gBAAgB,CAAEgF,QAAF,CAA3C,EAA0D;AACzD,eAAO;AAAEP,UAAAA,MAAM,EAAEO,QAAV;AAAoBpB,UAAAA,MAAM,EAAE/D;AAA5B,SAAP;AACA;;AAED,YAAM+D,MAAM,GAAGmB,SAAS,GAAG7E,OAAO,CAAE6E,SAAF,CAAP,GAAuB,CAA1B,GAA8B,CAAtD;AAEA,aAAO;AAAEN,QAAAA,MAAM,EAAEI,SAAV;AAAqBjB,QAAAA;AAArB,OAAP;AACA;AACD;AAED;;;;;;;;;;;;;;;;AAcAwB,EAAAA,SAAS,CAAEC,OAAF,EAAW1E,OAAO,GAAG,EAArB,EAA0B;AAClC,QAAK,KAAK2E,aAAL,CAAoBD,OAApB,EAA6B,KAAKzE,eAAlC,CAAL,EAA2D;AAC1D,aAAO,IAAP;AACA,KAHiC,CAKlC;;;AACA,UAAM2E,SAAS,GAAG,KAAKC,kBAAL,CAAyBH,OAAzB,EAAkC,KAAKrE,iBAAvC,CAAlB;;AAEA,QAAKuE,SAAL,EAAiB;AAChB,aAAOA,SAAP;AACA;;AAED,QAAKlF,MAAM,CAAEgF,OAAF,CAAX,EAAyB;AACxB,UAAKvF,cAAc,CAAEuF,OAAF,CAAnB,EAAiC;AAChC,eAAO,IAAP;AACA,OAFD,MAEO;AACN,cAAM9C,QAAQ,GAAG,KAAKkD,uBAAL,CAA8BJ,OAA9B,CAAjB;;AAEA,eAAO9C,QAAQ,KAAK,EAAb,GAAkB,IAAlB,GAAyB,IAAInD,QAAJ,CAAc,KAAKoB,QAAnB,EAA6B+B,QAA7B,CAAhC;AACA;AACD,KARD,MAQO,IAAK,KAAKmD,SAAL,CAAgBL,OAAhB,CAAL,EAAiC;AACvC,aAAO,IAAP;AACA,KAFM,MAEA;AACN,UAAK,KAAKM,YAAL,CAAmBN,OAAnB,CAAL,EAAoC;AACnC,eAAO,KAAKM,YAAL,CAAmBN,OAAnB,CAAP;AACA;;AAED,UAAI1D,WAAJ;;AAEA,UAAK,KAAKiE,kBAAL,CAAyBP,OAAzB,CAAL,EAA0C;AACzC;AACA1D,QAAAA,WAAW,GAAG,IAAIlC,oBAAJ,CAA0B,KAAKe,QAA/B,CAAd;;AAEA,YAAKG,OAAO,CAACiC,IAAb,EAAoB;AACnB,eAAKZ,qBAAL,CAA4BqD,OAA5B,EAAqC1D,WAArC;AACA;AACD,OAPD,MAOO;AACN;AACA,cAAMkE,QAAQ,GAAGlF,OAAO,CAACmF,gBAAR,GAA2BT,OAAO,CAACU,OAAnC,GAA6CV,OAAO,CAACU,OAAR,CAAgBC,WAAhB,EAA9D;AACArE,QAAAA,WAAW,GAAG,IAAItC,WAAJ,CAAiB,KAAKmB,QAAtB,EAAgCqF,QAAhC,CAAd;;AAEA,YAAKlF,OAAO,CAACiC,IAAb,EAAoB;AACnB,eAAKlB,YAAL,CAAmB2D,OAAnB,EAA4B1D,WAA5B;AACA,SAPK,CASN;;;AACA,cAAMsE,KAAK,GAAGZ,OAAO,CAACa,UAAtB;;AAEA,aAAM,IAAIC,CAAC,GAAGF,KAAK,CAACG,MAAN,GAAe,CAA7B,EAAgCD,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA8C;AAC7CxE,UAAAA,WAAW,CAAC0E,aAAZ,CAA2BJ,KAAK,CAAEE,CAAF,CAAL,CAAWlD,IAAtC,EAA4CgD,KAAK,CAAEE,CAAF,CAAL,CAAWG,KAAvD;AACA;AACD;;AAED,UAAK3F,OAAO,CAAC2C,YAAR,IAAwB3C,OAAO,CAAC2C,YAAR,KAAyBC,SAAtD,EAAkE;AACjE,aAAM,MAAMzB,KAAZ,IAAqB,KAAKyE,iBAAL,CAAwBlB,OAAxB,EAAiC1E,OAAjC,CAArB,EAAkE;AACjEgB,UAAAA,WAAW,CAAC6E,YAAZ,CAA0B1E,KAA1B;AACA;AACD;;AAED,aAAOH,WAAP;AACA;AACD;AAED;;;;;;;;;;;AASA,GAAE4E,iBAAF,CAAqBlF,UAArB,EAAiCV,OAAO,GAAG,EAA3C,EAAgD;AAC/C,SAAM,IAAIwF,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG9E,UAAU,CAACU,UAAX,CAAsBqE,MAA3C,EAAmDD,CAAC,EAApD,EAAyD;AACxD,YAAMM,QAAQ,GAAGpF,UAAU,CAACU,UAAX,CAAuBoE,CAAvB,CAAjB;AACA,YAAMO,SAAS,GAAG,KAAKtB,SAAL,CAAgBqB,QAAhB,EAA0B9F,OAA1B,CAAlB;;AAEA,UAAK+F,SAAS,KAAK,IAAnB,EAA0B;AACzB,cAAMA,SAAN;AACA;AACD;AACD;AAED;;;;;;;;;AAOAC,EAAAA,kBAAkB,CAAEC,YAAF,EAAiB;AAClC;AACA;AACA,QAAKA,YAAY,CAACC,UAAb,KAA4B,CAAjC,EAAqC;AACpC,UAAIC,SAAS,GAAGF,YAAY,CAACG,UAAb,CAAyB,CAAzB,EAA6BC,cAA7C,CADoC,CAGpC;;AACA,UAAK3G,MAAM,CAAEyG,SAAF,CAAX,EAA2B;AAC1BA,QAAAA,SAAS,GAAGA,SAAS,CAAC5B,UAAtB;AACA;;AAED,YAAM+B,aAAa,GAAG,KAAKzF,mBAAL,CAA0BsF,SAA1B,CAAtB;;AAEA,UAAKG,aAAL,EAAqB;AACpB,eAAOA,aAAP;AACA;AACD;;AAED,UAAMC,UAAU,GAAG,KAAKC,sBAAL,CAA6BP,YAA7B,CAAnB;AAEA,UAAMQ,UAAU,GAAG,EAAnB;;AAEA,SAAM,IAAIjB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGS,YAAY,CAACC,UAAlC,EAA8CV,CAAC,EAA/C,EAAoD;AACnD;AACA,YAAM7B,QAAQ,GAAGsC,YAAY,CAACG,UAAb,CAAyBZ,CAAzB,CAAjB;AACA,YAAMnC,SAAS,GAAG,KAAKqD,cAAL,CAAqB/C,QAArB,CAAlB;;AAEA,UAAKN,SAAL,EAAiB;AAChBoD,QAAAA,UAAU,CAACE,IAAX,CAAiBtD,SAAjB;AACA;AACD;;AAED,WAAO,IAAIxE,aAAJ,CAAmB4H,UAAnB,EAA+B;AAAEG,MAAAA,QAAQ,EAAEL;AAAZ,KAA/B,CAAP;AACA;AAED;;;;;;;;;AAOAG,EAAAA,cAAc,CAAE/C,QAAF,EAAa;AAC1B,UAAMkD,SAAS,GAAG,KAAKC,iBAAL,CAAwBnD,QAAQ,CAAC0C,cAAjC,EAAiD1C,QAAQ,CAACoD,WAA1D,CAAlB;AACA,UAAMC,OAAO,GAAG,KAAKF,iBAAL,CAAwBnD,QAAQ,CAACsD,YAAjC,EAA+CtD,QAAQ,CAACuD,SAAxD,CAAhB;;AAEA,QAAKL,SAAS,IAAIG,OAAlB,EAA4B;AAC3B,aAAO,IAAIpI,SAAJ,CAAeiI,SAAf,EAA0BG,OAA1B,CAAP;AACA;;AAED,WAAO,IAAP;AACA;AAED;;;;;;;;;;;;;;;;;AAeAF,EAAAA,iBAAiB,CAAE5C,SAAF,EAAaiD,SAAb,EAAyB;AACzC,QAAK,KAAKxC,aAAL,CAAoBT,SAApB,EAA+B,KAAKjE,eAApC,CAAL,EAA6D;AAC5D,aAAO,KAAK6G,iBAAL,CAAwB5C,SAAS,CAACK,UAAlC,EAA8ChF,OAAO,CAAE2E,SAAF,CAArD,CAAP;AACA,KAHwC,CAKzC;;;AACA,UAAMlD,WAAW,GAAG,KAAKgE,YAAL,CAAmBd,SAAnB,CAApB;;AAEA,QAAKlD,WAAW,IAAIA,WAAW,CAACW,EAAZ,CAAgB,WAAhB,CAApB,EAAoD;AACnD,aAAOhD,YAAY,CAACyI,aAAb,CAA4BpG,WAA5B,CAAP;AACA;;AAED,QAAKtB,MAAM,CAAEwE,SAAF,CAAX,EAA2B;AAC1B,UAAK/E,cAAc,CAAE+E,SAAF,CAAnB,EAAmC;AAClC,eAAO,KAAK4C,iBAAL,CAAwB5C,SAAS,CAACK,UAAlC,EAA8ChF,OAAO,CAAE2E,SAAF,CAArD,CAAP;AACA;;AAED,YAAMD,UAAU,GAAG,KAAKoD,yBAAL,CAAgCnD,SAAhC,CAAnB;AACA,UAAIjB,MAAM,GAAGkE,SAAb;;AAEA,UAAK,CAAClD,UAAN,EAAmB;AAClB,eAAO,IAAP;AACA;;AAED,UAAK5E,gBAAgB,CAAE6E,SAAF,CAArB,EAAqC;AACpCjB,QAAAA,MAAM,IAAI/D,oBAAV;AACA+D,QAAAA,MAAM,GAAGA,MAAM,GAAG,CAAT,GAAa,CAAb,GAAiBA,MAA1B;AACA;;AAED,aAAO,IAAItE,YAAJ,CAAkBsF,UAAlB,EAA8BhB,MAA9B,CAAP;AACA,KAlBD,CAmBA;AAnBA,SAoBK;AACJ,YAAKkE,SAAS,KAAK,CAAnB,EAAuB;AACtB,gBAAMlD,UAAU,GAAG,KAAKe,YAAL,CAAmBd,SAAnB,CAAnB;;AAEA,cAAKD,UAAL,EAAkB;AACjB,mBAAO,IAAItF,YAAJ,CAAkBsF,UAAlB,EAA8B,CAA9B,CAAP;AACA;AACD,SAND,MAMO;AACN,gBAAMG,SAAS,GAAGF,SAAS,CAAC9C,UAAV,CAAsB+F,SAAS,GAAG,CAAlC,CAAlB;AACA,gBAAMG,UAAU,GAAG5H,MAAM,CAAE0E,SAAF,CAAN,GAClB,KAAKiD,yBAAL,CAAgCjD,SAAhC,CADkB,GAElB,KAAKY,YAAL,CAAmBZ,SAAnB,CAFD,CAFM,CAMN;;AACA,cAAKkD,UAAU,IAAIA,UAAU,CAACxD,MAA9B,EAAuC;AACtC,mBAAO,IAAInF,YAAJ,CAAkB2I,UAAU,CAACxD,MAA7B,EAAqCwD,UAAU,CAACC,KAAX,GAAmB,CAAxD,CAAP;AACA;AACD;;AAED,eAAO,IAAP;AACA;AACD;AAED;;;;;;;;;;;;;AAWAvC,EAAAA,YAAY,CAAEwC,4BAAF,EAAiC;AAC5C,WAAO,KAAK3C,kBAAL,CAAyB2C,4BAAzB,KAA2D,KAAKnH,iBAAL,CAAuBS,GAAvB,CAA4B0G,4BAA5B,CAAlE;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;AAoBAH,EAAAA,yBAAyB,CAAEI,OAAF,EAAY;AACpC,QAAKtI,cAAc,CAAEsI,OAAF,CAAnB,EAAiC;AAChC,aAAO,IAAP;AACA,KAHmC,CAKpC;;;AACA,UAAM7C,SAAS,GAAG,KAAKC,kBAAL,CAAyB4C,OAAzB,CAAlB;;AAEA,QAAK7C,SAAL,EAAiB;AAChB,aAAOA,SAAP;AACA;;AAED,UAAM8C,eAAe,GAAGD,OAAO,CAACC,eAAhC,CAZoC,CAcpC;;AACA,QAAKA,eAAL,EAAuB;AACtB,UAAK,CAAG,KAAK/H,SAAL,CAAgB+H,eAAhB,CAAR,EAA8C;AAC7C;AACA,eAAO,IAAP;AACA;;AAED,YAAM1G,WAAW,GAAG,KAAKgE,YAAL,CAAmB0C,eAAnB,CAApB;;AAEA,UAAK1G,WAAL,EAAmB;AAClB,cAAMwD,WAAW,GAAGxD,WAAW,CAACwD,WAAhC,CADkB,CAGlB;;AACA,YAAKA,WAAW,YAAY/F,QAA5B,EAAuC;AACtC,iBAAOuC,WAAW,CAACwD,WAAnB;AACA,SAFD,MAEO;AACN,iBAAO,IAAP;AACA;AACD;AACD,KAlBD,CAmBA;AAnBA,SAoBK;AACJ,cAAMxD,WAAW,GAAG,KAAKgE,YAAL,CAAmByC,OAAO,CAAClD,UAA3B,CAApB;;AAEA,YAAKvD,WAAL,EAAmB;AAClB,gBAAM2G,UAAU,GAAG3G,WAAW,CAAC4G,QAAZ,CAAsB,CAAtB,CAAnB,CADkB,CAGlB;;AACA,cAAKD,UAAU,YAAYlJ,QAA3B,EAAsC;AACrC,mBAAOkJ,UAAP;AACA,WAFD,MAEO;AACN,mBAAO,IAAP;AACA;AACD;AACD;;AAED,WAAO,IAAP;AACA;AAED;;;;;;;;;;;;AAUA5F,EAAAA,YAAY,CAAE8F,yBAAF,EAA8B;AACzC,WAAO,KAAKtH,iBAAL,CAAuBO,GAAvB,CAA4B+G,yBAA5B,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;AAeA1D,EAAAA,wBAAwB,CAAE2D,QAAF,EAAa;AACpC,UAAMJ,eAAe,GAAGI,QAAQ,CAACJ,eAAjC,CADoC,CAGpC;;AACA,QAAKA,eAAe,IAAI,KAAK3F,YAAL,CAAmB2F,eAAnB,CAAxB,EAA+D;AAC9D,aAAO,KAAK3F,YAAL,CAAmB2F,eAAnB,EAAqClD,WAA5C;AACA,KANmC,CAQpC;;;AACA,QAAK,CAACkD,eAAD,IAAoBI,QAAQ,CAAChE,MAA7B,IAAuC,KAAK/B,YAAL,CAAmB+F,QAAQ,CAAChE,MAA5B,CAA5C,EAAmF;AAClF,aAAO,KAAK/B,YAAL,CAAmB+F,QAAQ,CAAChE,MAA5B,EAAqC1C,UAArC,CAAiD,CAAjD,CAAP;AACA;;AAED,WAAO,IAAP;AACA;AAED;;;;;;;AAKA2G,EAAAA,KAAK,CAAEC,YAAF,EAAiB;AACrB,UAAMC,WAAW,GAAG,KAAKlG,YAAL,CAAmBiG,YAAnB,CAApB;;AAEA,QAAKC,WAAW,IAAIA,WAAW,CAACC,aAAZ,CAA0BC,aAA1B,KAA4CF,WAAhE,EAA8E;AAC7E;AACA,YAAM;AAAEG,QAAAA,OAAF;AAAWC,QAAAA;AAAX,UAAuB/I,MAAM,CAACgJ,MAApC;AACA,YAAMC,eAAe,GAAG,EAAxB,CAH6E,CAK7E;AACA;;AACAC,MAAAA,sBAAsB,CAAEP,WAAF,EAAeQ,IAAI,IAAI;AAC5C,cAAM;AAAEC,UAAAA,UAAF;AAAcC,UAAAA;AAAd,YAA4BF,IAAlC;AAEAF,QAAAA,eAAe,CAAC5B,IAAhB,CAAsB,CAAE+B,UAAF,EAAcC,SAAd,CAAtB;AACA,OAJqB,CAAtB;AAMAV,MAAAA,WAAW,CAACF,KAAZ,GAb6E,CAe7E;AACA;AACA;AACA;;AACAS,MAAAA,sBAAsB,CAAEP,WAAF,EAAeQ,IAAI,IAAI;AAC5C,cAAM,CAAEC,UAAF,EAAcC,SAAd,IAA4BJ,eAAe,CAACK,KAAhB,EAAlC;AAEAH,QAAAA,IAAI,CAACC,UAAL,GAAkBA,UAAlB;AACAD,QAAAA,IAAI,CAACE,SAAL,GAAiBA,SAAjB;AACA,OALqB,CAAtB,CAnB6E,CA0B7E;AACA;;AACArJ,MAAAA,MAAM,CAACgJ,MAAP,CAAcO,QAAd,CAAwBT,OAAxB,EAAiCC,OAAjC;AACA;AACD;AAED;;;;;;;;AAMA1I,EAAAA,SAAS,CAAE8I,IAAF,EAAS;AACjB,WAAOA,IAAI,IAAIA,IAAI,CAACK,QAAL,IAAiBC,IAAI,CAACC,YAArC;AACA;AAED;;;;;;;;AAMA/D,EAAAA,kBAAkB,CAAEwD,IAAF,EAAS;AAC1B,WAAOA,IAAI,IAAIA,IAAI,CAACK,QAAL,IAAiBC,IAAI,CAACE,sBAArC;AACA;AAED;;;;;;;;AAMAlE,EAAAA,SAAS,CAAE0D,IAAF,EAAS;AACjB,WAAOA,IAAI,IAAIA,IAAI,CAACK,QAAL,IAAiBC,IAAI,CAACG,YAArC;AACA;AAED;;;;;;;;;;;;;;;;;AAeAvE,EAAAA,aAAa,CAAED,OAAF,EAAY;AACxB,QAAK,KAAKzE,eAAL,IAAwB,IAA7B,EAAoC;AACnC,aAAOyE,OAAO,CAACyE,WAAR,CAAqBvJ,aAArB,CAAP;AACA,KAHuB,CAKxB;AACA;;;AACA,QAAK8E,OAAO,CAACU,OAAR,KAAoB,IAApB,IAA4BgE,cAAc,CAAE1E,OAAF,EAAW,KAAKvE,aAAhB,CAA1C,IAA6EuE,OAAO,CAACH,UAAR,CAAmBnD,UAAnB,CAA8BqE,MAA9B,KAAyC,CAA3H,EAA+H;AAC9H,aAAO,IAAP;AACA;;AAED,WAAO4D,iBAAiB,CAAE3E,OAAF,EAAW,KAAKvE,aAAhB,CAAxB;AACA;AAED;;;;;;;;AAMAqG,EAAAA,sBAAsB,CAAE8C,SAAF,EAAc;AACnC,QAAKA,SAAS,CAACC,WAAf,EAA6B;AAC5B,aAAO,KAAP;AACA,KAHkC,CAKnC;AACA;;;AACA,UAAMC,KAAK,GAAG3J,QAAQ,CAAC+D,WAAT,EAAd;AAEA4F,IAAAA,KAAK,CAAC3F,QAAN,CAAgByF,SAAS,CAACG,UAA1B,EAAsCH,SAAS,CAACI,YAAhD;AACAF,IAAAA,KAAK,CAACzF,MAAN,CAAcuF,SAAS,CAACK,SAAxB,EAAmCL,SAAS,CAACM,WAA7C;AAEA,UAAMhD,QAAQ,GAAG4C,KAAK,CAACK,SAAvB;AAEAL,IAAAA,KAAK,CAACM,MAAN;AAEA,WAAOlD,QAAP;AACA;AAED;;;;;;;;;AAOA/B,EAAAA,kBAAkB,CAAEH,OAAF,EAAY;AAC7B,UAAMqF,SAAS,GAAGvK,YAAY,CAAEkF,OAAF,CAA9B,CAD6B,CAG7B;;AACAqF,IAAAA,SAAS,CAACC,GAAV;;AAEA,WAAQD,SAAS,CAACtE,MAAlB,EAA2B;AAC1B,YAAMf,OAAO,GAAGqF,SAAS,CAACC,GAAV,EAAhB;;AACA,YAAMvI,QAAQ,GAAG,KAAKpB,iBAAL,CAAuBS,GAAvB,CAA4B4D,OAA5B,CAAjB;;AAEA,UAAKjD,QAAQ,IAAIA,QAAQ,CAACE,EAAT,CAAa,WAAb,CAAjB,EAA8C;AAC7C,eAAOF,QAAP;AACA;AACD;;AAED,WAAO,IAAP;AACA;AAED;;;;;;;;;;;;AAUAwI,EAAAA,qBAAqB,CAAEhE,YAAF,EAAiB;AACrC,WAAO,KAAKiE,8BAAL,CAAqCjE,YAAY,CAACwD,UAAlD,EAA8DxD,YAAY,CAACyD,YAA3E,KACN,KAAKQ,8BAAL,CAAqCjE,YAAY,CAAC0D,SAAlD,EAA6D1D,YAAY,CAAC2D,WAA1E,CADD;AAEA;AAED;;;;;;;;;;AAQAM,EAAAA,8BAA8B,CAAEhG,SAAF,EAAajB,MAAb,EAAsB;AACnD;AACA,QAAKvD,MAAM,CAAEwE,SAAF,CAAN,IAAuB7E,gBAAgB,CAAE6E,SAAF,CAAvC,IAAwDjB,MAAM,GAAG/D,oBAAtE,EAA6F;AAC5F;AACA,aAAO,KAAP;AACA;;AAED,QAAK,KAAKS,SAAL,CAAgBuE,SAAhB,KAA+B7E,gBAAgB,CAAE6E,SAAS,CAAC9C,UAAV,CAAsB6B,MAAtB,CAAF,CAApD,EAAyF;AACxF;AACA,aAAO,KAAP;AACA;;AAED,UAAMgB,UAAU,GAAG,KAAKe,YAAL,CAAmBd,SAAnB,CAAnB,CAZmD,CAcnD;AACA;;AACA,QAAKD,UAAU,IAAIA,UAAU,CAACtC,EAAX,CAAe,WAAf,CAAnB,EAAkD;AACjD,aAAO,KAAP;AACA;;AAED,WAAO,IAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;AAkBAE,EAAAA,wBAAwB,CAAE4G,IAAF,EAAS;AAChC,QAAI0B,IAAI,GAAG1B,IAAI,CAAC0B,IAAhB,CADgC,CAGhC;AACA;;AACA,QAAK1B,IAAI,CAACjJ,YAAL,GAAoB4K,IAApB,CAA0BtG,MAAM,IAAI,KAAK5D,WAAL,CAAiBmK,QAAjB,CAA2BvG,MAAM,CAACxB,IAAlC,CAApC,CAAL,EAAsF;AACrF,aAAO6H,IAAP;AACA,KAP+B,CAShC;AACA;;;AACA,QAAKA,IAAI,CAACG,MAAL,CAAa,CAAb,KAAoB,GAAzB,EAA+B;AAC9B,YAAMC,QAAQ,GAAG,KAAKC,wBAAL,CAA+B/B,IAA/B,EAAqC,KAArC,CAAjB;;AACA,YAAMgC,iBAAiB,GAAGF,QAAQ,IAAI,KAAKG,kBAAL,CAAyBH,QAAzB,CAAtC;;AAEA,UAAKE,iBAAiB,IAAI,CAACF,QAA3B,EAAsC;AACrCJ,QAAAA,IAAI,GAAG,WAAWA,IAAI,CAACQ,MAAL,CAAa,CAAb,CAAlB;AACA;AACD,KAlB+B,CAoBhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAKR,IAAI,CAACG,MAAL,CAAaH,IAAI,CAAC1E,MAAL,GAAc,CAA3B,KAAkC,GAAvC,EAA6C;AAC5C,YAAMmF,QAAQ,GAAG,KAAKJ,wBAAL,CAA+B/B,IAA/B,EAAqC,IAArC,CAAjB;;AAEA,UAAK0B,IAAI,CAACG,MAAL,CAAaH,IAAI,CAAC1E,MAAL,GAAc,CAA3B,KAAkC,GAAlC,IAAyC,CAACmF,QAA1C,IAAsDA,QAAQ,CAACT,IAAT,CAAcG,MAAd,CAAsB,CAAtB,KAA6B,GAAxF,EAA8F;AAC7FH,QAAAA,IAAI,GAAGA,IAAI,CAACQ,MAAL,CAAa,CAAb,EAAgBR,IAAI,CAAC1E,MAAL,GAAc,CAA9B,IAAoC,QAA3C;AACA;AACD,KAnC+B,CAqChC;;;AACA,WAAO0E,IAAI,CAACU,OAAL,CAAc,OAAd,EAAuB,SAAvB,CAAP;AACA;AAED;;;;;;;;;AAOAH,EAAAA,kBAAkB,CAAEjC,IAAF,EAAS;AAC1B,QAAKA,IAAI,CAACjJ,YAAL,GAAoB4K,IAApB,CAA0BtG,MAAM,IAAI,KAAK5D,WAAL,CAAiBmK,QAAjB,CAA2BvG,MAAM,CAACxB,IAAlC,CAApC,CAAL,EAAsF;AACrF,aAAO,KAAP;AACA;;AAED,UAAM6H,IAAI,GAAG,KAAKtI,wBAAL,CAA+B4G,IAA/B,CAAb;;AAEA,WAAO0B,IAAI,CAACG,MAAL,CAAaH,IAAI,CAAC1E,MAAL,GAAc,CAA3B,KAAkC,GAAzC;AACA;AAED;;;;;;;;;;;;;;;;;;AAgBAX,EAAAA,uBAAuB,CAAE2D,IAAF,EAAS;AAC/B,QAAI0B,IAAI,GAAG1B,IAAI,CAAC0B,IAAhB;;AAEA,QAAKW,mBAAmB,CAAErC,IAAF,EAAQ,KAAKvI,WAAb,CAAxB,EAAqD;AACpD,aAAOjB,oBAAoB,CAAEwJ,IAAF,CAA3B;AACA,KAL8B,CAO/B;AACA;AACA;AACA;;;AACA0B,IAAAA,IAAI,GAAGA,IAAI,CAACU,OAAL,CAAc,gBAAd,EAAgC,GAAhC,CAAP;;AAEA,UAAMN,QAAQ,GAAG,KAAKQ,yBAAL,CAAgCtC,IAAhC,EAAsC,KAAtC,CAAjB;;AACA,UAAMmC,QAAQ,GAAG,KAAKG,yBAAL,CAAgCtC,IAAhC,EAAsC,IAAtC,CAAjB;;AAEA,UAAMuC,cAAc,GAAG,KAAKC,2BAAL,CAAkCV,QAAlC,CAAvB;;AACA,UAAMW,eAAe,GAAG,KAAKC,4BAAL,CAAmC1C,IAAnC,EAAyCmC,QAAzC,CAAxB,CAjB+B,CAmB/B;AACA;;;AACA,QAAKI,cAAL,EAAsB;AACrBb,MAAAA,IAAI,GAAGA,IAAI,CAACU,OAAL,CAAc,IAAd,EAAoB,EAApB,CAAP;AACA,KAvB8B,CAyB/B;;;AACA,QAAKK,eAAL,EAAuB;AACtBf,MAAAA,IAAI,GAAGA,IAAI,CAACU,OAAL,CAAc,IAAd,EAAoB,EAApB,CAAP;AACA,KA5B8B,CA8B/B;AACA;AACA;AACA;;;AACAV,IAAAA,IAAI,GAAGlL,oBAAoB,CAAE,IAAImM,IAAJ,CAAUjB,IAAV,CAAF,CAA3B,CAlC+B,CAoC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,IAAAA,IAAI,GAAGA,IAAI,CAACU,OAAL,CAAc,UAAd,EAA0B,IAA1B,CAAP,CA3C+B,CA6C/B;;AACA,QAAK,oBAAoBQ,IAApB,CAA0BlB,IAA1B,KAAoC,CAACS,QAArC,IAAmDA,QAAQ,CAACT,IAAT,IAAiBS,QAAQ,CAACT,IAAT,CAAcG,MAAd,CAAsB,CAAtB,KAA6B,GAAtG,EAA8G;AAC7GH,MAAAA,IAAI,GAAGA,IAAI,CAACU,OAAL,CAAc,SAAd,EAAyB,GAAzB,CAAP;AACA,KAhD8B,CAkD/B;AACA;;;AACA,QAAKG,cAAL,EAAsB;AACrBb,MAAAA,IAAI,GAAGA,IAAI,CAACU,OAAL,CAAc,SAAd,EAAyB,GAAzB,CAAP;AACA,KAtD8B,CAwD/B;AACA;;;AACA,WAAOV,IAAP;AACA;AAED;;;;;;;;AAMAc,EAAAA,2BAA2B,CAAEV,QAAF,EAAa;AACvC,QAAK,CAACA,QAAN,EAAiB;AAChB,aAAO,IAAP;AACA;;AAED,QAAK5K,SAAS,CAAE4K,QAAF,CAAd,EAA6B;AAC5B,aAAO,IAAP;AACA;;AAED,WAAO,cAAcc,IAAd,CAAoBd,QAAQ,CAACJ,IAAT,CAAcG,MAAd,CAAsBC,QAAQ,CAACJ,IAAT,CAAc1E,MAAd,GAAuB,CAA7C,CAApB,CAAP;AACA;AAED;;;;;;;;;AAOA0F,EAAAA,4BAA4B,CAAE1C,IAAF,EAAQmC,QAAR,EAAmB;AAC9C,QAAKA,QAAL,EAAgB;AACf,aAAO,KAAP;AACA;;AAED,WAAO,CAACvL,gBAAgB,CAAEoJ,IAAF,CAAxB;AACA;AAED;;;;;;;;;;AAQA+B,EAAAA,wBAAwB,CAAE/B,IAAF,EAAQ6C,OAAR,EAAkB;AACzC,UAAMC,UAAU,GAAG,IAAIxM,cAAJ,CAAoB;AACtCyM,MAAAA,aAAa,EAAEF,OAAO,GAAG3M,YAAY,CAAC8M,YAAb,CAA2BhD,IAA3B,CAAH,GAAuC9J,YAAY,CAACyI,aAAb,CAA4BqB,IAA5B,CADvB;AAEtCiD,MAAAA,SAAS,EAAEJ,OAAO,GAAG,SAAH,GAAe;AAFK,KAApB,CAAnB;;AAKA,SAAM,MAAM3F,KAAZ,IAAqB4F,UAArB,EAAkC;AACjC;AACA;AACA,UAAK5F,KAAK,CAACgG,IAAN,CAAWhK,EAAX,CAAe,kBAAf,CAAL,EAA2C;AAC1C,eAAO,IAAP;AACA,OAFD,CAGA;AAHA,WAIK,IAAKgE,KAAK,CAACgG,IAAN,CAAWhK,EAAX,CAAe,IAAf,CAAL,EAA6B;AACjC,iBAAO,IAAP;AACA,SAFI,CAGL;AAHK,aAIA,IAAKgE,KAAK,CAACgG,IAAN,CAAWhK,EAAX,CAAe,WAAf,CAAL,EAAoC;AACxC,mBAAOgE,KAAK,CAACgG,IAAb;AACA;AACD;;AAED,WAAO,IAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;AAqBAZ,EAAAA,yBAAyB,CAAEtC,IAAF,EAAQ6C,OAAR,EAAkB;AAC1C,QAAK,CAAC7C,IAAI,CAAClE,UAAX,EAAwB;AACvB,aAAO,IAAP;AACA;;AAED,UAAMmH,SAAS,GAAGJ,OAAO,GAAG,UAAH,GAAgB,cAAzC;AACA,UAAMzL,QAAQ,GAAG4I,IAAI,CAACP,aAAtB;AACA,UAAM0D,aAAa,GAAGpM,YAAY,CAAEiJ,IAAF,CAAZ,CAAsB,CAAtB,CAAtB;AAEA,UAAM8C,UAAU,GAAG1L,QAAQ,CAACgM,gBAAT,CAA2BD,aAA3B,EAA0CE,UAAU,CAACC,SAAX,GAAuBD,UAAU,CAACE,YAA5E,EAA0F;AAC5GC,MAAAA,UAAU,CAAExD,IAAF,EAAS;AAClB,YAAK/I,MAAM,CAAE+I,IAAF,CAAX,EAAsB;AACrB,iBAAOqD,UAAU,CAACI,aAAlB;AACA;;AAED,YAAKzD,IAAI,CAACrD,OAAL,IAAgB,IAArB,EAA4B;AAC3B,iBAAO0G,UAAU,CAACI,aAAlB;AACA;;AAED,eAAOJ,UAAU,CAACK,WAAlB;AACA;;AAX2G,KAA1F,CAAnB;AAcAZ,IAAAA,UAAU,CAACa,WAAX,GAAyB3D,IAAzB;AAEA,UAAM4D,YAAY,GAAGd,UAAU,CAAEG,SAAF,CAAV,EAArB;;AAEA,QAAKW,YAAY,KAAK,IAAtB,EAA6B;AAC5B,YAAMC,GAAG,GAAG7M,iBAAiB,CAAEgJ,IAAF,EAAQ4D,YAAR,CAA7B,CAD4B,CAG5B;AACA;AACA;;AACA,UACCC,GAAG,IACH,CAACxB,mBAAmB,CAAErC,IAAF,EAAQ,KAAKtI,aAAb,EAA4BmM,GAA5B,CADpB,IAEA,CAACxB,mBAAmB,CAAEuB,YAAF,EAAgB,KAAKlM,aAArB,EAAoCmM,GAApC,CAHrB,EAIE;AACD;AACA,eAAOD,YAAP;AACA;AACD;;AAED,WAAO,IAAP;AACA;;AAppCgC,C,CAupClC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASvB,mBAAT,CAA8BrC,IAA9B,EAAoC8D,KAApC,EAA2CC,cAA3C,EAA4D;AAC3D,MAAIC,OAAO,GAAGjN,YAAY,CAAEiJ,IAAF,CAA1B;;AAEA,MAAK+D,cAAL,EAAsB;AACrBC,IAAAA,OAAO,GAAGA,OAAO,CAACC,KAAR,CAAeD,OAAO,CAAClN,OAAR,CAAiBiN,cAAjB,IAAoC,CAAnD,CAAV;AACA;;AAED,SAAOC,OAAO,CAACrC,IAAR,CAActG,MAAM,IAAIA,MAAM,CAACsB,OAAP,IAAkBmH,KAAK,CAAClC,QAAN,CAAgBvG,MAAM,CAACsB,OAAP,CAAeC,WAAf,EAAhB,CAA1C,CAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASmD,sBAAT,CAAiCC,IAAjC,EAAuCkE,QAAvC,EAAkD;AACjD,SAAQlE,IAAI,IAAIA,IAAI,IAAInJ,MAAM,CAACO,QAA/B,EAA0C;AACzC8M,IAAAA,QAAQ,CAAElE,IAAF,CAAR;AACAA,IAAAA,IAAI,GAAGA,IAAI,CAAClE,UAAZ;AACA;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS8E,iBAAT,CAA4B3E,OAA5B,EAAqCvE,aAArC,EAAqD;AACpD,QAAMyM,MAAM,GAAGlN,MAAM,CAAEgF,OAAF,CAAN,IAAqBA,OAAO,CAACyF,IAAR,IAAgB,QAApD;AAEA,SAAOyC,MAAM,IAAIxD,cAAc,CAAE1E,OAAF,EAAWvE,aAAX,CAAxB,IAAsDuE,OAAO,CAACH,UAAR,CAAmBnD,UAAnB,CAA8BqE,MAA9B,KAAyC,CAAtG;AACA,C,CAED;AACA;AACA;AACA;;;AACA,SAAS2D,cAAT,CAAyB1E,OAAzB,EAAkCvE,aAAlC,EAAkD;AACjD,QAAM2D,MAAM,GAAGY,OAAO,CAACH,UAAvB;AAEA,SAAOT,MAAM,IAAIA,MAAM,CAACsB,OAAjB,IAA4BjF,aAAa,CAACkK,QAAd,CAAwBvG,MAAM,CAACsB,OAAP,CAAeC,WAAf,EAAxB,CAAnC;AACA;AAED","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\n\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { BR_FILLER, getDataWithoutFiller, INLINE_FILLER_LENGTH, isInlineFiller, NBSP_FILLER, startsWithFiller } from './filler';\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport { isElement } from 'lodash-es';\n\n// eslint-disable-next-line new-cap\nconst BR_FILLER_REF = BR_FILLER( document );\n\n/**\n * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.\n *\n * The instance of DOMConverter is available in {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a\n * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).\n *\n * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will\n * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n\t/**\n\t * Creates DOM converter.\n\t *\n\t * @param {module:engine/view/document~Document} document The view document instance.\n\t * @param {Object} options Object with configuration options.\n\t * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode='br'] The type of the block filler to use.\n\t */\n\tconstructor( document, options = {} ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * The mode of a block filler used by DOM converter.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'br'|'nbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n\t\t */\n\t\tthis.blockFillerMode = options.blockFillerMode || 'br';\n\n\t\t/**\n\t\t * Elements which are considered pre-formatted elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n\t\t */\n\t\tthis.preElements = [ 'pre' ];\n\n\t\t/**\n\t\t * Elements which are considered block elements (and hence should be filled with a\n\t\t * {@link #isBlockFiller block filler}).\n\t\t *\n\t\t * Whether an element is considered a block element also affects handling of trailing whitespaces.\n\t\t *\n\t\t * You can extend this array if you introduce support for block elements which are not yet recognized here.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n\t\t */\n\t\tthis.blockElements = [ 'p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'dd', 'dt', 'figcaption' ];\n\n\t\t/**\n\t\t * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the\n\t\t * view to DOM conversion and to recognize block fillers during the DOM to view conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {Function} module:engine/view/domconverter~DomConverter#_blockFiller\n\t\t */\n\t\tthis._blockFiller = this.blockFillerMode == 'br' ? BR_FILLER : NBSP_FILLER;\n\n\t\t/**\n\t\t * DOM to View mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n\t\t */\n\t\tthis._domToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View to DOM mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n\t\t */\n\t\tthis._viewToDomMapping = new WeakMap();\n\n\t\t/**\n\t\t * Holds mapping between fake selection containers and corresponding view selections.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n\t\t */\n\t\tthis._fakeSelectionMapping = new WeakMap();\n\t}\n\n\t/**\n\t * Binds given DOM element that represents fake selection to a **position** of a\n\t * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n\t * Document selection copy is stored and can be retrieved by\n\t * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n\t */\n\tbindFakeSelection( domElement, viewDocumentSelection ) {\n\t\tthis._fakeSelectionMapping.set( domElement, new ViewSelection( viewDocumentSelection ) );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to\n\t * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @returns {module:engine/view/selection~Selection|undefined}\n\t */\n\tfakeSelectionToView( domElement ) {\n\t\treturn this._fakeSelectionMapping.get( domElement );\n\t}\n\n\t/**\n\t * Binds DOM and View elements, so it will be possible to get corresponding elements using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {HTMLElement} domElement DOM element to bind.\n\t * @param {module:engine/view/element~Element} viewElement View element to bind.\n\t */\n\tbindElements( domElement, viewElement ) {\n\t\tthis._domToViewMapping.set( domElement, viewElement );\n\t\tthis._viewToDomMapping.set( viewElement, domElement );\n\t}\n\n\t/**\n\t * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of\n\t * `domElement` will be unbound too.\n\t *\n\t * @param {HTMLElement} domElement DOM element to unbind.\n\t */\n\tunbindDomElement( domElement ) {\n\t\tconst viewElement = this._domToViewMapping.get( domElement );\n\n\t\tif ( viewElement ) {\n\t\t\tthis._domToViewMapping.delete( domElement );\n\t\t\tthis._viewToDomMapping.delete( viewElement );\n\n\t\t\tfor ( const child of domElement.childNodes ) {\n\t\t\t\tthis.unbindDomElement( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {DocumentFragment} domFragment DOM document fragment to bind.\n\t * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.\n\t */\n\tbindDocumentFragments( domFragment, viewFragment ) {\n\t\tthis._domToViewMapping.set( domFragment, viewFragment );\n\t\tthis._viewToDomMapping.set( viewFragment, domFragment );\n\t}\n\n\t/**\n\t * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View node or document fragment to transform.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n\t */\n\tviewToDom( viewNode, domDocument, options = {} ) {\n\t\tif ( viewNode.is( 'text' ) ) {\n\t\t\tconst textData = this._processDataFromViewText( viewNode );\n\n\t\t\treturn domDocument.createTextNode( textData );\n\t\t} else {\n\t\t\tif ( this.mapViewToDom( viewNode ) ) {\n\t\t\t\treturn this.mapViewToDom( viewNode );\n\t\t\t}\n\n\t\t\tlet domElement;\n\n\t\t\tif ( viewNode.is( 'documentFragment' ) ) {\n\t\t\t\t// Create DOM document fragment.\n\t\t\t\tdomElement = domDocument.createDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domElement, viewNode );\n\t\t\t\t}\n\t\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\t\t// UIElement has its own render() method (see #799).\n\t\t\t\tdomElement = viewNode.render( domDocument );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\treturn domElement;\n\t\t\t} else {\n\t\t\t\t// Create DOM element.\n\t\t\t\tif ( viewNode.hasAttribute( 'xmlns' ) ) {\n\t\t\t\t\tdomElement = domDocument.createElementNS( viewNode.getAttribute( 'xmlns' ), viewNode.name );\n\t\t\t\t} else {\n\t\t\t\t\tdomElement = domDocument.createElement( viewNode.name );\n\t\t\t\t}\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tfor ( const key of viewNode.getAttributeKeys() ) {\n\t\t\t\t\tdomElement.setAttribute( key, viewNode.getAttribute( key ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.viewChildrenToDom( viewNode, domDocument, options ) ) {\n\t\t\t\t\tdomElement.appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the view element to DOM using the\n\t * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n\t * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n\t * @returns {Iterable.<Node>} DOM nodes.\n\t */\n\t* viewChildrenToDom( viewElement, domDocument, options = {} ) {\n\t\tconst fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n\t\tlet offset = 0;\n\n\t\tfor ( const childView of viewElement.getChildren() ) {\n\t\t\tif ( fillerPositionOffset === offset ) {\n\t\t\t\tyield this._blockFiller( domDocument );\n\t\t\t}\n\n\t\t\tyield this.viewToDom( childView, domDocument, options );\n\n\t\t\toffset++;\n\t\t}\n\n\t\tif ( fillerPositionOffset === offset ) {\n\t\t\tyield this._blockFiller( domDocument );\n\t\t}\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/range~Range} to DOM range.\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {Range} DOM range.\n\t */\n\tviewRangeToDom( viewRange ) {\n\t\tconst domStart = this.viewPositionToDom( viewRange.start );\n\t\tconst domEnd = this.viewPositionToDom( viewRange.end );\n\n\t\tconst domRange = document.createRange();\n\t\tdomRange.setStart( domStart.parent, domStart.offset );\n\t\tdomRange.setEnd( domEnd.parent, domEnd.offset );\n\n\t\treturn domRange;\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n\t *\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t * If the converted position is directly before inline filler it is moved inside the filler.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n\t * @returns {Node} position.parent DOM position parent.\n\t * @returns {Number} position.offset DOM position offset.\n\t */\n\tviewPositionToDom( viewPosition ) {\n\t\tconst viewParent = viewPosition.parent;\n\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\tconst domParent = this.findCorrespondingDomText( viewParent );\n\n\t\t\tif ( !domParent ) {\n\t\t\t\t// Position is in a view text node that has not been rendered to DOM yet.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet offset = viewPosition.offset;\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset += INLINE_FILLER_LENGTH;\n\t\t\t}\n\n\t\t\treturn { parent: domParent, offset };\n\t\t} else {\n\t\t\t// viewParent is instance of ViewElement.\n\t\t\tlet domParent, domBefore, domAfter;\n\n\t\t\tif ( viewPosition.offset === 0 ) {\n\t\t\t\tdomParent = this.mapViewToDom( viewParent );\n\n\t\t\t\tif ( !domParent ) {\n\t\t\t\t\t// Position is in a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomAfter = domParent.childNodes[ 0 ];\n\t\t\t} else {\n\t\t\t\tconst nodeBefore = viewPosition.nodeBefore;\n\n\t\t\t\tdomBefore = nodeBefore.is( 'text' ) ?\n\t\t\t\t\tthis.findCorrespondingDomText( nodeBefore ) :\n\t\t\t\t\tthis.mapViewToDom( viewPosition.nodeBefore );\n\n\t\t\t\tif ( !domBefore ) {\n\t\t\t\t\t// Position is after a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomParent = domBefore.parentNode;\n\t\t\t\tdomAfter = domBefore.nextSibling;\n\t\t\t}\n\n\t\t\t// If there is an inline filler at position return position inside the filler. We should never return\n\t\t\t// the position before the inline filler.\n\t\t\tif ( isText( domAfter ) && startsWithFiller( domAfter ) ) {\n\t\t\t\treturn { parent: domAfter, offset: INLINE_FILLER_LENGTH };\n\t\t\t}\n\n\t\t\tconst offset = domBefore ? indexOf( domBefore ) + 1 : 0;\n\n\t\t\treturn { parent: domParent, offset };\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items. For\n\t * {@link module:engine/view/filler fillers} `null` will be returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n\t * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n\t */\n\tdomToView( domNode, options = {} ) {\n\t\tif ( this.isBlockFiller( domNode, this.blockFillerMode ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When node is inside UIElement return that UIElement as it's view representation.\n\t\tconst uiElement = this.getParentUIElement( domNode, this._domToViewMapping );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tif ( isText( domNode ) ) {\n\t\t\tif ( isInlineFiller( domNode ) ) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst textData = this._processDataFromDomText( domNode );\n\n\t\t\t\treturn textData === '' ? null : new ViewText( this.document, textData );\n\t\t\t}\n\t\t} else if ( this.isComment( domNode ) ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif ( this.mapDomToView( domNode ) ) {\n\t\t\t\treturn this.mapDomToView( domNode );\n\t\t\t}\n\n\t\t\tlet viewElement;\n\n\t\t\tif ( this.isDocumentFragment( domNode ) ) {\n\t\t\t\t// Create view document fragment.\n\t\t\t\tviewElement = new ViewDocumentFragment( this.document );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domNode, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create view element.\n\t\t\t\tconst viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n\t\t\t\tviewElement = new ViewElement( this.document, viewName );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domNode, viewElement );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tconst attrs = domNode.attributes;\n\n\t\t\t\tfor ( let i = attrs.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tviewElement._setAttribute( attrs[ i ].name, attrs[ i ].value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.domChildrenToView( domNode, options ) ) {\n\t\t\t\t\tviewElement._appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn viewElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the DOM element to view nodes using\n\t * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n\t * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n\t *\n\t * @param {HTMLElement} domElement Parent DOM element.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n\t */\n\t* domChildrenToView( domElement, options = {} ) {\n\t\tfor ( let i = 0; i < domElement.childNodes.length; i++ ) {\n\t\t\tconst domChild = domElement.childNodes[ i ];\n\t\t\tconst viewChild = this.domToView( domChild, options );\n\n\t\t\tif ( viewChild !== null ) {\n\t\t\t\tyield viewChild;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n\t * Ranges which cannot be converted will be omitted.\n\t *\n\t * @param {Selection} domSelection DOM selection.\n\t * @returns {module:engine/view/selection~Selection} View selection.\n\t */\n\tdomSelectionToView( domSelection ) {\n\t\t// DOM selection might be placed in fake selection container.\n\t\t// If container contains fake selection - return corresponding view selection.\n\t\tif ( domSelection.rangeCount === 1 ) {\n\t\t\tlet container = domSelection.getRangeAt( 0 ).startContainer;\n\n\t\t\t// The DOM selection might be moved to the text node inside the fake selection container.\n\t\t\tif ( isText( container ) ) {\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t}\n\n\t\t\tconst viewSelection = this.fakeSelectionToView( container );\n\n\t\t\tif ( viewSelection ) {\n\t\t\t\treturn viewSelection;\n\t\t\t}\n\t\t}\n\n\t\tconst isBackward = this.isDomSelectionBackward( domSelection );\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( let i = 0; i < domSelection.rangeCount; i++ ) {\n\t\t\t// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n\t\t\tconst domRange = domSelection.getRangeAt( i );\n\t\t\tconst viewRange = this.domRangeToView( domRange );\n\n\t\t\tif ( viewRange ) {\n\t\t\t\tviewRanges.push( viewRange );\n\t\t\t}\n\t\t}\n\n\t\treturn new ViewSelection( viewRanges, { backward: isBackward } );\n\t}\n\n\t/**\n\t * Converts DOM Range to view {@link module:engine/view/range~Range}.\n\t * If the start or end position can not be converted `null` is returned.\n\t *\n\t * @param {Range} domRange DOM range.\n\t * @returns {module:engine/view/range~Range|null} View range.\n\t */\n\tdomRangeToView( domRange ) {\n\t\tconst viewStart = this.domPositionToView( domRange.startContainer, domRange.startOffset );\n\t\tconst viewEnd = this.domPositionToView( domRange.endContainer, domRange.endOffset );\n\n\t\tif ( viewStart && viewEnd ) {\n\t\t\treturn new ViewRange( viewStart, viewEnd );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n\t *\n\t * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n\t * position of the filler will be converted and returned.\n\t *\n\t * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n\t * that position will be converted to view position before that UIElement.\n\t *\n\t * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n\t *\n\t * @param {Node} domParent DOM position parent.\n\t * @param {Number} domOffset DOM position offset.\n\t * @returns {module:engine/view/position~Position} viewPosition View position.\n\t */\n\tdomPositionToView( domParent, domOffset ) {\n\t\tif ( this.isBlockFiller( domParent, this.blockFillerMode ) ) {\n\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t}\n\n\t\t// If position is somewhere inside UIElement - return position before that element.\n\t\tconst viewElement = this.mapDomToView( domParent );\n\n\t\tif ( viewElement && viewElement.is( 'uiElement' ) ) {\n\t\t\treturn ViewPosition._createBefore( viewElement );\n\t\t}\n\n\t\tif ( isText( domParent ) ) {\n\t\t\tif ( isInlineFiller( domParent ) ) {\n\t\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t\t}\n\n\t\t\tconst viewParent = this.findCorrespondingViewText( domParent );\n\t\t\tlet offset = domOffset;\n\n\t\t\tif ( !viewParent ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset -= INLINE_FILLER_LENGTH;\n\t\t\t\toffset = offset < 0 ? 0 : offset;\n\t\t\t}\n\n\t\t\treturn new ViewPosition( viewParent, offset );\n\t\t}\n\t\t// domParent instanceof HTMLElement.\n\t\telse {\n\t\t\tif ( domOffset === 0 ) {\n\t\t\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t\t\tif ( viewParent ) {\n\t\t\t\t\treturn new ViewPosition( viewParent, 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst domBefore = domParent.childNodes[ domOffset - 1 ];\n\t\t\t\tconst viewBefore = isText( domBefore ) ?\n\t\t\t\t\tthis.findCorrespondingViewText( domBefore ) :\n\t\t\t\t\tthis.mapDomToView( domBefore );\n\n\t\t\t\t// TODO #663\n\t\t\t\tif ( viewBefore && viewBefore.parent ) {\n\t\t\t\t\treturn new ViewPosition( viewBefore.parent, viewBefore.index + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns corresponding view {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n\t * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * to the given DOM - `undefined` is returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n\t * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n\t * Corresponding view element, document fragment or `undefined` if no element was bound.\n\t */\n\tmapDomToView( domElementOrDocumentFragment ) {\n\t\treturn this.getParentUIElement( domElementOrDocumentFragment ) || this._domToViewMapping.get( domElementOrDocumentFragment );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n\t *\n\t * @param {Text} domText DOM text node.\n\t * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n\t * corresponding node.\n\t */\n\tfindCorrespondingViewText( domText ) {\n\t\tif ( isInlineFiller( domText ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If DOM text was rendered by UIElement - return that element.\n\t\tconst uiElement = this.getParentUIElement( domText );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tconst previousSibling = domText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling ) {\n\t\t\tif ( !( this.isElement( previousSibling ) ) ) {\n\t\t\t\t// The previous is text or comment.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst viewElement = this.mapDomToView( previousSibling );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst nextSibling = viewElement.nextSibling;\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( nextSibling instanceof ViewText ) {\n\t\t\t\t\treturn viewElement.nextSibling;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to use parent to find the corresponding text node.\n\t\telse {\n\t\t\tconst viewElement = this.mapDomToView( domText.parentNode );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst firstChild = viewElement.getChild( 0 );\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( firstChild instanceof ViewText ) {\n\t\t\t\t\treturn firstChild;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n\t * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n\t * use {@link #findCorrespondingDomText}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View element or document fragment.\n\t * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n\t */\n\tmapViewToDom( documentFragmentOrElement ) {\n\t\treturn this._viewToDomMapping.get( documentFragmentOrElement );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} viewText View text node.\n\t * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n\t */\n\tfindCorrespondingDomText( viewText ) {\n\t\tconst previousSibling = viewText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling && this.mapViewToDom( previousSibling ) ) {\n\t\t\treturn this.mapViewToDom( previousSibling ).nextSibling;\n\t\t}\n\n\t\t// If this is a first node, try to use parent to find the corresponding text node.\n\t\tif ( !previousSibling && viewText.parent && this.mapViewToDom( viewText.parent ) ) {\n\t\t\treturn this.mapViewToDom( viewText.parent ).childNodes[ 0 ];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t * @param {module:engine/view/editableelement~EditableElement} viewEditable\n\t */\n\tfocus( viewEditable ) {\n\t\tconst domEditable = this.mapViewToDom( viewEditable );\n\n\t\tif ( domEditable && domEditable.ownerDocument.activeElement !== domEditable ) {\n\t\t\t// Save the scrollX and scrollY positions before the focus.\n\t\t\tconst { scrollX, scrollY } = global.window;\n\t\t\tconst scrollPositions = [];\n\n\t\t\t// Save all scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst { scrollLeft, scrollTop } = node;\n\n\t\t\t\tscrollPositions.push( [ scrollLeft, scrollTop ] );\n\t\t\t} );\n\n\t\t\tdomEditable.focus();\n\n\t\t\t// Restore scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/957\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst [ scrollLeft, scrollTop ] = scrollPositions.shift();\n\n\t\t\t\tnode.scrollLeft = scrollLeft;\n\t\t\t\tnode.scrollTop = scrollTop;\n\t\t\t} );\n\n\t\t\t// Restore the scrollX and scrollY positions after the focus.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\tglobal.window.scrollTo( scrollX, scrollY );\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisElement( node ) {\n\t\treturn node && node.nodeType == Node.ELEMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisDocumentFragment( node ) {\n\t\treturn node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisComment( node ) {\n\t\treturn node && node.nodeType == Node.COMMENT_NODE;\n\t}\n\n\t/**\n\t * Checks if the node is an instance of the block filler for this DOM converter.\n\t *\n\t *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n\t *\n\t *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n\t *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n\t *\n\t * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n\t *\n\t * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n\t *\n\t * @param {Node} domNode DOM node to check.\n\t * @returns {Boolean} True if a node is considered a block filler for given mode.\n\t */\n\tisBlockFiller( domNode ) {\n\t\tif ( this.blockFillerMode == 'br' ) {\n\t\t\treturn domNode.isEqualNode( BR_FILLER_REF );\n\t\t}\n\n\t\t// Special case for <p><br></p> in which case the <br> should be treated as filler even\n\t\t// when we're in the 'nbsp' mode. See ckeditor5#5564.\n\t\tif ( domNode.tagName === 'BR' && hasBlockParent( domNode, this.blockElements ) && domNode.parentNode.childNodes.length === 1 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn isNbspBlockFiller( domNode, this.blockElements );\n\t}\n\n\t/**\n\t * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n\t *\n\t * @param {Selection} DOM Selection instance to check.\n\t * @returns {Boolean}\n\t */\n\tisDomSelectionBackward( selection ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n\t\t// we will use the fact that range will collapse if it's end is before it's start.\n\t\tconst range = document.createRange();\n\n\t\trange.setStart( selection.anchorNode, selection.anchorOffset );\n\t\trange.setEnd( selection.focusNode, selection.focusOffset );\n\n\t\tconst backward = range.collapsed;\n\n\t\trange.detach();\n\n\t\treturn backward;\n\t}\n\n\t/**\n\t * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no\n\t * parent UIElement.\n\t *\n\t * @param {Node} domNode\n\t * @returns {module:engine/view/uielement~UIElement|null}\n\t */\n\tgetParentUIElement( domNode ) {\n\t\tconst ancestors = getAncestors( domNode );\n\n\t\t// Remove domNode from the list.\n\t\tancestors.pop();\n\n\t\twhile ( ancestors.length ) {\n\t\t\tconst domNode = ancestors.pop();\n\t\t\tconst viewNode = this._domToViewMapping.get( domNode );\n\n\t\t\tif ( viewNode && viewNode.is( 'uiElement' ) ) {\n\t\t\t\treturn viewNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if given selection's boundaries are at correct places.\n\t *\n\t * The following places are considered as incorrect for selection boundaries:\n\t * * before or in the middle of the inline filler sequence,\n\t * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.\n\t *\n\t * @param {Selection} domSelection DOM Selection object to be checked.\n\t * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n\t */\n\tisDomSelectionCorrect( domSelection ) {\n\t\treturn this._isDomSelectionPositionCorrect( domSelection.anchorNode, domSelection.anchorOffset ) &&\n\t\t\tthis._isDomSelectionPositionCorrect( domSelection.focusNode, domSelection.focusOffset );\n\t}\n\n\t/**\n\t * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n\t *\n\t * @private\n\t * @param {Element} domParent Position parent.\n\t * @param {Number} offset Position offset.\n\t * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n\t */\n\t_isDomSelectionPositionCorrect( domParent, offset ) {\n\t\t// If selection is before or in the middle of inline filler string, it is incorrect.\n\t\tif ( isText( domParent ) && startsWithFiller( domParent ) && offset < INLINE_FILLER_LENGTH ) {\n\t\t\t// Selection in a text node, at wrong position (before or in the middle of filler).\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isElement( domParent ) && startsWithFiller( domParent.childNodes[ offset ] ) ) {\n\t\t\t// Selection in an element node, before filler text node.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t// If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`\n\t\t// also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).\n\t\tif ( viewParent && viewParent.is( 'uiElement' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n\t * it is correctly displayed in the DOM.\n\t *\n\t * Following changes are done:\n\t *\n\t * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n\t * element or if a previous text node ends with a space character,\n\t * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container,\n\t * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n\t *\n\t * Content of {@link #preElements} is not processed.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node View text node to process.\n\t * @returns {String} Processed text data.\n\t */\n\t_processDataFromViewText( node ) {\n\t\tlet data = node.data;\n\n\t\t// If any of node ancestors has a name which is in `preElements` array, then currently processed\n\t\t// view text node is (will be) in preformatted element. We should not change whitespaces then.\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn data;\n\t\t}\n\n\t\t// 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n\t\t// (container element boundary).\n\t\tif ( data.charAt( 0 ) == ' ' ) {\n\t\t\tconst prevNode = this._getTouchingViewTextNode( node, false );\n\t\t\tconst prevEndsWithSpace = prevNode && this._nodeEndsWithSpace( prevNode );\n\n\t\t\tif ( prevEndsWithSpace || !prevNode ) {\n\t\t\t\tdata = '\\u00A0' + data.substr( 1 );\n\t\t\t}\n\t\t}\n\n\t\t// 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n\t\t// next node (container element boundary).\n\t\t//\n\t\t// Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n\t\t//\n\t\t// Foo <span>&nbsp;bar</span>  <-- bad.\n\t\t// Foo&nbsp;<span> bar</span>  <-- good.\n\t\t//\n\t\t// More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\t\tif ( data.charAt( data.length - 1 ) == ' ' ) {\n\t\t\tconst nextNode = this._getTouchingViewTextNode( node, true );\n\n\t\t\tif ( data.charAt( data.length - 2 ) == ' ' || !nextNode || nextNode.data.charAt( 0 ) == ' ' ) {\n\t\t\t\tdata = data.substr( 0, data.length - 1 ) + '\\u00A0';\n\t\t\t}\n\t\t}\n\n\t\t// 3. Create space+nbsp pairs.\n\t\treturn data.replace( / {2}/g, ' \\u00A0' );\n\t}\n\n\t/**\n\t * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Node to check.\n\t * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n\t */\n\t_nodeEndsWithSpace( node ) {\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst data = this._processDataFromViewText( node );\n\n\t\treturn data.charAt( data.length - 1 ) == ' ';\n\t}\n\n\t/**\n\t * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n\t *\n\t * Following changes are done:\n\t *\n\t * * multiple whitespaces are replaced to a single space,\n\t * * space at the beginning of a text node is removed if it is the first text node in its container\n\t * element or if the previous text node ends with a space character,\n\t * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container\n\t * * nbsps are converted to spaces.\n\t *\n\t * @param {Node} node DOM text node to process.\n\t * @returns {String} Processed data.\n\t * @private\n\t */\n\t_processDataFromDomText( node ) {\n\t\tlet data = node.data;\n\n\t\tif ( _hasDomParentOfType( node, this.preElements ) ) {\n\t\t\treturn getDataWithoutFiller( node );\n\t\t}\n\n\t\t// Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n\t\t// That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n\t\t// We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\t\tdata = data.replace( /[ \\n\\t\\r]{1,}/g, ' ' );\n\n\t\tconst prevNode = this._getTouchingInlineDomNode( node, false );\n\t\tconst nextNode = this._getTouchingInlineDomNode( node, true );\n\n\t\tconst shouldLeftTrim = this._checkShouldLeftTrimDomText( prevNode );\n\t\tconst shouldRightTrim = this._checkShouldRightTrimDomText( node, nextNode );\n\n\t\t// If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n\t\t// of this text node. Such space character is treated as a whitespace.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^ /, '' );\n\t\t}\n\n\t\t// If the next text node does not exist remove space character from the end of this text node.\n\t\tif ( shouldRightTrim ) {\n\t\t\tdata = data.replace( / $/, '' );\n\t\t}\n\n\t\t// At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n\t\t// This means that the text node starts/end with normal space instead of non-breaking space.\n\t\t// This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n\t\t// the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\t\tdata = getDataWithoutFiller( new Text( data ) );\n\n\t\t// At this point we should have removed all whitespaces from DOM text data.\n\t\t//\n\t\t// Now, We will reverse the process that happens in `_processDataFromViewText`.\n\t\t//\n\t\t// We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n\t\t// First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n\t\t// ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\t\tdata = data.replace( / \\u00A0/g, '  ' );\n\n\t\t// Then, let's change the last nbsp to a space.\n\t\tif ( /( |\\u00A0)\\u00A0$/.test( data ) || !nextNode || ( nextNode.data && nextNode.data.charAt( 0 ) == ' ' ) ) {\n\t\t\tdata = data.replace( /\\u00A0$/, ' ' );\n\t\t}\n\n\t\t// Then, change &nbsp; character that is at the beginning of the text node to space character.\n\t\t// We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^\\u00A0/, ' ' );\n\t\t}\n\n\t\t// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n\t\t// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\t\treturn data;\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n\t * be trimmed from the left side.\n\t *\n\t * @param {Node} prevNode\n\t */\n\t_checkShouldLeftTrimDomText( prevNode ) {\n\t\tif ( !prevNode ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( isElement( prevNode ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn /[^\\S\\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) );\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n\t * be trimmed from the right side.\n\t *\n\t * @param {Node} node\n\t * @param {Node} nextNode\n\t */\n\t_checkShouldRightTrimDomText( node, nextNode ) {\n\t\tif ( nextNode ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !startsWithFiller( node );\n\t}\n\n\t/**\n\t * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n\t * that is contained in the same container element. If there is no such sibling, `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} node Reference node.\n\t * @param {Boolean} getNext\n\t * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n\t */\n\t_getTouchingViewTextNode( node, getNext ) {\n\t\tconst treeWalker = new ViewTreeWalker( {\n\t\t\tstartPosition: getNext ? ViewPosition._createAfter( node ) : ViewPosition._createBefore( node ),\n\t\t\tdirection: getNext ? 'forward' : 'backward'\n\t\t} );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\t// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n\t\t\t// text node in its container element.\n\t\t\tif ( value.item.is( 'containerElement' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// <br> found – it works like a block boundary, so do not scan further.\n\t\t\telse if ( value.item.is( 'br' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Found a text node in the same container element.\n\t\t\telse if ( value.item.is( 'textProxy' ) ) {\n\t\t\t\treturn value.item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Helper function. For the given text node, it finds the closest touching node which is either\n\t * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n\t * wasn't found so far, `null` is returned.\n\t *\n\t * In the following DOM structure:\n\t *\n\t *\t\t<p>foo<b>bar</b><br>bom</p>\n\t *\n\t * * `foo` doesn't have its previous touching inline node (`null` is returned),\n\t * * `foo`'s next touching inline node is `bar`\n\t * * `bar`'s next touching inline node is `<br>`\n\t *\n\t * This method returns text nodes and `<br>` elements because these types of nodes affect how\n\t * spaces in the given text node need to be converted.\n\t *\n\t * @private\n\t * @param {Text} node\n\t * @param {Boolean} getNext\n\t * @returns {Text|Element|null}\n\t */\n\t_getTouchingInlineDomNode( node, getNext ) {\n\t\tif ( !node.parentNode ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst direction = getNext ? 'nextNode' : 'previousNode';\n\t\tconst document = node.ownerDocument;\n\t\tconst topmostParent = getAncestors( node )[ 0 ];\n\n\t\tconst treeWalker = document.createTreeWalker( topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode( node ) {\n\t\t\t\tif ( isText( node ) ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\tif ( node.tagName == 'BR' ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\t\t}\n\t\t} );\n\n\t\ttreeWalker.currentNode = node;\n\n\t\tconst touchingNode = treeWalker[ direction ]();\n\n\t\tif ( touchingNode !== null ) {\n\t\t\tconst lca = getCommonAncestor( node, touchingNode );\n\n\t\t\t// If there is common ancestor between the text node and next/prev text node,\n\t\t\t// and there are no block elements on a way from the text node to that ancestor,\n\t\t\t// and there are no block elements on a way from next/prev text node to that ancestor...\n\t\t\tif (\n\t\t\t\tlca &&\n\t\t\t\t!_hasDomParentOfType( node, this.blockElements, lca ) &&\n\t\t\t\t!_hasDomParentOfType( touchingNode, this.blockElements, lca )\n\t\t\t) {\n\t\t\t\t// Then they are in the same container element.\n\t\t\t\treturn touchingNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType( node, types, boundaryParent ) {\n\tlet parents = getAncestors( node );\n\n\tif ( boundaryParent ) {\n\t\tparents = parents.slice( parents.indexOf( boundaryParent ) + 1 );\n\t}\n\n\treturn parents.some( parent => parent.tagName && types.includes( parent.tagName.toLowerCase() ) );\n}\n\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomNodeAncestor( node, callback ) {\n\twhile ( node && node != global.document ) {\n\t\tcallback( node );\n\t\tnode = node.parentNode;\n\t}\n}\n\n// Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\nfunction isNbspBlockFiller( domNode, blockElements ) {\n\tconst isNBSP = isText( domNode ) && domNode.data == '\\u00A0';\n\n\treturn isNBSP && hasBlockParent( domNode, blockElements ) && domNode.parentNode.childNodes.length === 1;\n}\n\n// Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\nfunction hasBlockParent( domNode, blockElements ) {\n\tconst parent = domNode.parentNode;\n\n\treturn parent && parent.tagName && blockElements.includes( parent.tagName.toLowerCase() );\n}\n\n/**\n * Enum representing type of the block filler.\n *\n * Possible values:\n *\n * * `br` - for `<br>` block filler used in editing view,\n * * `nbsp` - for `&nbsp;` block fillers used in the data.\n *\n * @typedef {String} module:engine/view/filler~BlockFillerMode\n */\n"]},"metadata":{},"sourceType":"module"}