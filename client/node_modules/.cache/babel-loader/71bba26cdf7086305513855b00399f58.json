{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/documentselection\n */\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport Selection from './selection';\nimport LiveRange from './liverange';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\nconst storePrefix = 'selection:';\n/**\n * `DocumentSelection` is a special selection which is used as the\n * {@link module:engine/model/document~Document#selection document's selection}.\n * There can be only one instance of `DocumentSelection` per document.\n *\n * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance\n * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.\n *\n * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n *\n * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:\n * * there is always a range in `DocumentSelection` - even if no ranges were added there is a \"default range\"\n * present in the selection,\n * * ranges added to this selection updates automatically when the document changes,\n * * attributes of `DocumentSelection` are updated automatically according to selection ranges.\n *\n * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}\n * and is updated when {@link module:engine/model/document~Document document}\n * changes, it cannot be set on {@link module:engine/model/node~Node nodes}\n * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n * If you need to represent a selection in document fragment,\n * use {@link module:engine/model/selection~Selection Selection class} instead.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class DocumentSelection {\n  /**\n   * Creates an empty live selection for given {@link module:engine/model/document~Document}.\n   *\n   * @param {module:engine/model/document~Document} doc Document which owns this selection.\n   */\n  constructor(doc) {\n    /**\n     * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).\n     *\n     * @protected\n     */\n    this._selection = new LiveSelection(doc);\n\n    this._selection.delegate('change:range').to(this);\n\n    this._selection.delegate('change:attribute').to(this);\n\n    this._selection.delegate('change:marker').to(this);\n  }\n  /**\n   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n   * collapsed.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isCollapsed() {\n    return this._selection.isCollapsed;\n  }\n  /**\n   * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n   * Together with {@link #focus} they define the direction of selection, which is important\n   * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n   * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n   *\n   * Is set to `null` if there are no ranges in selection.\n   *\n   * @see #focus\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n\n\n  get anchor() {\n    return this._selection.anchor;\n  }\n  /**\n   * Selection focus. Focus is a position where the selection ends.\n   *\n   * Is set to `null` if there are no ranges in selection.\n   *\n   * @see #anchor\n   * @readonly\n   * @type {module:engine/model/position~Position|null}\n   */\n\n\n  get focus() {\n    return this._selection.focus;\n  }\n  /**\n   * Returns number of ranges in selection.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get rangeCount() {\n    return this._selection.rangeCount;\n  }\n  /**\n   * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to\n   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get hasOwnRange() {\n    return this._selection.hasOwnRange;\n  }\n  /**\n   * Specifies whether the {@link #focus}\n   * precedes {@link #anchor}.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isBackward() {\n    return this._selection.isBackward;\n  }\n  /**\n   * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.\n   *\n   * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.\n   *\n   * @readonly\n   * @returns {Boolean}\n   */\n\n\n  get isGravityOverridden() {\n    return this._selection.isGravityOverridden;\n  }\n  /**\n   * A collection of selection markers.\n   * Marker is a selection marker when selection range is inside the marker range.\n   *\n   * @readonly\n   * @type {module:utils/collection~Collection.<module:engine/model/markercollection~Marker>}\n   */\n\n\n  get markers() {\n    return this._selection.markers;\n  }\n  /**\n   * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.\n   *\n   * @protected\n   */\n\n\n  get _ranges() {\n    return this._selection._ranges;\n  }\n  /**\n   * Returns an iterable that iterates over copies of selection ranges.\n   *\n   * @returns {Iterable.<module:engine/model/range~Range>}\n   */\n\n\n  getRanges() {\n    return this._selection.getRanges();\n  }\n  /**\n   * Returns the first position in the selection.\n   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n\n\n  getFirstPosition() {\n    return this._selection.getFirstPosition();\n  }\n  /**\n   * Returns the last position in the selection.\n   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n   * any other position in the selection.\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/position~Position|null}\n   */\n\n\n  getLastPosition() {\n    return this._selection.getLastPosition();\n  }\n  /**\n   * Returns a copy of the first range in the selection.\n   * First range is the one which {@link module:engine/model/range~Range#start start} position\n   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n   * (not to confuse with the first range added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getFirstRange() {\n    return this._selection.getFirstRange();\n  }\n  /**\n   * Returns a copy of the last range in the selection.\n   * Last range is the one which {@link module:engine/model/range~Range#end end} position\n   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n   * recently added to the selection).\n   *\n   * Returns `null` if there are no ranges in selection.\n   *\n   * @returns {module:engine/model/range~Range|null}\n   */\n\n\n  getLastRange() {\n    return this._selection.getLastRange();\n  }\n  /**\n   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n   *\n   * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n   *\n   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n   * but will not return blocks nested in other blocks.\n   *\n   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<blockQuote>\n   *\t\t\t<paragraph>b</paragraph>\n   *\t\t</blockQuote>\n   *\t\t<paragraph>c]d</paragraph>\n   *\n   * In this case the paragraph will also be returned, despite the collapsed selection:\n   *\n   *\t\t<paragraph>[]a</paragraph>\n   *\n   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n   *\n   *\t\t[<blockA></blockA>\n   *\t\t<blockB>\n   *\t\t\t<blockC></blockC>\n   *\t\t\t<blockD></blockD>\n   *\t\t</blockB>\n   *\t\t<blockE></blockE>]\n   *\n   * If the selection is inside a block all the inner blocks (A & B) are returned:\n   *\n   * \t\t<block>\n   *\t\t\t<blockA>[a</blockA>\n   * \t\t\t<blockB>b]</blockB>\n   * \t\t</block>\n   *\n   * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n   * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n   *\n   *\t\t<paragraph>[a</paragraph>\n   *\t\t<paragraph>b</paragraph>\n   *\t\t<paragraph>]c</paragraph> // this block will not be returned\n   *\n   * @returns {Iterable.<module:engine/model/element~Element>}\n   */\n\n\n  getSelectedBlocks() {\n    return this._selection.getSelectedBlocks();\n  }\n  /**\n   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n   * one range in the selection, and that range contains exactly one element.\n   * Returns `null` if there is no selected element.\n   *\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  getSelectedElement() {\n    return this._selection.getSelectedElement();\n  }\n  /**\n   * Checks whether the selection contains the entire content of the given element. This means that selection must start\n   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n   * touching the element's end.\n   *\n   * By default, this method will check whether the entire content of the selection's current root is selected.\n   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n   *\n   * @param {module:engine/model/element~Element} [element=this.anchor.root]\n   * @returns {Boolean}\n   */\n\n\n  containsEntireContent(element) {\n    return this._selection.containsEntireContent(element);\n  }\n  /**\n   * Unbinds all events previously bound by document selection.\n   */\n\n\n  destroy() {\n    this._selection.destroy();\n  }\n  /**\n   * Returns iterable that iterates over this selection's attribute keys.\n   *\n   * @returns {Iterable.<String>}\n   */\n\n\n  getAttributeKeys() {\n    return this._selection.getAttributeKeys();\n  }\n  /**\n   * Returns iterable that iterates over this selection's attributes.\n   *\n   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n   *\n   * @returns {Iterable.<*>}\n   */\n\n\n  getAttributes() {\n    return this._selection.getAttributes();\n  }\n  /**\n   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n   *\n   * @param {String} key Key of attribute to look for.\n   * @returns {*} Attribute value or `undefined`.\n   */\n\n\n  getAttribute(key) {\n    return this._selection.getAttribute(key);\n  }\n  /**\n   * Checks if the selection has an attribute for given key.\n   *\n   * @param {String} key Key of attribute to check.\n   * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n   */\n\n\n  hasAttribute(key) {\n    return this._selection.hasAttribute(key);\n  }\n  /**\n   * Refreshes selection attributes and markers according to the current position in the model.\n   */\n\n\n  refresh() {\n    this._selection._updateMarkers();\n\n    this._selection._updateAttributes(false);\n  }\n  /**\n   * Checks whether this object is of the given type.\n   *\n   *\t\tselection.is( 'selection' ); // -> true\n   *\t\tselection.is( 'documentSelection' ); // -> true\n   *\t\tselection.is( 'model:selection' ); // -> true\n   *\t\tselection.is( 'model:documentSelection' ); // -> true\n   *\n   *\t\tselection.is( 'view:selection' ); // -> false\n   *\t\tselection.is( 'element' ); // -> false\n   *\t\tselection.is( 'node' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type === 'selection' || type == 'model:selection' || type == 'documentSelection' || type == 'model:documentSelection';\n  }\n  /**\n   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.\n   *\n   * The location can be specified in the same form as\n   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n   *\n   * @see module:engine/model/writer~Writer#setSelectionFocus\n   * @protected\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   */\n\n\n  _setFocus(itemOrPosition, offset) {\n    this._selection.setFocus(itemOrPosition, offset);\n  }\n  /**\n   * Sets this selection's ranges and direction to the specified location based on the given\n   * {@link module:engine/model/selection~Selectable selectable}.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.\n   *\n   * @see module:engine/model/writer~Writer#setSelection\n   * @protected\n   * @param {module:engine/model/selection~Selectable} selectable\n   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n   * @param {Object} [options]\n   * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n   */\n\n\n  _setTo(selectable, placeOrOffset, options) {\n    this._selection.setTo(selectable, placeOrOffset, options);\n  }\n  /**\n   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.\n   *\n   * @see module:engine/model/writer~Writer#setSelectionAttribute\n   * @protected\n   * @param {String} key Key of the attribute to set.\n   * @param {*} value Attribute value.\n   */\n\n\n  _setAttribute(key, value) {\n    this._selection.setAttribute(key, value);\n  }\n  /**\n   * Removes an attribute with given key from the selection.\n   * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}\n   * event with removed attribute key.\n   * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.\n   *\n   * @see module:engine/model/writer~Writer#removeSelectionAttribute\n   * @protected\n   * @param {String} key Key of the attribute to remove.\n   */\n\n\n  _removeAttribute(key) {\n    this._selection.removeAttribute(key);\n  }\n  /**\n   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n   *\n   * @protected\n   * @returns {Iterable.<*>}\n   */\n\n\n  _getStoredAttributes() {\n    return this._selection._getStoredAttributes();\n  }\n  /**\n   * Temporarily changes the gravity of the selection from the left to the right.\n   *\n   * The gravity defines from which direction the selection inherits its attributes. If it's the default left\n   * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.\n   * This method allows to temporarily override this behavior by forcing the gravity to the right.\n   *\n   * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n   * of the process.\n   *\n   * @see module:engine/model/writer~Writer#overrideSelectionGravity\n   * @protected\n   * @returns {String} The unique id which allows restoring the gravity.\n   */\n\n\n  _overrideGravity() {\n    return this._selection.overrideGravity();\n  }\n  /**\n   * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.\n   *\n   * Restoring the gravity is only possible using the unique identifier returned by\n   * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored\n   * the same number of times it was overridden.\n   *\n   * @see module:engine/model/writer~Writer#restoreSelectionGravity\n   * @protected\n   * @param {String} uid The unique id returned by {@link #_overrideGravity}.\n   */\n\n\n  _restoreGravity(uid) {\n    this._selection.restoreGravity(uid);\n  }\n  /**\n   * Generates and returns an attribute key for selection attributes store, basing on original attribute key.\n   *\n   * @protected\n   * @param {String} key Attribute key to convert.\n   * @returns {String} Converted attribute key, applicable for selection store.\n   */\n\n\n  static _getStoreAttributeKey(key) {\n    return storePrefix + key;\n  }\n  /**\n   * Checks whether the given attribute key is an attribute stored on an element.\n   *\n   * @protected\n   * @param {String} key\n   * @returns {Boolean}\n   */\n\n\n  static _isStoreAttributeKey(key) {\n    return key.startsWith(storePrefix);\n  }\n\n}\nmix(DocumentSelection, EmitterMixin);\n/**\n * Fired when selection range(s) changed.\n *\n * @event change:range\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed because the structure of the model has been changed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n */\n\n/**\n * Fired when selection attribute changed.\n *\n * @event change:attribute\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed in the model and its attributes were refreshed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n */\n\n/**\n * Fired when selection marker(s) changed.\n *\n * @event change:marker\n * @param {Boolean} directChange This is always set to `false` in case of `change:marker` event as there is no possibility\n * to change markers directly through {@link module:engine/model/documentselection~DocumentSelection} API.\n * See also {@link module:engine/model/documentselection~DocumentSelection#event:change:range} and\n * {@link module:engine/model/documentselection~DocumentSelection#event:change:attribute}.\n * @param {Array.<module:engine/model/markercollection~Marker>} oldMarkers Markers in which the selection was before the change.\n */\n// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.\n//\n// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n//\n// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:\n// * there is always a range in `LiveSelection` - even if no ranges were added there is a \"default range\"\n// present in the selection,\n// * ranges added to this selection updates automatically when the document changes,\n// * attributes of `LiveSelection` are updated automatically according to selection ranges.\n//\n// @extends module:engine/model/selection~Selection\n//\n\nclass LiveSelection extends Selection {\n  // Creates an empty live selection for given {@link module:engine/model/document~Document}.\n  // @param {module:engine/model/document~Document} doc Document which owns this selection.\n  constructor(doc) {\n    super(); // List of selection markers.\n    // Marker is a selection marker when selection range is inside the marker range.\n    //\n    // @type {module:utils/collection~Collection}\n\n    this.markers = new Collection({\n      idProperty: 'name'\n    }); // Document which owns this selection.\n    //\n    // @protected\n    // @member {module:engine/model/model~Model}\n\n    this._model = doc.model; // Document which owns this selection.\n    //\n    // @protected\n    // @member {module:engine/model/document~Document}\n\n    this._document = doc; // Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)\n    // last time. Possible values of priority are: `'low'` and `'normal'`.\n    //\n    // Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`\n    // attributes API are set with `'normal'` priority.\n    //\n    // @private\n    // @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority\n\n    this._attributePriority = new Map(); // Contains data required to fix ranges which have been moved to the graveyard.\n    // @private\n    // @member {Array} module:engine/model/liveselection~LiveSelection#_fixGraveyardRangesData\n\n    this._fixGraveyardRangesData = []; // Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.\n    // @private\n    // @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange\n\n    this._hasChangedRange = false; // Each overriding gravity adds an UID to the set and each removal removes it.\n    // Gravity is overridden when there's at least one UID in the set.\n    // Gravity is restored when the set is empty.\n    // This is to prevent conflicts when gravity is overridden by more than one feature at the same time.\n    // @private\n    // @type {Set}\n\n    this._overriddenGravityRegister = new Set(); // Ensure selection is correct after each operation.\n\n    this.listenTo(this._model, 'applyOperation', (evt, args) => {\n      const operation = args[0];\n\n      if (!operation.isDocumentOperation || operation.type == 'marker' || operation.type == 'rename' || operation.type == 'noop') {\n        return;\n      }\n\n      while (this._fixGraveyardRangesData.length) {\n        const {\n          liveRange,\n          sourcePosition\n        } = this._fixGraveyardRangesData.shift();\n\n        this._fixGraveyardSelection(liveRange, sourcePosition);\n      }\n\n      if (this._hasChangedRange) {\n        this._hasChangedRange = false;\n        this.fire('change:range', {\n          directChange: false\n        });\n      }\n    }, {\n      priority: 'lowest'\n    }); // Ensure selection is correct and up to date after each range change.\n\n    this.on('change:range', () => {\n      for (const range of this.getRanges()) {\n        if (!this._document._validateSelectionRange(range)) {\n          /**\n           * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}\n           * starts or ends at incorrect position.\n           *\n           * @error document-selection-wrong-position\n           * @param {module:engine/model/range~Range} range\n           */\n          throw new CKEditorError('document-selection-wrong-position: Range from document selection starts or ends at incorrect position.', this, {\n            range\n          });\n        }\n      }\n    }); // Update markers data stored by the selection after each marker change.\n\n    this.listenTo(this._model.markers, 'update', () => this._updateMarkers()); // Ensure selection is up to date after each change block.\n\n    this.listenTo(this._document, 'change', (evt, batch) => {\n      clearAttributesStoredInElement(this._model, batch);\n    });\n  }\n\n  get isCollapsed() {\n    const length = this._ranges.length;\n    return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;\n  }\n\n  get anchor() {\n    return super.anchor || this._document._getDefaultRange().start;\n  }\n\n  get focus() {\n    return super.focus || this._document._getDefaultRange().end;\n  }\n\n  get rangeCount() {\n    return this._ranges.length ? this._ranges.length : 1;\n  } // Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to\n  // {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n  //\n  // @readonly\n  // @type {Boolean}\n\n\n  get hasOwnRange() {\n    return this._ranges.length > 0;\n  } // When set to `true` then selection attributes on node before the caret won't be taken\n  // into consideration while updating selection attributes.\n  //\n  // @protected\n  // @type {Boolean}\n\n\n  get isGravityOverridden() {\n    return !!this._overriddenGravityRegister.size;\n  } // Unbinds all events previously bound by live selection.\n\n\n  destroy() {\n    for (let i = 0; i < this._ranges.length; i++) {\n      this._ranges[i].detach();\n    }\n\n    this.stopListening();\n  }\n\n  *getRanges() {\n    if (this._ranges.length) {\n      yield* super.getRanges();\n    } else {\n      yield this._document._getDefaultRange();\n    }\n  }\n\n  getFirstRange() {\n    return super.getFirstRange() || this._document._getDefaultRange();\n  }\n\n  getLastRange() {\n    return super.getLastRange() || this._document._getDefaultRange();\n  }\n\n  setTo(selectable, optionsOrPlaceOrOffset, options) {\n    super.setTo(selectable, optionsOrPlaceOrOffset, options);\n\n    this._updateAttributes(true);\n\n    this._updateMarkers();\n  }\n\n  setFocus(itemOrPosition, offset) {\n    super.setFocus(itemOrPosition, offset);\n\n    this._updateAttributes(true);\n\n    this._updateMarkers();\n  }\n\n  setAttribute(key, value) {\n    if (this._setAttribute(key, value)) {\n      // Fire event with exact data.\n      const attributeKeys = [key];\n      this.fire('change:attribute', {\n        attributeKeys,\n        directChange: true\n      });\n    }\n  }\n\n  removeAttribute(key) {\n    if (this._removeAttribute(key)) {\n      // Fire event with exact data.\n      const attributeKeys = [key];\n      this.fire('change:attribute', {\n        attributeKeys,\n        directChange: true\n      });\n    }\n  }\n\n  overrideGravity() {\n    const overrideUid = uid(); // Remember that another overriding has been requested. It will need to be removed\n    // before the gravity is to be restored.\n\n    this._overriddenGravityRegister.add(overrideUid);\n\n    if (this._overriddenGravityRegister.size === 1) {\n      this._updateAttributes(true);\n    }\n\n    return overrideUid;\n  }\n\n  restoreGravity(uid) {\n    if (!this._overriddenGravityRegister.has(uid)) {\n      /**\n       * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct\n       * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.\n       *\n       * @error document-selection-gravity-wrong-restore\n       * @param {String} uid The unique identifier returned by\n       * {@link module:engine/model/documentselection~DocumentSelection#_overrideGravity}.\n       */\n      throw new CKEditorError('document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.', this, {\n        uid\n      });\n    }\n\n    this._overriddenGravityRegister.delete(uid); // Restore gravity only when all overriding have been restored.\n\n\n    if (!this.isGravityOverridden) {\n      this._updateAttributes(true);\n    }\n  }\n\n  _popRange() {\n    this._ranges.pop().detach();\n  }\n\n  _pushRange(range) {\n    const liveRange = this._prepareRange(range); // `undefined` is returned when given `range` is in graveyard root.\n\n\n    if (liveRange) {\n      this._ranges.push(liveRange);\n    }\n  } // Prepares given range to be added to selection. Checks if it is correct,\n  // converts it to {@link module:engine/model/liverange~LiveRange LiveRange}\n  // and sets listeners listening to the range's change event.\n  //\n  // @private\n  // @param {module:engine/model/range~Range} range\n\n\n  _prepareRange(range) {\n    this._checkRange(range);\n\n    if (range.root == this._document.graveyard) {\n      // @if CK_DEBUG // console.warn( 'Trying to add a Range that is in the graveyard root. Range rejected.' );\n      return;\n    }\n\n    const liveRange = LiveRange.fromRange(range);\n    liveRange.on('change:range', (evt, oldRange, data) => {\n      this._hasChangedRange = true; // If `LiveRange` is in whole moved to the graveyard, save necessary data. It will be fixed on `Model#applyOperation` event.\n\n      if (liveRange.root == this._document.graveyard) {\n        this._fixGraveyardRangesData.push({\n          liveRange,\n          sourcePosition: data.deletionPosition\n        });\n      }\n    });\n    return liveRange;\n  }\n\n  _updateMarkers() {\n    const markers = [];\n    let changed = false;\n\n    for (const marker of this._model.markers) {\n      const markerRange = marker.getRange();\n\n      for (const selectionRange of this.getRanges()) {\n        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {\n          markers.push(marker);\n        }\n      }\n    }\n\n    const oldMarkers = Array.from(this.markers);\n\n    for (const marker of markers) {\n      if (!this.markers.has(marker)) {\n        this.markers.add(marker);\n        changed = true;\n      }\n    }\n\n    for (const marker of Array.from(this.markers)) {\n      if (!markers.includes(marker)) {\n        this.markers.remove(marker);\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this.fire('change:marker', {\n        oldMarkers,\n        directChange: false\n      });\n    }\n  } // Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.\n  //\n  // @protected\n  // @param {Boolean} clearAll\n  // @fires change:attribute\n\n\n  _updateAttributes(clearAll) {\n    const newAttributes = toMap(this._getSurroundingAttributes());\n    const oldAttributes = toMap(this.getAttributes());\n\n    if (clearAll) {\n      // If `clearAll` remove all attributes and reset priorities.\n      this._attributePriority = new Map();\n      this._attrs = new Map();\n    } else {\n      // If not, remove only attributes added with `low` priority.\n      for (const [key, priority] of this._attributePriority) {\n        if (priority == 'low') {\n          this._attrs.delete(key);\n\n          this._attributePriority.delete(key);\n        }\n      }\n    }\n\n    this._setAttributesTo(newAttributes); // Let's evaluate which attributes really changed.\n\n\n    const changed = []; // First, loop through all attributes that are set on selection right now.\n    // Check which of them are different than old attributes.\n\n    for (const [newKey, newValue] of this.getAttributes()) {\n      if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {\n        changed.push(newKey);\n      }\n    } // Then, check which of old attributes got removed.\n\n\n    for (const [oldKey] of oldAttributes) {\n      if (!this.hasAttribute(oldKey)) {\n        changed.push(oldKey);\n      }\n    } // Fire event with exact data (fire only if anything changed).\n\n\n    if (changed.length > 0) {\n      this.fire('change:attribute', {\n        attributeKeys: changed,\n        directChange: false\n      });\n    }\n  } // Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n  // parameter).\n  //\n  // @private\n  // @param {String} key Attribute key.\n  // @param {*} value Attribute value.\n  // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n  // is caused by `Batch` API.\n  // @returns {Boolean} Whether value has changed.\n\n\n  _setAttribute(key, value, directChange = true) {\n    const priority = directChange ? 'normal' : 'low';\n\n    if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n      // Priority too low.\n      return false;\n    }\n\n    const oldValue = super.getAttribute(key); // Don't do anything if value has not changed.\n\n    if (oldValue === value) {\n      return false;\n    }\n\n    this._attrs.set(key, value); // Update priorities map.\n\n\n    this._attributePriority.set(key, priority);\n\n    return true;\n  } // Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n  // parameter).\n  //\n  // NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will\n  // be changed according to `directChange` parameter.\n  //\n  // @private\n  // @param {String} key Attribute key.\n  // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n  // is caused by `Batch` API.\n  // @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the\n  // existing attribute had higher priority.\n\n\n  _removeAttribute(key, directChange = true) {\n    const priority = directChange ? 'normal' : 'low';\n\n    if (priority == 'low' && this._attributePriority.get(key) == 'normal') {\n      // Priority too low.\n      return false;\n    } // Update priorities map.\n\n\n    this._attributePriority.set(key, priority); // Don't do anything if value has not changed.\n\n\n    if (!super.hasAttribute(key)) {\n      return false;\n    }\n\n    this._attrs.delete(key);\n\n    return true;\n  } // Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through\n  // `directChange` parameter).\n  //\n  // @private\n  // @param {Map.<String,*>} attrs Iterable object containing attributes to be set.\n  // @returns {Set.<String>} Changed attribute keys.\n\n\n  _setAttributesTo(attrs) {\n    const changed = new Set();\n\n    for (const [oldKey, oldValue] of this.getAttributes()) {\n      // Do not remove attribute if attribute with same key and value is about to be set.\n      if (attrs.get(oldKey) === oldValue) {\n        continue;\n      } // All rest attributes will be removed so changed attributes won't change .\n\n\n      this._removeAttribute(oldKey, false);\n    }\n\n    for (const [key, value] of attrs) {\n      // Attribute may not be set because of attributes or because same key/value is already added.\n      const gotAdded = this._setAttribute(key, value, false);\n\n      if (gotAdded) {\n        changed.add(key);\n      }\n    }\n\n    return changed;\n  } // Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n  //\n  // @protected\n  // @returns {Iterable.<*>}\n\n\n  *_getStoredAttributes() {\n    const selectionParent = this.getFirstPosition().parent;\n\n    if (this.isCollapsed && selectionParent.isEmpty) {\n      for (const key of selectionParent.getAttributeKeys()) {\n        if (key.startsWith(storePrefix)) {\n          const realKey = key.substr(storePrefix.length);\n          yield [realKey, selectionParent.getAttribute(key)];\n        }\n      }\n    }\n  } // Checks model text nodes that are closest to the selection's first position and returns attributes of first\n  // found element. If there are no text nodes in selection's first position parent, it returns selection\n  // attributes stored in that parent.\n  //\n  // @private\n  // @returns {Iterable.<*>} Collection of attributes.\n\n\n  _getSurroundingAttributes() {\n    const position = this.getFirstPosition();\n    const schema = this._model.schema;\n    let attrs = null;\n\n    if (!this.isCollapsed) {\n      // 1. If selection is a range...\n      const range = this.getFirstRange(); // ...look for a first character node in that range and take attributes from it.\n\n      for (const value of range) {\n        // If the item is an object, we don't want to get attributes from its children.\n        if (value.item.is('element') && schema.isObject(value.item)) {\n          break;\n        }\n\n        if (value.type == 'text') {\n          attrs = value.item.getAttributes();\n          break;\n        }\n      }\n    } else {\n      // 2. If the selection is a caret or the range does not contain a character node...\n      const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;\n      const nodeAfter = position.textNode ? position.textNode : position.nodeAfter; // When gravity is overridden then don't take node before into consideration.\n\n      if (!this.isGravityOverridden) {\n        // ...look at the node before caret and take attributes from it if it is a character node.\n        attrs = getAttrsIfCharacter(nodeBefore);\n      } // 3. If not, look at the node after caret...\n\n\n      if (!attrs) {\n        attrs = getAttrsIfCharacter(nodeAfter);\n      } // 4. If not, try to find the first character on the left, that is in the same node.\n      // When gravity is overridden then don't take node before into consideration.\n\n\n      if (!this.isGravityOverridden && !attrs) {\n        let node = nodeBefore;\n\n        while (node && !attrs) {\n          node = node.previousSibling;\n          attrs = getAttrsIfCharacter(node);\n        }\n      } // 5. If not found, try to find the first character on the right, that is in the same node.\n\n\n      if (!attrs) {\n        let node = nodeAfter;\n\n        while (node && !attrs) {\n          node = node.nextSibling;\n          attrs = getAttrsIfCharacter(node);\n        }\n      } // 6. If not found, selection should retrieve attributes from parent.\n\n\n      if (!attrs) {\n        attrs = this._getStoredAttributes();\n      }\n    }\n\n    return attrs;\n  } // Fixes a selection range after it ends up in graveyard root.\n  //\n  // @private\n  // @param {module:engine/model/liverange~LiveRange} liveRange The range from selection, that ended up in the graveyard root.\n  // @param {module:engine/model/position~Position} removedRangeStart Start position of a range which was removed.\n\n\n  _fixGraveyardSelection(liveRange, removedRangeStart) {\n    // The start of the removed range is the closest position to the `liveRange` - the original selection range.\n    // This is a good candidate for a fixed selection range.\n    const positionCandidate = removedRangeStart.clone(); // Find a range that is a correct selection range and is closest to the start of removed range.\n\n    const selectionRange = this._model.schema.getNearestSelectionRange(positionCandidate); // Remove the old selection range before preparing and adding new selection range. This order is important,\n    // because new range, in some cases, may intersect with old range (it depends on `getNearestSelectionRange()` result).\n\n\n    const index = this._ranges.indexOf(liveRange);\n\n    this._ranges.splice(index, 1);\n\n    liveRange.detach(); // If nearest valid selection range has been found - add it in the place of old range.\n    // If range is equal to any other selection ranges then it is probably due to contents\n    // of a multi-range selection being removed. See ckeditor/ckeditor5#6501.\n\n    if (selectionRange && !isRangeCollidingWithSelection(selectionRange, this)) {\n      // Check the range, convert it to live range, bind events, etc.\n      const newRange = this._prepareRange(selectionRange); // Add new range in the place of old range.\n\n\n      this._ranges.splice(index, 0, newRange);\n    } // If nearest valid selection range cannot be found or is intersecting with other selection ranges removing the old range is fine.\n\n  }\n\n} // Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.\n//\n// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.\n//\n// @param {module:engine/model/item~Item|null}  node\n// @returns {Boolean}\n\n\nfunction getAttrsIfCharacter(node) {\n  if (node instanceof TextProxy || node instanceof Text) {\n    return node.getAttributes();\n  }\n\n  return null;\n} // Removes selection attributes from element which is not empty anymore.\n//\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/model/batch~Batch} batch\n\n\nfunction clearAttributesStoredInElement(model, batch) {\n  const differ = model.document.differ;\n\n  for (const entry of differ.getChanges()) {\n    if (entry.type != 'insert') {\n      continue;\n    }\n\n    const changeParent = entry.position.parent;\n    const isNoLongerEmpty = entry.length === changeParent.maxOffset;\n\n    if (isNoLongerEmpty) {\n      model.enqueueChange(batch, writer => {\n        const storedAttributes = Array.from(changeParent.getAttributeKeys()).filter(key => key.startsWith(storePrefix));\n\n        for (const key of storedAttributes) {\n          writer.removeAttribute(key, changeParent);\n        }\n      });\n    }\n  }\n} // Checks if range collides with any of selection ranges.\n\n\nfunction isRangeCollidingWithSelection(range, selection) {\n  return !selection._ranges.every(selectionRange => !range.isEqual(selectionRange));\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/model/documentselection.js"],"names":["mix","EmitterMixin","Selection","LiveRange","Text","TextProxy","toMap","Collection","CKEditorError","uid","storePrefix","DocumentSelection","constructor","doc","_selection","LiveSelection","delegate","to","isCollapsed","anchor","focus","rangeCount","hasOwnRange","isBackward","isGravityOverridden","markers","_ranges","getRanges","getFirstPosition","getLastPosition","getFirstRange","getLastRange","getSelectedBlocks","getSelectedElement","containsEntireContent","element","destroy","getAttributeKeys","getAttributes","getAttribute","key","hasAttribute","refresh","_updateMarkers","_updateAttributes","is","type","_setFocus","itemOrPosition","offset","setFocus","_setTo","selectable","placeOrOffset","options","setTo","_setAttribute","value","setAttribute","_removeAttribute","removeAttribute","_getStoredAttributes","_overrideGravity","overrideGravity","_restoreGravity","restoreGravity","_getStoreAttributeKey","_isStoreAttributeKey","startsWith","idProperty","_model","model","_document","_attributePriority","Map","_fixGraveyardRangesData","_hasChangedRange","_overriddenGravityRegister","Set","listenTo","evt","args","operation","isDocumentOperation","length","liveRange","sourcePosition","shift","_fixGraveyardSelection","fire","directChange","priority","on","range","_validateSelectionRange","batch","clearAttributesStoredInElement","_getDefaultRange","start","end","size","i","detach","stopListening","optionsOrPlaceOrOffset","attributeKeys","overrideUid","add","has","delete","_popRange","pop","_pushRange","_prepareRange","push","_checkRange","root","graveyard","fromRange","oldRange","data","deletionPosition","changed","marker","markerRange","getRange","selectionRange","containsRange","oldMarkers","Array","from","includes","remove","clearAll","newAttributes","_getSurroundingAttributes","oldAttributes","_attrs","_setAttributesTo","newKey","newValue","get","oldKey","oldValue","set","attrs","gotAdded","selectionParent","parent","isEmpty","realKey","substr","position","schema","item","isObject","nodeBefore","textNode","nodeAfter","getAttrsIfCharacter","node","previousSibling","nextSibling","removedRangeStart","positionCandidate","clone","getNearestSelectionRange","index","indexOf","splice","isRangeCollidingWithSelection","newRange","differ","document","entry","getChanges","changeParent","isNoLongerEmpty","maxOffset","enqueueChange","writer","storedAttributes","filter","selection","every","isEqual"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/documentselection\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\n\nimport Selection from './selection';\nimport LiveRange from './liverange';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport uid from '@ckeditor/ckeditor5-utils/src/uid';\n\nconst storePrefix = 'selection:';\n\n/**\n * `DocumentSelection` is a special selection which is used as the\n * {@link module:engine/model/document~Document#selection document's selection}.\n * There can be only one instance of `DocumentSelection` per document.\n *\n * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance\n * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.\n *\n * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n *\n * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:\n * * there is always a range in `DocumentSelection` - even if no ranges were added there is a \"default range\"\n * present in the selection,\n * * ranges added to this selection updates automatically when the document changes,\n * * attributes of `DocumentSelection` are updated automatically according to selection ranges.\n *\n * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}\n * and is updated when {@link module:engine/model/document~Document document}\n * changes, it cannot be set on {@link module:engine/model/node~Node nodes}\n * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n * If you need to represent a selection in document fragment,\n * use {@link module:engine/model/selection~Selection Selection class} instead.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class DocumentSelection {\n\t/**\n\t * Creates an empty live selection for given {@link module:engine/model/document~Document}.\n\t *\n\t * @param {module:engine/model/document~Document} doc Document which owns this selection.\n\t */\n\tconstructor( doc ) {\n\t\t/**\n\t\t * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).\n\t\t *\n\t\t * @protected\n\t\t */\n\t\tthis._selection = new LiveSelection( doc );\n\n\t\tthis._selection.delegate( 'change:range' ).to( this );\n\t\tthis._selection.delegate( 'change:attribute' ).to( this );\n\t\tthis._selection.delegate( 'change:marker' ).to( this );\n\t}\n\n\t/**\n\t * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is\n\t * collapsed.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this._selection.isCollapsed;\n\t}\n\n\t/**\n\t * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.\n\t * Together with {@link #focus} they define the direction of selection, which is important\n\t * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or\n\t * {@link module:engine/model/range~Range#end end} position of the most recently added range.\n\t *\n\t * Is set to `null` if there are no ranges in selection.\n\t *\n\t * @see #focus\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget anchor() {\n\t\treturn this._selection.anchor;\n\t}\n\n\t/**\n\t * Selection focus. Focus is a position where the selection ends.\n\t *\n\t * Is set to `null` if there are no ranges in selection.\n\t *\n\t * @see #anchor\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget focus() {\n\t\treturn this._selection.focus;\n\t}\n\n\t/**\n\t * Returns number of ranges in selection.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._selection.rangeCount;\n\t}\n\n\t/**\n\t * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to\n\t * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget hasOwnRange() {\n\t\treturn this._selection.hasOwnRange;\n\t}\n\n\t/**\n\t * Specifies whether the {@link #focus}\n\t * precedes {@link #anchor}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn this._selection.isBackward;\n\t}\n\n\t/**\n\t * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.\n\t *\n\t * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.\n\t *\n\t * @readonly\n\t * @returns {Boolean}\n\t */\n\tget isGravityOverridden() {\n\t\treturn this._selection.isGravityOverridden;\n\t}\n\n\t/**\n\t * A collection of selection markers.\n\t * Marker is a selection marker when selection range is inside the marker range.\n\t *\n\t * @readonly\n\t * @type {module:utils/collection~Collection.<module:engine/model/markercollection~Marker>}\n\t */\n\tget markers() {\n\t\treturn this._selection.markers;\n\t}\n\n\t/**\n\t * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.\n\t *\n\t * @protected\n\t */\n\tget _ranges() {\n\t\treturn this._selection._ranges;\n\t}\n\n\t/**\n\t * Returns an iterable that iterates over copies of selection ranges.\n\t *\n\t * @returns {Iterable.<module:engine/model/range~Range>}\n\t */\n\tgetRanges() {\n\t\treturn this._selection.getRanges();\n\t}\n\n\t/**\n\t * Returns the first position in the selection.\n\t * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\treturn this._selection.getFirstPosition();\n\t}\n\n\t/**\n\t * Returns the last position in the selection.\n\t * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\treturn this._selection.getLastPosition();\n\t}\n\n\t/**\n\t * Returns a copy of the first range in the selection.\n\t * First range is the one which {@link module:engine/model/range~Range#start start} position\n\t * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n\t * (not to confuse with the first range added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\treturn this._selection.getFirstRange();\n\t}\n\n\t/**\n\t * Returns a copy of the last range in the selection.\n\t * Last range is the one which {@link module:engine/model/range~Range#end end} position\n\t * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n\t * recently added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\treturn this._selection.getLastRange();\n\t}\n\n\t/**\n\t * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n\t *\n\t * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n\t *\n\t * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n\t * but will not return blocks nested in other blocks.\n\t *\n\t * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<blockQuote>\n\t *\t\t\t<paragraph>b</paragraph>\n\t *\t\t</blockQuote>\n\t *\t\t<paragraph>c]d</paragraph>\n\t *\n\t * In this case the paragraph will also be returned, despite the collapsed selection:\n\t *\n\t *\t\t<paragraph>[]a</paragraph>\n\t *\n\t * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n\t *\n\t *\t\t[<blockA></blockA>\n\t *\t\t<blockB>\n\t *\t\t\t<blockC></blockC>\n\t *\t\t\t<blockD></blockD>\n\t *\t\t</blockB>\n\t *\t\t<blockE></blockE>]\n\t *\n\t * If the selection is inside a block all the inner blocks (A & B) are returned:\n\t *\n\t * \t\t<block>\n\t *\t\t\t<blockA>[a</blockA>\n\t * \t\t\t<blockB>b]</blockB>\n\t * \t\t</block>\n\t *\n\t * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n\t * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<paragraph>b</paragraph>\n\t *\t\t<paragraph>]c</paragraph> // this block will not be returned\n\t *\n\t * @returns {Iterable.<module:engine/model/element~Element>}\n\t */\n\tgetSelectedBlocks() {\n\t\treturn this._selection.getSelectedBlocks();\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\treturn this._selection.getSelectedElement();\n\t}\n\n\t/**\n\t * Checks whether the selection contains the entire content of the given element. This means that selection must start\n\t * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n\t * touching the element's end.\n\t *\n\t * By default, this method will check whether the entire content of the selection's current root is selected.\n\t * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n\t *\n\t * @param {module:engine/model/element~Element} [element=this.anchor.root]\n\t * @returns {Boolean}\n\t */\n\tcontainsEntireContent( element ) {\n\t\treturn this._selection.containsEntireContent( element );\n\t}\n\n\t/**\n\t * Unbinds all events previously bound by document selection.\n\t */\n\tdestroy() {\n\t\tthis._selection.destroy();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._selection.getAttributeKeys();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._selection.getAttributes();\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._selection.getAttribute( key );\n\t}\n\n\t/**\n\t * Checks if the selection has an attribute for given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._selection.hasAttribute( key );\n\t}\n\n\t/**\n\t * Refreshes selection attributes and markers according to the current position in the model.\n\t */\n\trefresh() {\n\t\tthis._selection._updateMarkers();\n\t\tthis._selection._updateAttributes( false );\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\tselection.is( 'selection' ); // -> true\n\t *\t\tselection.is( 'documentSelection' ); // -> true\n\t *\t\tselection.is( 'model:selection' ); // -> true\n\t *\t\tselection.is( 'model:documentSelection' ); // -> true\n\t *\n\t *\t\tselection.is( 'view:selection' ); // -> false\n\t *\t\tselection.is( 'element' ); // -> false\n\t *\t\tselection.is( 'node' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type === 'selection' ||\n\t\t\ttype == 'model:selection' ||\n\t\t\ttype == 'documentSelection' ||\n\t\t\ttype == 'model:documentSelection';\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.\n\t *\n\t * The location can be specified in the same form as\n\t * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelectionFocus\n\t * @protected\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\t_setFocus( itemOrPosition, offset ) {\n\t\tthis._selection.setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/model/selection~Selectable selectable}.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelection\n\t * @protected\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\t_setTo( selectable, placeOrOffset, options ) {\n\t\tthis._selection.setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.\n\t *\n\t * @see module:engine/model/writer~Writer#setSelectionAttribute\n\t * @protected\n\t * @param {String} key Key of the attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\t_setAttribute( key, value ) {\n\t\tthis._selection.setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the selection.\n\t * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}\n\t * event with removed attribute key.\n\t * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.\n\t *\n\t * @see module:engine/model/writer~Writer#removeSelectionAttribute\n\t * @protected\n\t * @param {String} key Key of the attribute to remove.\n\t */\n\t_removeAttribute( key ) {\n\t\tthis._selection.removeAttribute( key );\n\t}\n\n\t/**\n\t * Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n\t *\n\t * @protected\n\t * @returns {Iterable.<*>}\n\t */\n\t_getStoredAttributes() {\n\t\treturn this._selection._getStoredAttributes();\n\t}\n\n\t/**\n\t * Temporarily changes the gravity of the selection from the left to the right.\n\t *\n\t * The gravity defines from which direction the selection inherits its attributes. If it's the default left\n\t * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.\n\t * This method allows to temporarily override this behavior by forcing the gravity to the right.\n\t *\n\t * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n\t * of the process.\n\t *\n\t * @see module:engine/model/writer~Writer#overrideSelectionGravity\n\t * @protected\n\t * @returns {String} The unique id which allows restoring the gravity.\n\t */\n\t_overrideGravity() {\n\t\treturn this._selection.overrideGravity();\n\t}\n\n\t/**\n\t * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.\n\t *\n\t * Restoring the gravity is only possible using the unique identifier returned by\n\t * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored\n\t * the same number of times it was overridden.\n\t *\n\t * @see module:engine/model/writer~Writer#restoreSelectionGravity\n\t * @protected\n\t * @param {String} uid The unique id returned by {@link #_overrideGravity}.\n\t */\n\t_restoreGravity( uid ) {\n\t\tthis._selection.restoreGravity( uid );\n\t}\n\n\t/**\n\t * Generates and returns an attribute key for selection attributes store, basing on original attribute key.\n\t *\n\t * @protected\n\t * @param {String} key Attribute key to convert.\n\t * @returns {String} Converted attribute key, applicable for selection store.\n\t */\n\tstatic _getStoreAttributeKey( key ) {\n\t\treturn storePrefix + key;\n\t}\n\n\t/**\n\t * Checks whether the given attribute key is an attribute stored on an element.\n\t *\n\t * @protected\n\t * @param {String} key\n\t * @returns {Boolean}\n\t */\n\tstatic _isStoreAttributeKey( key ) {\n\t\treturn key.startsWith( storePrefix );\n\t}\n}\n\nmix( DocumentSelection, EmitterMixin );\n\n/**\n * Fired when selection range(s) changed.\n *\n * @event change:range\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed because the structure of the model has been changed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n */\n\n/**\n * Fired when selection attribute changed.\n *\n * @event change:attribute\n * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n * changed in the model and its attributes were refreshed (which means an indirect change).\n * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n * which mean that they are not updated once the document changes.\n * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n */\n\n/**\n * Fired when selection marker(s) changed.\n *\n * @event change:marker\n * @param {Boolean} directChange This is always set to `false` in case of `change:marker` event as there is no possibility\n * to change markers directly through {@link module:engine/model/documentselection~DocumentSelection} API.\n * See also {@link module:engine/model/documentselection~DocumentSelection#event:change:range} and\n * {@link module:engine/model/documentselection~DocumentSelection#event:change:attribute}.\n * @param {Array.<module:engine/model/markercollection~Marker>} oldMarkers Markers in which the selection was before the change.\n */\n\n// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.\n//\n// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}\n// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.\n//\n// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:\n// * there is always a range in `LiveSelection` - even if no ranges were added there is a \"default range\"\n// present in the selection,\n// * ranges added to this selection updates automatically when the document changes,\n// * attributes of `LiveSelection` are updated automatically according to selection ranges.\n//\n// @extends module:engine/model/selection~Selection\n//\n\nclass LiveSelection extends Selection {\n\t// Creates an empty live selection for given {@link module:engine/model/document~Document}.\n\t// @param {module:engine/model/document~Document} doc Document which owns this selection.\n\tconstructor( doc ) {\n\t\tsuper();\n\n\t\t// List of selection markers.\n\t\t// Marker is a selection marker when selection range is inside the marker range.\n\t\t//\n\t\t// @type {module:utils/collection~Collection}\n\t\tthis.markers = new Collection( { idProperty: 'name' } );\n\n\t\t// Document which owns this selection.\n\t\t//\n\t\t// @protected\n\t\t// @member {module:engine/model/model~Model}\n\t\tthis._model = doc.model;\n\n\t\t// Document which owns this selection.\n\t\t//\n\t\t// @protected\n\t\t// @member {module:engine/model/document~Document}\n\t\tthis._document = doc;\n\n\t\t// Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)\n\t\t// last time. Possible values of priority are: `'low'` and `'normal'`.\n\t\t//\n\t\t// Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`\n\t\t// attributes API are set with `'normal'` priority.\n\t\t//\n\t\t// @private\n\t\t// @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority\n\t\tthis._attributePriority = new Map();\n\n\t\t// Contains data required to fix ranges which have been moved to the graveyard.\n\t\t// @private\n\t\t// @member {Array} module:engine/model/liveselection~LiveSelection#_fixGraveyardRangesData\n\t\tthis._fixGraveyardRangesData = [];\n\n\t\t// Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.\n\t\t// @private\n\t\t// @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange\n\t\tthis._hasChangedRange = false;\n\n\t\t// Each overriding gravity adds an UID to the set and each removal removes it.\n\t\t// Gravity is overridden when there's at least one UID in the set.\n\t\t// Gravity is restored when the set is empty.\n\t\t// This is to prevent conflicts when gravity is overridden by more than one feature at the same time.\n\t\t// @private\n\t\t// @type {Set}\n\t\tthis._overriddenGravityRegister = new Set();\n\n\t\t// Ensure selection is correct after each operation.\n\t\tthis.listenTo( this._model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( !operation.isDocumentOperation || operation.type == 'marker' || operation.type == 'rename' || operation.type == 'noop' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twhile ( this._fixGraveyardRangesData.length ) {\n\t\t\t\tconst { liveRange, sourcePosition } = this._fixGraveyardRangesData.shift();\n\n\t\t\t\tthis._fixGraveyardSelection( liveRange, sourcePosition );\n\t\t\t}\n\n\t\t\tif ( this._hasChangedRange ) {\n\t\t\t\tthis._hasChangedRange = false;\n\t\t\t\tthis.fire( 'change:range', { directChange: false } );\n\t\t\t}\n\t\t}, { priority: 'lowest' } );\n\n\t\t// Ensure selection is correct and up to date after each range change.\n\t\tthis.on( 'change:range', () => {\n\t\t\tfor ( const range of this.getRanges() ) {\n\t\t\t\tif ( !this._document._validateSelectionRange( range ) ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}\n\t\t\t\t\t * starts or ends at incorrect position.\n\t\t\t\t\t *\n\t\t\t\t\t * @error document-selection-wrong-position\n\t\t\t\t\t * @param {module:engine/model/range~Range} range\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t'document-selection-wrong-position: Range from document selection starts or ends at incorrect position.',\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\t{ range }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Update markers data stored by the selection after each marker change.\n\t\tthis.listenTo( this._model.markers, 'update', () => this._updateMarkers() );\n\n\t\t// Ensure selection is up to date after each change block.\n\t\tthis.listenTo( this._document, 'change', ( evt, batch ) => {\n\t\t\tclearAttributesStoredInElement( this._model, batch );\n\t\t} );\n\t}\n\n\tget isCollapsed() {\n\t\tconst length = this._ranges.length;\n\n\t\treturn length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;\n\t}\n\n\tget anchor() {\n\t\treturn super.anchor || this._document._getDefaultRange().start;\n\t}\n\n\tget focus() {\n\t\treturn super.focus || this._document._getDefaultRange().end;\n\t}\n\n\tget rangeCount() {\n\t\treturn this._ranges.length ? this._ranges.length : 1;\n\t}\n\n\t// Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to\n\t// {@link module:engine/model/document~Document#_getDefaultRange document's default range}.\n\t//\n\t// @readonly\n\t// @type {Boolean}\n\tget hasOwnRange() {\n\t\treturn this._ranges.length > 0;\n\t}\n\n\t// When set to `true` then selection attributes on node before the caret won't be taken\n\t// into consideration while updating selection attributes.\n\t//\n\t// @protected\n\t// @type {Boolean}\n\tget isGravityOverridden() {\n\t\treturn !!this._overriddenGravityRegister.size;\n\t}\n\n\t// Unbinds all events previously bound by live selection.\n\tdestroy() {\n\t\tfor ( let i = 0; i < this._ranges.length; i++ ) {\n\t\t\tthis._ranges[ i ].detach();\n\t\t}\n\n\t\tthis.stopListening();\n\t}\n\n\t* getRanges() {\n\t\tif ( this._ranges.length ) {\n\t\t\tyield* super.getRanges();\n\t\t} else {\n\t\t\tyield this._document._getDefaultRange();\n\t\t}\n\t}\n\n\tgetFirstRange() {\n\t\treturn super.getFirstRange() || this._document._getDefaultRange();\n\t}\n\n\tgetLastRange() {\n\t\treturn super.getLastRange() || this._document._getDefaultRange();\n\t}\n\n\tsetTo( selectable, optionsOrPlaceOrOffset, options ) {\n\t\tsuper.setTo( selectable, optionsOrPlaceOrOffset, options );\n\t\tthis._updateAttributes( true );\n\t\tthis._updateMarkers();\n\t}\n\n\tsetFocus( itemOrPosition, offset ) {\n\t\tsuper.setFocus( itemOrPosition, offset );\n\t\tthis._updateAttributes( true );\n\t\tthis._updateMarkers();\n\t}\n\n\tsetAttribute( key, value ) {\n\t\tif ( this._setAttribute( key, value ) ) {\n\t\t\t// Fire event with exact data.\n\t\t\tconst attributeKeys = [ key ];\n\t\t\tthis.fire( 'change:attribute', { attributeKeys, directChange: true } );\n\t\t}\n\t}\n\n\tremoveAttribute( key ) {\n\t\tif ( this._removeAttribute( key ) ) {\n\t\t\t// Fire event with exact data.\n\t\t\tconst attributeKeys = [ key ];\n\t\t\tthis.fire( 'change:attribute', { attributeKeys, directChange: true } );\n\t\t}\n\t}\n\n\toverrideGravity() {\n\t\tconst overrideUid = uid();\n\n\t\t// Remember that another overriding has been requested. It will need to be removed\n\t\t// before the gravity is to be restored.\n\t\tthis._overriddenGravityRegister.add( overrideUid );\n\n\t\tif ( this._overriddenGravityRegister.size === 1 ) {\n\t\t\tthis._updateAttributes( true );\n\t\t}\n\n\t\treturn overrideUid;\n\t}\n\n\trestoreGravity( uid ) {\n\t\tif ( !this._overriddenGravityRegister.has( uid ) ) {\n\t\t\t/**\n\t\t\t * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct\n\t\t\t * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.\n\t\t\t *\n\t\t\t * @error document-selection-gravity-wrong-restore\n\t\t\t * @param {String} uid The unique identifier returned by\n\t\t\t * {@link module:engine/model/documentselection~DocumentSelection#_overrideGravity}.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.',\n\t\t\t\tthis,\n\t\t\t\t{ uid }\n\t\t\t);\n\t\t}\n\n\t\tthis._overriddenGravityRegister.delete( uid );\n\n\t\t// Restore gravity only when all overriding have been restored.\n\t\tif ( !this.isGravityOverridden ) {\n\t\t\tthis._updateAttributes( true );\n\t\t}\n\t}\n\n\t_popRange() {\n\t\tthis._ranges.pop().detach();\n\t}\n\n\t_pushRange( range ) {\n\t\tconst liveRange = this._prepareRange( range );\n\n\t\t// `undefined` is returned when given `range` is in graveyard root.\n\t\tif ( liveRange ) {\n\t\t\tthis._ranges.push( liveRange );\n\t\t}\n\t}\n\n\t// Prepares given range to be added to selection. Checks if it is correct,\n\t// converts it to {@link module:engine/model/liverange~LiveRange LiveRange}\n\t// and sets listeners listening to the range's change event.\n\t//\n\t// @private\n\t// @param {module:engine/model/range~Range} range\n\t_prepareRange( range ) {\n\t\tthis._checkRange( range );\n\n\t\tif ( range.root == this._document.graveyard ) {\n\t\t\t// @if CK_DEBUG // console.warn( 'Trying to add a Range that is in the graveyard root. Range rejected.' );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst liveRange = LiveRange.fromRange( range );\n\n\t\tliveRange.on( 'change:range', ( evt, oldRange, data ) => {\n\t\t\tthis._hasChangedRange = true;\n\n\t\t\t// If `LiveRange` is in whole moved to the graveyard, save necessary data. It will be fixed on `Model#applyOperation` event.\n\t\t\tif ( liveRange.root == this._document.graveyard ) {\n\t\t\t\tthis._fixGraveyardRangesData.push( {\n\t\t\t\t\tliveRange,\n\t\t\t\t\tsourcePosition: data.deletionPosition\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\treturn liveRange;\n\t}\n\n\t_updateMarkers() {\n\t\tconst markers = [];\n\t\tlet changed = false;\n\n\t\tfor ( const marker of this._model.markers ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tfor ( const selectionRange of this.getRanges() ) {\n\t\t\t\tif ( markerRange.containsRange( selectionRange, !selectionRange.isCollapsed ) ) {\n\t\t\t\t\tmarkers.push( marker );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst oldMarkers = Array.from( this.markers );\n\n\t\tfor ( const marker of markers ) {\n\t\t\tif ( !this.markers.has( marker ) ) {\n\t\t\t\tthis.markers.add( marker );\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tfor ( const marker of Array.from( this.markers ) ) {\n\t\t\tif ( !markers.includes( marker ) ) {\n\t\t\t\tthis.markers.remove( marker );\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( changed ) {\n\t\t\tthis.fire( 'change:marker', { oldMarkers, directChange: false } );\n\t\t}\n\t}\n\n\t// Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.\n\t//\n\t// @protected\n\t// @param {Boolean} clearAll\n\t// @fires change:attribute\n\t_updateAttributes( clearAll ) {\n\t\tconst newAttributes = toMap( this._getSurroundingAttributes() );\n\t\tconst oldAttributes = toMap( this.getAttributes() );\n\n\t\tif ( clearAll ) {\n\t\t\t// If `clearAll` remove all attributes and reset priorities.\n\t\t\tthis._attributePriority = new Map();\n\t\t\tthis._attrs = new Map();\n\t\t} else {\n\t\t\t// If not, remove only attributes added with `low` priority.\n\t\t\tfor ( const [ key, priority ] of this._attributePriority ) {\n\t\t\t\tif ( priority == 'low' ) {\n\t\t\t\t\tthis._attrs.delete( key );\n\t\t\t\t\tthis._attributePriority.delete( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._setAttributesTo( newAttributes );\n\n\t\t// Let's evaluate which attributes really changed.\n\t\tconst changed = [];\n\n\t\t// First, loop through all attributes that are set on selection right now.\n\t\t// Check which of them are different than old attributes.\n\t\tfor ( const [ newKey, newValue ] of this.getAttributes() ) {\n\t\t\tif ( !oldAttributes.has( newKey ) || oldAttributes.get( newKey ) !== newValue ) {\n\t\t\t\tchanged.push( newKey );\n\t\t\t}\n\t\t}\n\n\t\t// Then, check which of old attributes got removed.\n\t\tfor ( const [ oldKey ] of oldAttributes ) {\n\t\t\tif ( !this.hasAttribute( oldKey ) ) {\n\t\t\t\tchanged.push( oldKey );\n\t\t\t}\n\t\t}\n\n\t\t// Fire event with exact data (fire only if anything changed).\n\t\tif ( changed.length > 0 ) {\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: changed, directChange: false } );\n\t\t}\n\t}\n\n\t// Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n\t// parameter).\n\t//\n\t// @private\n\t// @param {String} key Attribute key.\n\t// @param {*} value Attribute value.\n\t// @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n\t// is caused by `Batch` API.\n\t// @returns {Boolean} Whether value has changed.\n\t_setAttribute( key, value, directChange = true ) {\n\t\tconst priority = directChange ? 'normal' : 'low';\n\n\t\tif ( priority == 'low' && this._attributePriority.get( key ) == 'normal' ) {\n\t\t\t// Priority too low.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst oldValue = super.getAttribute( key );\n\n\t\t// Don't do anything if value has not changed.\n\t\tif ( oldValue === value ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._attrs.set( key, value );\n\n\t\t// Update priorities map.\n\t\tthis._attributePriority.set( key, priority );\n\n\t\treturn true;\n\t}\n\n\t// Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`\n\t// parameter).\n\t//\n\t// NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will\n\t// be changed according to `directChange` parameter.\n\t//\n\t// @private\n\t// @param {String} key Attribute key.\n\t// @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change\n\t// is caused by `Batch` API.\n\t// @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the\n\t// existing attribute had higher priority.\n\t_removeAttribute( key, directChange = true ) {\n\t\tconst priority = directChange ? 'normal' : 'low';\n\n\t\tif ( priority == 'low' && this._attributePriority.get( key ) == 'normal' ) {\n\t\t\t// Priority too low.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Update priorities map.\n\t\tthis._attributePriority.set( key, priority );\n\n\t\t// Don't do anything if value has not changed.\n\t\tif ( !super.hasAttribute( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._attrs.delete( key );\n\n\t\treturn true;\n\t}\n\n\t// Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through\n\t// `directChange` parameter).\n\t//\n\t// @private\n\t// @param {Map.<String,*>} attrs Iterable object containing attributes to be set.\n\t// @returns {Set.<String>} Changed attribute keys.\n\t_setAttributesTo( attrs ) {\n\t\tconst changed = new Set();\n\n\t\tfor ( const [ oldKey, oldValue ] of this.getAttributes() ) {\n\t\t\t// Do not remove attribute if attribute with same key and value is about to be set.\n\t\t\tif ( attrs.get( oldKey ) === oldValue ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// All rest attributes will be removed so changed attributes won't change .\n\t\t\tthis._removeAttribute( oldKey, false );\n\t\t}\n\n\t\tfor ( const [ key, value ] of attrs ) {\n\t\t\t// Attribute may not be set because of attributes or because same key/value is already added.\n\t\t\tconst gotAdded = this._setAttribute( key, value, false );\n\n\t\t\tif ( gotAdded ) {\n\t\t\t\tchanged.add( key );\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n\n\t// Returns an iterable that iterates through all selection attributes stored in current selection's parent.\n\t//\n\t// @protected\n\t// @returns {Iterable.<*>}\n\t* _getStoredAttributes() {\n\t\tconst selectionParent = this.getFirstPosition().parent;\n\n\t\tif ( this.isCollapsed && selectionParent.isEmpty ) {\n\t\t\tfor ( const key of selectionParent.getAttributeKeys() ) {\n\t\t\t\tif ( key.startsWith( storePrefix ) ) {\n\t\t\t\t\tconst realKey = key.substr( storePrefix.length );\n\n\t\t\t\t\tyield [ realKey, selectionParent.getAttribute( key ) ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Checks model text nodes that are closest to the selection's first position and returns attributes of first\n\t// found element. If there are no text nodes in selection's first position parent, it returns selection\n\t// attributes stored in that parent.\n\t//\n\t// @private\n\t// @returns {Iterable.<*>} Collection of attributes.\n\t_getSurroundingAttributes() {\n\t\tconst position = this.getFirstPosition();\n\t\tconst schema = this._model.schema;\n\n\t\tlet attrs = null;\n\n\t\tif ( !this.isCollapsed ) {\n\t\t\t// 1. If selection is a range...\n\t\t\tconst range = this.getFirstRange();\n\n\t\t\t// ...look for a first character node in that range and take attributes from it.\n\t\t\tfor ( const value of range ) {\n\t\t\t\t// If the item is an object, we don't want to get attributes from its children.\n\t\t\t\tif ( value.item.is( 'element' ) && schema.isObject( value.item ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( value.type == 'text' ) {\n\t\t\t\t\tattrs = value.item.getAttributes();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// 2. If the selection is a caret or the range does not contain a character node...\n\n\t\t\tconst nodeBefore = position.textNode ? position.textNode : position.nodeBefore;\n\t\t\tconst nodeAfter = position.textNode ? position.textNode : position.nodeAfter;\n\n\t\t\t// When gravity is overridden then don't take node before into consideration.\n\t\t\tif ( !this.isGravityOverridden ) {\n\t\t\t\t// ...look at the node before caret and take attributes from it if it is a character node.\n\t\t\t\tattrs = getAttrsIfCharacter( nodeBefore );\n\t\t\t}\n\n\t\t\t// 3. If not, look at the node after caret...\n\t\t\tif ( !attrs ) {\n\t\t\t\tattrs = getAttrsIfCharacter( nodeAfter );\n\t\t\t}\n\n\t\t\t// 4. If not, try to find the first character on the left, that is in the same node.\n\t\t\t// When gravity is overridden then don't take node before into consideration.\n\t\t\tif ( !this.isGravityOverridden && !attrs ) {\n\t\t\t\tlet node = nodeBefore;\n\n\t\t\t\twhile ( node && !attrs ) {\n\t\t\t\t\tnode = node.previousSibling;\n\t\t\t\t\tattrs = getAttrsIfCharacter( node );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 5. If not found, try to find the first character on the right, that is in the same node.\n\t\t\tif ( !attrs ) {\n\t\t\t\tlet node = nodeAfter;\n\n\t\t\t\twhile ( node && !attrs ) {\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\tattrs = getAttrsIfCharacter( node );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 6. If not found, selection should retrieve attributes from parent.\n\t\t\tif ( !attrs ) {\n\t\t\t\tattrs = this._getStoredAttributes();\n\t\t\t}\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\t// Fixes a selection range after it ends up in graveyard root.\n\t//\n\t// @private\n\t// @param {module:engine/model/liverange~LiveRange} liveRange The range from selection, that ended up in the graveyard root.\n\t// @param {module:engine/model/position~Position} removedRangeStart Start position of a range which was removed.\n\t_fixGraveyardSelection( liveRange, removedRangeStart ) {\n\t\t// The start of the removed range is the closest position to the `liveRange` - the original selection range.\n\t\t// This is a good candidate for a fixed selection range.\n\t\tconst positionCandidate = removedRangeStart.clone();\n\n\t\t// Find a range that is a correct selection range and is closest to the start of removed range.\n\t\tconst selectionRange = this._model.schema.getNearestSelectionRange( positionCandidate );\n\n\t\t// Remove the old selection range before preparing and adding new selection range. This order is important,\n\t\t// because new range, in some cases, may intersect with old range (it depends on `getNearestSelectionRange()` result).\n\t\tconst index = this._ranges.indexOf( liveRange );\n\t\tthis._ranges.splice( index, 1 );\n\t\tliveRange.detach();\n\n\t\t// If nearest valid selection range has been found - add it in the place of old range.\n\t\t// If range is equal to any other selection ranges then it is probably due to contents\n\t\t// of a multi-range selection being removed. See ckeditor/ckeditor5#6501.\n\t\tif ( selectionRange && !isRangeCollidingWithSelection( selectionRange, this ) ) {\n\t\t\t// Check the range, convert it to live range, bind events, etc.\n\t\t\tconst newRange = this._prepareRange( selectionRange );\n\n\t\t\t// Add new range in the place of old range.\n\t\t\tthis._ranges.splice( index, 0, newRange );\n\t\t}\n\t\t// If nearest valid selection range cannot be found or is intersecting with other selection ranges removing the old range is fine.\n\t}\n}\n\n// Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.\n//\n// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.\n//\n// @param {module:engine/model/item~Item|null}  node\n// @returns {Boolean}\nfunction getAttrsIfCharacter( node ) {\n\tif ( node instanceof TextProxy || node instanceof Text ) {\n\t\treturn node.getAttributes();\n\t}\n\n\treturn null;\n}\n\n// Removes selection attributes from element which is not empty anymore.\n//\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/model/batch~Batch} batch\nfunction clearAttributesStoredInElement( model, batch ) {\n\tconst differ = model.document.differ;\n\n\tfor ( const entry of differ.getChanges() ) {\n\t\tif ( entry.type != 'insert' ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst changeParent = entry.position.parent;\n\t\tconst isNoLongerEmpty = entry.length === changeParent.maxOffset;\n\n\t\tif ( isNoLongerEmpty ) {\n\t\t\tmodel.enqueueChange( batch, writer => {\n\t\t\t\tconst storedAttributes = Array.from( changeParent.getAttributeKeys() )\n\t\t\t\t\t.filter( key => key.startsWith( storePrefix ) );\n\n\t\t\t\tfor ( const key of storedAttributes ) {\n\t\t\t\t\twriter.removeAttribute( key, changeParent );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t}\n}\n\n// Checks if range collides with any of selection ranges.\nfunction isRangeCollidingWithSelection( range, selection ) {\n\treturn !selection._ranges.every( selectionRange => !range.isEqual( selectionRange ) );\n}\n"]},"metadata":{},"sourceType":"module"}