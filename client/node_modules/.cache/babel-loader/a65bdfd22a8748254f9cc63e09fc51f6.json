{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/element\n */\nimport Node from './node';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable'; // @if CK_DEBUG_ENGINE // const { stringifyMap, convertMapToStringifiedObject, convertMapToTags } = require( '../dev-utils/utils' );\n\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends module:engine/model/node~Node\n */\n\nexport default class Element extends Node {\n  /**\n   * Creates a model element.\n   *\n   * **Note:** Constructor of this class shouldn't be used directly in the code.\n   * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n   *\n   * @protected\n   * @param {String} name Element's name.\n   * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n   * One or more nodes to be inserted as children of created element.\n   */\n  constructor(name, attrs, children) {\n    super(attrs);\n    /**\n     * Element name.\n     *\n     * @readonly\n     * @member {String} module:engine/model/element~Element#name\n     */\n\n    this.name = name;\n    /**\n     * List of children nodes.\n     *\n     * @private\n     * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n     */\n\n    this._children = new NodeList();\n\n    if (children) {\n      this._insertChild(0, children);\n    }\n  }\n  /**\n   * Number of this element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get childCount() {\n    return this._children.length;\n  }\n  /**\n   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get maxOffset() {\n    return this._children.maxOffset;\n  }\n  /**\n   * Is `true` if there are no nodes inside this element, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isEmpty() {\n    return this.childCount === 0;\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\telement.is( 'element' ); // -> true\n   *\t\telement.is( 'node' ); // -> true\n   *\t\telement.is( 'model:element' ); // -> true\n   *\t\telement.is( 'model:node' ); // -> true\n   *\n   *\t\telement.is( 'view:element' ); // -> false\n   *\t\telement.is( 'documentSelection' ); // -> false\n   *\n   * Assuming that the object being checked is an element, you can also check its\n   * {@link module:engine/model/element~Element#name name}:\n   *\n   *\t\telement.is( 'image' ); // -> true if this is an <image> element\n   *\t\telement.is( 'element', 'image' ); // -> same as above\n   *\t\ttext.is( 'image' ); -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type Type to check when `name` parameter is present.\n   * Otherwise, it acts like the `name` parameter.\n   * @param {String} [name] Element name.\n   * @returns {Boolean}\n   */\n\n\n  is(type, name = null) {\n    if (!name) {\n      return type === 'element' || type === 'model:element' || type === this.name || type === 'model:' + this.name || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n      type === 'node' || type === 'model:node';\n    }\n\n    return name === this.name && (type === 'element' || type === 'model:element');\n  }\n  /**\n   * Gets the child at the given index.\n   *\n   * @param {Number} index Index of child.\n   * @returns {module:engine/model/node~Node} Child node.\n   */\n\n\n  getChild(index) {\n    return this._children.getNode(index);\n  }\n  /**\n   * Returns an iterator that iterates over all of this element's children.\n   *\n   * @returns {Iterable.<module:engine/model/node~Node>}\n   */\n\n\n  getChildren() {\n    return this._children[Symbol.iterator]();\n  }\n  /**\n   * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number} Child node's index in this element.\n   */\n\n\n  getChildIndex(node) {\n    return this._children.getNodeIndex(node);\n  }\n  /**\n   * Returns the starting offset of given child. Starting offset is equal to the sum of\n   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n   * given node is not a child of this element.\n   *\n   * @param {module:engine/model/node~Node} node Child node to look for.\n   * @returns {Number} Child node's starting offset.\n   */\n\n\n  getChildStartOffset(node) {\n    return this._children.getNodeStartOffset(node);\n  }\n  /**\n   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n   * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n   *\n   *\t\tconst textNode = new Text( 'foo' );\n   *\t\tconst pElement = new Element( 'p' );\n   *\t\tconst divElement = new Element( [ textNode, pElement ] );\n   *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n   *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n   *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n   *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n   *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n   *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n   *\n   * @param {Number} offset Offset to look for.\n   * @returns {Number}\n   */\n\n\n  offsetToIndex(offset) {\n    return this._children.offsetToIndex(offset);\n  }\n  /**\n   * Returns a descendant node by its path relative to this element.\n   *\n   *\t\t// <this>a<b>c</b></this>\n   *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n   *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n   *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n   *\n   * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n   * @returns {module:engine/model/node~Node}\n   */\n\n\n  getNodeByPath(relativePath) {\n    let node = this; // eslint-disable-line consistent-this\n\n    for (const index of relativePath) {\n      node = node.getChild(node.offsetToIndex(index));\n    }\n\n    return node;\n  }\n  /**\n   * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n   *\n   * @returns {Object} `Element` instance converted to plain object.\n   */\n\n\n  toJSON() {\n    const json = super.toJSON();\n    json.name = this.name;\n\n    if (this._children.length > 0) {\n      json.children = [];\n\n      for (const node of this._children) {\n        json.children.push(node.toJSON());\n      }\n    }\n\n    return json;\n  }\n  /**\n   * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n   *\n   * @protected\n   * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n   * element will be cloned without any child.\n   */\n\n\n  _clone(deep = false) {\n    const children = deep ? Array.from(this._children).map(node => node._clone(true)) : null;\n    return new Element(this.name, this.getAttributes(), children);\n  }\n  /**\n   * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n   *\n   * @see module:engine/model/writer~Writer#append\n   * @protected\n   * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} nodes Nodes to be inserted.\n   */\n\n\n  _appendChild(nodes) {\n    this._insertChild(this.childCount, nodes);\n  }\n  /**\n   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n   * to this element.\n   *\n   * @see module:engine/model/writer~Writer#insert\n   * @protected\n   * @param {Number} index Index at which nodes should be inserted.\n   * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n   */\n\n\n  _insertChild(index, items) {\n    const nodes = normalize(items);\n\n    for (const node of nodes) {\n      // If node that is being added to this element is already inside another element, first remove it from the old parent.\n      if (node.parent !== null) {\n        node._remove();\n      }\n\n      node.parent = this;\n    }\n\n    this._children._insertNodes(index, nodes);\n  }\n  /**\n   * Removes one or more nodes starting at the given index and sets\n   * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n   *\n   * @see module:engine/model/writer~Writer#remove\n   * @protected\n   * @param {Number} index Index of the first node to remove.\n   * @param {Number} [howMany=1] Number of nodes to remove.\n   * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n   */\n\n\n  _removeChildren(index, howMany = 1) {\n    const nodes = this._children._removeNodes(index, howMany);\n\n    for (const node of nodes) {\n      node.parent = null;\n    }\n\n    return nodes;\n  }\n  /**\n   * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n   * Converts `Element` children to proper nodes.\n   *\n   * @param {Object} json Plain object to be converted to `Element`.\n   * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n   */\n\n\n  static fromJSON(json) {\n    let children = null;\n\n    if (json.children) {\n      children = [];\n\n      for (const child of json.children) {\n        if (child.name) {\n          // If child has name property, it is an Element.\n          children.push(Element.fromJSON(child));\n        } else {\n          // Otherwise, it is a Text node.\n          children.push(Text.fromJSON(child));\n        }\n      }\n    }\n\n    return new Element(json.name, json.attributes, children);\n  } // @if CK_DEBUG_ENGINE // toString() {\n  // @if CK_DEBUG_ENGINE // \treturn `<${ this.rootName || this.name }>`;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // log() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelElement: ' + this );\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logExtended() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( `ModelElement: ${ this }, ${ this.childCount } children,\n  // @if CK_DEBUG_ENGINE //\t\tattrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logAll() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( '--------------------' );\n  // @if CK_DEBUG_ENGINE //\n  // @if CK_DEBUG_ENGINE // \tthis.logExtended();\n  // @if CK_DEBUG_ENGINE //\tconsole.log( 'List of children:' );\n  // @if CK_DEBUG_ENGINE //\n  // @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n  // @if CK_DEBUG_ENGINE // \t\tchild.log();\n  // @if CK_DEBUG_ENGINE // \t}\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // printTree( level = 0) {\n  // @if CK_DEBUG_ENGINE // \tlet string = '';\n  // @if CK_DEBUG_ENGINE // \tstring += '\\t'.repeat( level );\n  // @if CK_DEBUG_ENGINE // \tstring += `<${ this.rootName || this.name }${ convertMapToTags( this.getAttributes() ) }>`;\n  // @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n  // @if CK_DEBUG_ENGINE // \t\tstring += '\\n';\n  // @if CK_DEBUG_ENGINE // \t\tif ( child.is( 'text' ) ) {\n  // @if CK_DEBUG_ENGINE // \t\t\tconst textAttrs = convertMapToTags( child._attrs );\n  // @if CK_DEBUG_ENGINE // \t\t\tstring += '\\t'.repeat( level + 1 );\n  // @if CK_DEBUG_ENGINE // \t\t\tif ( textAttrs !== '' ) {\n  // @if CK_DEBUG_ENGINE // \t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n  // @if CK_DEBUG_ENGINE // \t\t\t} else {\n  // @if CK_DEBUG_ENGINE // \t\t\t\tstring += child.data;\n  // @if CK_DEBUG_ENGINE // \t\t\t}\n  // @if CK_DEBUG_ENGINE // \t\t} else {\n  // @if CK_DEBUG_ENGINE // \t\t\tstring += child.printTree( level + 1 );\n  // @if CK_DEBUG_ENGINE // \t\t}\n  // @if CK_DEBUG_ENGINE // \t}\n  // @if CK_DEBUG_ENGINE // \tif ( this.childCount ) {\n  // @if CK_DEBUG_ENGINE // \t\tstring += '\\n' + '\\t'.repeat( level );\n  // @if CK_DEBUG_ENGINE // \t}\n  // @if CK_DEBUG_ENGINE // \tstring += `</${ this.rootName || this.name }>`;\n  // @if CK_DEBUG_ENGINE // \treturn string;\n  // @if CK_DEBUG_ENGINE // }\n  // @if CK_DEBUG_ENGINE // logTree() {\n  // @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n  // @if CK_DEBUG_ENGINE // }\n\n\n} // Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\n\nfunction normalize(nodes) {\n  // Separate condition because string is iterable.\n  if (typeof nodes == 'string') {\n    return [new Text(nodes)];\n  }\n\n  if (!isIterable(nodes)) {\n    nodes = [nodes];\n  } // Array.from to enable .map() on non-arrays.\n\n\n  return Array.from(nodes).map(node => {\n    if (typeof node == 'string') {\n      return new Text(node);\n    }\n\n    if (node instanceof TextProxy) {\n      return new Text(node.data, node.getAttributes());\n    }\n\n    return node;\n  });\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/model/element.js"],"names":["Node","NodeList","Text","TextProxy","isIterable","Element","constructor","name","attrs","children","_children","_insertChild","childCount","length","maxOffset","isEmpty","is","type","getChild","index","getNode","getChildren","Symbol","iterator","getChildIndex","node","getNodeIndex","getChildStartOffset","getNodeStartOffset","offsetToIndex","offset","getNodeByPath","relativePath","toJSON","json","push","_clone","deep","Array","from","map","getAttributes","_appendChild","nodes","items","normalize","parent","_remove","_insertNodes","_removeChildren","howMany","_removeNodes","fromJSON","child","attributes","data"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/element\n */\n\nimport Node from './node';\nimport NodeList from './nodelist';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n// @if CK_DEBUG_ENGINE // const { stringifyMap, convertMapToStringifiedObject, convertMapToTags } = require( '../dev-utils/utils' );\n\n/**\n * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and\n * {@link module:engine/model/element~Element#getChildren child nodes}.\n *\n * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.\n *\n * @extends module:engine/model/node~Node\n */\nexport default class Element extends Node {\n\t/**\n\t * Creates a model element.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createElement} method instead.\n\t *\n\t * @protected\n\t * @param {String} name Element's name.\n\t * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n\t * One or more nodes to be inserted as children of created element.\n\t */\n\tconstructor( name, attrs, children ) {\n\t\tsuper( attrs );\n\n\t\t/**\n\t\t * Element name.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} module:engine/model/element~Element#name\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * List of children nodes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children\n\t\t */\n\t\tthis._children = new NodeList();\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Number of this element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._children.maxOffset;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this element, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\telement.is( 'element' ); // -> true\n\t *\t\telement.is( 'node' ); // -> true\n\t *\t\telement.is( 'model:element' ); // -> true\n\t *\t\telement.is( 'model:node' ); // -> true\n\t *\n\t *\t\telement.is( 'view:element' ); // -> false\n\t *\t\telement.is( 'documentSelection' ); // -> false\n\t *\n\t * Assuming that the object being checked is an element, you can also check its\n\t * {@link module:engine/model/element~Element#name name}:\n\t *\n\t *\t\telement.is( 'image' ); // -> true if this is an <image> element\n\t *\t\telement.is( 'element', 'image' ); // -> same as above\n\t *\t\ttext.is( 'image' ); -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type Type to check when `name` parameter is present.\n\t * Otherwise, it acts like the `name` parameter.\n\t * @param {String} [name] Element name.\n\t * @returns {Boolean}\n\t */\n\tis( type, name = null ) {\n\t\tif ( !name ) {\n\t\t\treturn type === 'element' || type === 'model:element' ||\n\t\t\t\ttype === this.name || type === 'model:' + this.name ||\n\t\t\t\t// From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.\n\t\t\t\ttype === 'node' || type === 'model:node';\n\t\t}\n\n\t\treturn name === this.name && ( type === 'element' || type === 'model:element' );\n\t}\n\n\t/**\n\t * Gets the child at the given index.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/model/node~Node} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children.getNode( index );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all of this element's children.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an index of the given child node. Returns `null` if given node is not a child of this element.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number} Child node's index in this element.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.getNodeIndex( node );\n\t}\n\n\t/**\n\t * Returns the starting offset of given child. Starting offset is equal to the sum of\n\t * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n\t * given node is not a child of this element.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number} Child node's starting offset.\n\t */\n\tgetChildStartOffset( node ) {\n\t\treturn this._children.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n\t * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.\n\t *\n\t *\t\tconst textNode = new Text( 'foo' );\n\t *\t\tconst pElement = new Element( 'p' );\n\t *\t\tconst divElement = new Element( [ textNode, pElement ] );\n\t *\t\tdivElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n\t *\t\tdivElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n\t *\t\tdivElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n\t *\t\tdivElement.offsetToIndex( 2 ); // Returns 0.\n\t *\t\tdivElement.offsetToIndex( 3 ); // Returns 1.\n\t *\t\tdivElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number}\n\t */\n\toffsetToIndex( offset ) {\n\t\treturn this._children.offsetToIndex( offset );\n\t}\n\n\t/**\n\t * Returns a descendant node by its path relative to this element.\n\t *\n\t *\t\t// <this>a<b>c</b></this>\n\t *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n\t *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n\t *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n\t *\n\t * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n\t * @returns {module:engine/model/node~Node}\n\t */\n\tgetNodeByPath( relativePath ) {\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\tfor ( const index of relativePath ) {\n\t\t\tnode = node.getChild( node.offsetToIndex( index ) );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.\n\t *\n\t * @returns {Object} `Element` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = super.toJSON();\n\n\t\tjson.name = this.name;\n\n\t\tif ( this._children.length > 0 ) {\n\t\t\tjson.children = [];\n\n\t\t\tfor ( const node of this._children ) {\n\t\t\t\tjson.children.push( node.toJSON() );\n\t\t\t}\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.\n\t * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.\n\t *\n\t * @protected\n\t * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,\n\t * element will be cloned without any child.\n\t */\n\t_clone( deep = false ) {\n\t\tconst children = deep ? Array.from( this._children ).map( node => node._clone( true ) ) : null;\n\n\t\treturn new Element( this.name, this.getAttributes(), children );\n\t}\n\n\t/**\n\t * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.\n\t *\n\t * @see module:engine/model/writer~Writer#append\n\t * @protected\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} nodes Nodes to be inserted.\n\t */\n\t_appendChild( nodes ) {\n\t\tthis._insertChild( this.childCount, nodes );\n\t}\n\n\t/**\n\t * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n\t * to this element.\n\t *\n\t * @see module:engine/model/writer~Writer#insert\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_insertChild( index, items ) {\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t}\n\n\t\tthis._children._insertNodes( index, nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index and sets\n\t * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t * @param {Number} index Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tconst nodes = this._children._removeNodes( index, howMany );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t/**\n\t * Creates an `Element` instance from given plain object (i.e. parsed JSON string).\n\t * Converts `Element` children to proper nodes.\n\t *\n\t * @param {Object} json Plain object to be converted to `Element`.\n\t * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\tlet children = null;\n\n\t\tif ( json.children ) {\n\t\t\tchildren = [];\n\n\t\t\tfor ( const child of json.children ) {\n\t\t\t\tif ( child.name ) {\n\t\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Element( json.name, json.attributes, children );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `<${ this.rootName || this.name }>`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelElement: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logExtended() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( `ModelElement: ${ this }, ${ this.childCount } children,\n\t// @if CK_DEBUG_ENGINE //\t\tattrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logAll() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( '--------------------' );\n\t// @if CK_DEBUG_ENGINE //\n\t// @if CK_DEBUG_ENGINE // \tthis.logExtended();\n\t// @if CK_DEBUG_ENGINE //\tconsole.log( 'List of children:' );\n\t// @if CK_DEBUG_ENGINE //\n\t// @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE // \t\tchild.log();\n\t// @if CK_DEBUG_ENGINE // \t}\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // printTree( level = 0) {\n\t// @if CK_DEBUG_ENGINE // \tlet string = '';\n\n\t// @if CK_DEBUG_ENGINE // \tstring += '\\t'.repeat( level );\n\t// @if CK_DEBUG_ENGINE // \tstring += `<${ this.rootName || this.name }${ convertMapToTags( this.getAttributes() ) }>`;\n\n\t// @if CK_DEBUG_ENGINE // \tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE // \t\tstring += '\\n';\n\n\t// @if CK_DEBUG_ENGINE // \t\tif ( child.is( 'text' ) ) {\n\t// @if CK_DEBUG_ENGINE // \t\t\tconst textAttrs = convertMapToTags( child._attrs );\n\n\t// @if CK_DEBUG_ENGINE // \t\t\tstring += '\\t'.repeat( level + 1 );\n\n\t// @if CK_DEBUG_ENGINE // \t\t\tif ( textAttrs !== '' ) {\n\t// @if CK_DEBUG_ENGINE // \t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n\t// @if CK_DEBUG_ENGINE // \t\t\t} else {\n\t// @if CK_DEBUG_ENGINE // \t\t\t\tstring += child.data;\n\t// @if CK_DEBUG_ENGINE // \t\t\t}\n\t// @if CK_DEBUG_ENGINE // \t\t} else {\n\t// @if CK_DEBUG_ENGINE // \t\t\tstring += child.printTree( level + 1 );\n\t// @if CK_DEBUG_ENGINE // \t\t}\n\t// @if CK_DEBUG_ENGINE // \t}\n\n\t// @if CK_DEBUG_ENGINE // \tif ( this.childCount ) {\n\t// @if CK_DEBUG_ENGINE // \t\tstring += '\\n' + '\\t'.repeat( level );\n\t// @if CK_DEBUG_ENGINE // \t}\n\n\t// @if CK_DEBUG_ENGINE // \tstring += `</${ this.rootName || this.name }>`;\n\n\t// @if CK_DEBUG_ENGINE // \treturn string;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logTree() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data, node.getAttributes() );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n"]},"metadata":{},"sourceType":"module"}