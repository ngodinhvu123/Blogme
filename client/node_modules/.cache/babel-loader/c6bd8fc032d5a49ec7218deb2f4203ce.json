{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/stylesmap\n */\nimport { get, isObject, merge, set, unset } from 'lodash-es';\n/**\n * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).\n *\n * The styles map is capable of normalizing style names so e.g. the following operations are possible:\n */\n\nexport default class StylesMap {\n  /**\n   * Creates Styles instance.\n   *\n   * @param {module:engine/view/stylesmap~StylesProcessor} styleProcessor\n   */\n  constructor(styleProcessor) {\n    /**\n     * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and\n     * value access model using lodash's get, set, unset, etc methods.\n     *\n     * When no style processor rules are defined the it acts as simple key-value storage.\n     *\n     * @private\n     * @type {Object}\n     */\n    this._styles = {};\n    /**\n     * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.\n     *\n     * @private\n     * @member {module:engine/view/stylesmap~StylesProcessor}\n     */\n\n    this._styleProcessor = styleProcessor;\n  }\n  /**\n   * Returns true if style map has no styles set.\n   *\n   * @returns {Boolean}\n   */\n\n\n  get isEmpty() {\n    const entries = Object.entries(this._styles);\n    const from = Array.from(entries);\n    return !from.length;\n  }\n  /**\n   * Number of styles defined.\n   *\n   * @type {Number}\n   */\n\n\n  get size() {\n    if (this.isEmpty) {\n      return 0;\n    }\n\n    return this.getStyleNames().length;\n  }\n  /**\n   * Set styles map to a new value.\n   *\n   *\t\tstyles.setTo( 'border:1px solid blue;margin-top:1px;' );\n   *\n   * @param {String} inlineStyle\n   */\n\n\n  setTo(inlineStyle) {\n    this.clear();\n    const parsedStyles = Array.from(parseInlineStyles(inlineStyle).entries());\n\n    for (const [key, value] of parsedStyles) {\n      this._styleProcessor.toNormalizedForm(key, value, this._styles);\n    }\n  }\n  /**\n   * Checks if a given style is set.\n   *\n   *\t\tstyles.setTo( 'margin-left:1px;' );\n   *\n   *\t\tstyles.has( 'margin-left' );    // -> true\n   *\t\tstyles.has( 'padding' );        // -> false\n   *\n   * **Note**: This check supports normalized style names.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tstyles.setTo( 'margin:2px;' );\n   *\n   *\t\tstyles.has( 'margin' );         // -> true\n   *\t\tstyles.has( 'margin-top' );     // -> true\n   *\t\tstyles.has( 'margin-left' );    // -> true\n   *\n   *\t\tstyles.remove( 'margin-top' );\n   *\n   *\t\tstyles.has( 'margin' );         // -> false\n   *\t\tstyles.has( 'margin-top' );     // -> false\n   *\t\tstyles.has( 'margin-left' );    // -> true\n   *\n   * @param {String} name Style name.\n   * @returns {Boolean}\n   */\n\n\n  has(name) {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    const styles = this._styleProcessor.getReducedForm(name, this._styles);\n\n    const propertyDescriptor = styles.find(([property]) => property === name); // Only return a value if it is set;\n\n    return Array.isArray(propertyDescriptor);\n  }\n  /**\n   * Sets a given style.\n   *\n   * Can insert one by one:\n   *\n   *\t\tstyles.set( 'color', 'blue' );\n   *\t\tstyles.set( 'margin-right', '1em' );\n   *\n   * or many styles at once:\n   *\n   *\t\tstyles.set( {\n   *\t\t\tcolor: 'blue',\n   *\t\t\t'margin-right': '1em'\n   *\t\t} );\n   *\n   * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n   * enabled style processor rules} to normalize passed values.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tstyles.set( 'margin', '2px' );\n   *\n   * The above code will set margin to:\n   *\n   *\t\tstyles.getNormalized( 'margin' );\n   *\t\t// -> { top: '2px', right: '2px', bottom: '2px', left: '2px' }\n   *\n   * Which makes it possible to retrieve a \"sub-value\":\n   *\n   *\t\tstyles.get( 'margin-left' );       // -> '2px'\n   *\n   * Or modify it:\n   *\n   *\t\tstyles.remove( 'margin-left' );\n   *\n   *\t\tstyles.getNormalized( 'margin' );  // -> { top: '1px', bottom: '1px', right: '1px' }\n   *\t\tstyles.toString();                 // -> 'margin-bottom:1px;margin-right:1px;margin-top:1px;'\n   *\n   * This method also allows to set normalized values directly (if a particular styles processor rule was enabled):\n   *\n   *\t\tstyles.set( 'border-color', { top: 'blue' } );\n   *\t\tstyles.set( 'margin', { right: '2em' } );\n   *\n   *\t\tstyles.toString();                 // -> 'border-color-top:blue;margin-right:2em;'\n   *\n   * @param {String|Object} nameOrObject Style property name or object with multiple properties.\n   * @param {String|Object} valueOrObject Value to set.\n   */\n\n\n  set(nameOrObject, valueOrObject) {\n    if (isObject(nameOrObject)) {\n      for (const [key, value] of Object.entries(nameOrObject)) {\n        this._styleProcessor.toNormalizedForm(key, value, this._styles);\n      }\n    } else {\n      this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);\n    }\n  }\n  /**\n   * Removes given style.\n   *\n   *\t\tstyles.setTo( 'background:#f00;margin-right:2px;' );\n   *\n   *\t\tstyles.remove( 'background' );\n   *\n   *\t\tstyles.toString();   // -> 'margin-right:2px;'\n   *\n   * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n   * enabled style processor rules} to normalize passed values.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tstyles.setTo( 'margin:1px' );\n   *\n   *\t\tstyles.remove( 'margin-top' );\n   *\t\tstyles.remove( 'margin-right' );\n   *\n   *\t\tstyles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'\n   *\n   * @param {String} name Style name.\n   */\n\n\n  remove(name) {\n    const path = toPath(name);\n    unset(this._styles, path);\n    delete this._styles[name];\n\n    this._cleanEmptyObjectsOnPath(path);\n  }\n  /**\n   * Returns a normalized style object or a single value.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px 2px 3em;' );\n   *\n   *\t\tstyles.getNormalized( 'margin' );\n   *\t\t// will log:\n   *\t\t// {\n   *\t\t//     top: '1px',\n   *\t\t//     right: '2px',\n   *\t\t//     bottom: '3em',\n   *\t\t//     left: '2px'     // normalized value from margin shorthand\n   *\t\t// }\n   *\n   *\t\tstyles.getNormalized( 'margin-left' ); // -> '2px'\n   *\n   * **Note**: This method will only return normalized styles if a style processor was defined.\n   *\n   * @param {String} name Style name.\n   * @returns {Object|String|undefined}\n   */\n\n\n  getNormalized(name) {\n    return this._styleProcessor.getNormalized(name, this._styles);\n  }\n  /**\n   * Returns a normalized style string. Styles are sorted by name.\n   *\n   *\t\tstyles.set( 'margin' , '1px' );\n   *\t\tstyles.set( 'background', '#f00' );\n   *\n   *\t\tstyles.toString(); // -> 'background:#f00;margin:1px;'\n   *\n   * **Note**: This method supports normalized styles if defined.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tstyles.set( 'margin' , '1px' );\n   *\t\tstyles.set( 'background', '#f00' );\n   *\t\tstyles.remove( 'margin-top' );\n   *\t\tstyles.remove( 'margin-right' );\n   *\n   *\t\tstyles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'\n   *\n   * @returns {String}\n   */\n\n\n  toString() {\n    if (this.isEmpty) {\n      return '';\n    }\n\n    return this._getStylesEntries().map(arr => arr.join(':')).sort().join(';') + ';';\n  }\n  /**\n   * Returns property as a value string or undefined if property is not set.\n   *\n   *\t\t// Enable 'margin' shorthand processing:\n   *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px;' );\n   *\t\tstyles.set( 'margin-bottom', '3em' );\n   *\n   *\t\tstyles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'\n   *\n   * Note, however, that all sub-values must be set for the longhand property name to return a value:\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px;' );\n   *\t\tstyles.remove( 'margin-bottom' );\n   *\n   *\t\tstyles.getAsString( 'margin' ); // -> undefined\n   *\n   * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.\n   * Instead, you should use:\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px;' );\n   *\t\tstyles.remove( 'margin-bottom' );\n   *\n   *\t\tfor ( const styleName of styles.getStyleNames() ) {\n   *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n   *\t\t}\n   *\t\t// 'margin-top', '1px'\n   *\t\t// 'margin-right', '1px'\n   *\t\t// 'margin-left', '1px'\n   *\n   * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all\n   * the currently set style values. So, if all the 4 margin values would be set\n   * the for-of loop above would yield only `'margin'`, `'1px'`:\n   *\n   *\t\tconst styles = new Styles();\n   *\t\tstyles.setTo( 'margin:1px;' );\n   *\n   *\t\tfor ( const styleName of styles.getStyleNames() ) {\n   *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n   *\t\t}\n   *\t\t// 'margin', '1px'\n   *\n   * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.\n   *\n   * @param {String} propertyName\n   * @returns {String|undefined}\n   */\n\n\n  getAsString(propertyName) {\n    if (this.isEmpty) {\n      return;\n    }\n\n    if (this._styles[propertyName] && !isObject(this._styles[propertyName])) {\n      // Try return styles set directly - values that are not parsed.\n      return this._styles[propertyName];\n    }\n\n    const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);\n\n    const propertyDescriptor = styles.find(([property]) => property === propertyName); // Only return a value if it is set;\n\n    if (Array.isArray(propertyDescriptor)) {\n      return propertyDescriptor[1];\n    }\n  }\n  /**\n   * Returns style property names as they would appear when using {@link #toString `#toString()`}.\n   *\n   * @returns {Array.<String>}\n   */\n\n\n  getStyleNames() {\n    if (this.isEmpty) {\n      return [];\n    }\n\n    const entries = this._getStylesEntries();\n\n    return entries.map(([key]) => key);\n  }\n  /**\n   * Removes all styles.\n   */\n\n\n  clear() {\n    this._styles = {};\n  }\n  /**\n   * Returns normalized styles entries for further processing.\n   *\n   * @private\n   * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n   */\n\n\n  _getStylesEntries() {\n    const parsed = [];\n    const keys = Object.keys(this._styles);\n\n    for (const key of keys) {\n      parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));\n    }\n\n    return parsed;\n  }\n  /**\n   * Removes empty objects upon removing an entry from internal object.\n   *\n   * @param {String} path\n   * @private\n   */\n\n\n  _cleanEmptyObjectsOnPath(path) {\n    const pathParts = path.split('.');\n    const isChildPath = pathParts.length > 1;\n\n    if (!isChildPath) {\n      return;\n    }\n\n    const parentPath = pathParts.splice(0, pathParts.length - 1).join('.');\n    const parentObject = get(this._styles, parentPath);\n\n    if (!parentObject) {\n      return;\n    }\n\n    const isParentEmpty = !Array.from(Object.keys(parentObject)).length;\n\n    if (isParentEmpty) {\n      this.remove(parentPath);\n    }\n  }\n\n}\n/**\n * Style processor is responsible for writing and reading a normalized styles object.\n */\n\nexport class StylesProcessor {\n  /**\n   * Creates StylesProcessor instance.\n   *\n   * @private\n   */\n  constructor() {\n    this._normalizers = new Map();\n    this._extractors = new Map();\n    this._reducers = new Map();\n    this._consumables = new Map();\n  }\n  /**\n   * Parse style string value to a normalized object and appends it to styles object.\n   *\n   *\t\tconst styles = {};\n   *\n   *\t\tstylesProcessor.toNormalizedForm( 'margin', '1px', styles );\n   *\n   *\t\t// styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }\n   *\n   * **Note**: To define normalizer callbacks use {@link #setNormalizer}.\n   *\n   * @param {String} name Name of style property.\n   * @param {String} propertyValue Value of style property.\n   * @param {Object} styles Object holding normalized styles.\n   */\n\n\n  toNormalizedForm(name, propertyValue, styles) {\n    if (isObject(propertyValue)) {\n      appendStyleValue(styles, toPath(name), propertyValue);\n      return;\n    }\n\n    if (this._normalizers.has(name)) {\n      const normalizer = this._normalizers.get(name);\n\n      const {\n        path,\n        value\n      } = normalizer(propertyValue);\n      appendStyleValue(styles, path, value);\n    } else {\n      appendStyleValue(styles, name, propertyValue);\n    }\n  }\n  /**\n   * Returns a normalized version of a style property.\n   *\t\tconst styles = {\n   *\t\t\tmargin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },\n   *\t\t\tbackground: { color: '#f00' }\n   *\t\t};\n   *\n   *\t\tstylesProcessor.getNormalized( 'background' );\n   *\t\t// will return: { color: '#f00' }\n   *\n   *\t\tstylesProcessor.getNormalized( 'margin-top' );\n   *\t\t// will return: '1px'\n   *\n   * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.\n   *\n   * @param {String} name Name of style property.\n   * @param {Object} styles Object holding normalized styles.\n   * @returns {*}\n   */\n\n\n  getNormalized(name, styles) {\n    if (!name) {\n      return merge({}, styles);\n    } // Might be empty string.\n\n\n    if (styles[name] !== undefined) {\n      return styles[name];\n    }\n\n    if (this._extractors.has(name)) {\n      const extractor = this._extractors.get(name);\n\n      if (typeof extractor === 'string') {\n        return get(styles, extractor);\n      }\n\n      const value = extractor(name, styles);\n\n      if (value) {\n        return value;\n      }\n    }\n\n    return get(styles, toPath(name));\n  }\n  /**\n   * Returns a reduced form of style property form normalized object.\n   *\n   * For default margin reducer, the below code:\n   *\n   *\t\tstylesProcessor.getReducedForm( 'margin', {\n   *\t\t\tmargin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }\n   *\t\t} );\n   *\n   * will return:\n   *\n   *\t\t[\n   *\t\t\t[ 'margin', '1px 1px 2px' ]\n   *\t\t]\n   *\n   * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:\n   *\n   *\t\t[\n   *\t\t\t[ 'margin-top', '1px' ],\n   *\t\t\t[ 'margin-right', '1px' ],\n   *\t\t\t[ 'margin-bottom', '2px' ]\n   *\t\t\t// the 'left' value is missing - cannot use 'margin' shorthand.\n   *\t\t]\n   *\n   * **Note**: To define reducer callbacks use {@link #setReducer}.\n   *\n   * @param {String} name\n   * @param {String} name Name of style property.\n   * @param {Object} styles Object holding normalized styles.\n   * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n   */\n\n\n  getReducedForm(name, styles) {\n    const normalizedValue = this.getNormalized(name, styles); // Might be empty string.\n\n    if (normalizedValue === undefined) {\n      return [];\n    }\n\n    if (this._reducers.has(name)) {\n      const reducer = this._reducers.get(name);\n\n      return reducer(normalizedValue);\n    }\n\n    return [[name, normalizedValue]];\n  }\n  /**\n   * Returns related style names.\n   *\n   *\t\tstylesProcessor.getRelatedStyles( 'margin' );\n   *\t\t// will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];\n   *\n   *\t\tstylesProcessor.getRelatedStyles( 'margin-top' );\n   *\t\t// will return: [ 'margin' ];\n   *\n   * **Note**: To define new style relations load an existing style processor or use\n   * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.\n   *\n   * @param {String} name\n   * @returns {Array.<String>}\n   */\n\n\n  getRelatedStyles(name) {\n    return this._consumables.get(name) || [];\n  }\n  /**\n   * Adds a normalizer method for a style property.\n   *\n   * A normalizer returns describing how the value should be normalized.\n   *\n   * For instance 'margin' style is a shorthand for four margin values:\n   *\n   * - 'margin-top'\n   * - 'margin-right'\n   * - 'margin-bottom'\n   * - 'margin-left'\n   *\n   * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for\n   * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.\n   *\n   * A normalizer should parse various margin notations as a single object:\n   *\n   *\t\tconst styles = {\n   *\t\t\tmargin: {\n   *\t\t\t\ttop: '1px',\n   *\t\t\t\tright: '2em',\n   *\t\t\t\tbottom: '1px',\n   *\t\t\t\tleft: '2em'\n   *\t\t\t}\n   *\t\t};\n   *\n   * Thus a normalizer for 'margin' style should return an object defining style path and value to store:\n   *\n   *\t\tconst returnValue = {\n   *\t\t\tpath: 'margin',\n   *\t\t\tvalue: {\n   *\t\t\t\ttop: '1px',\n   *\t\t\t\tright: '2em',\n   *\t\t\t\tbottom: '1px',\n   *\t\t\t\tleft: '2em'\n   *\t\t\t}\n   *\t\t};\n   *\n   * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below\n   * is an example for 'margin-top' style property normalizer:\n   *\n   *\t\tstylesProcessor.setNormalizer( 'margin-top', valueString => {\n   *\t\t\treturn {\n   *\t\t\t\tpath: 'margin.top',\n   *\t\t\t\tvalue: valueString\n   *\t\t\t}\n   *\t\t} );\n   *\n   * @param {String} name\n   * @param {Function} callback\n   */\n\n\n  setNormalizer(name, callback) {\n    this._normalizers.set(name, callback);\n  }\n  /**\n   * Adds a extractor callback for a style property.\n   *\n   * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:\n   *\n   *\t\tconst styles = {\n   *\t\t\tmargin: {\n   *\t\t\t\ttop: 'value'\n   *\t\t\t}\n   *\t\t}\n   *\n   * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance\n   * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`\n   * shorthands. The default border styles processors stores styles as:\n   *\n   *\t\tconst styles = {\n   *\t\t\tborder: {\n   *\t\t\t\tstyle: {\n   *\t\t\t\t\ttop: 'solid'\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t}\n   *\n   * as it is better to modify border style independently from other values. On the other part the output of the border might be\n   * desired as `border-top`, `border-left`, etc notation.\n   *\n   * In the above example a reducer should return a side border value that combines style, color and width:\n   *\n   *\t\tstyleProcessor.setExtractor( 'border-top', styles => {\n   *\t\t\treturn {\n   *\t\t\t\tcolor: styles.border.color.top,\n   *\t\t\t\tstyle: styles.border.style.top,\n   *\t\t\t\twidth: styles.border.width.top\n   *\t\t\t}\n   *\t\t} );\n   *\n   * @param {String} name\n   * @param {Function|String} callbackOrPath Callback that return a requested value or path string for single values.\n   */\n\n\n  setExtractor(name, callbackOrPath) {\n    this._extractors.set(name, callbackOrPath);\n  }\n  /**\n   * Adds a reducer callback for a style property.\n   *\n   * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as\n   * by default the direct value from style path is taken.\n   *\n   * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples\n   * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:\n   *\n   *\t\tconst marginShortHandTuple = [\n   *\t\t\t[ 'margin', '1px 1px 2px' ]\n   *\t\t];\n   *\n   * or a longhand tuples for defined values:\n   *\n   *\t\t// Considering margin.bottom and margin.left are undefined.\n   *\t\tconst marginLonghandsTuples = [\n   *\t\t\t[ 'margin-top', '1px' ],\n   *\t\t\t[ 'margin-right', '1px' ]\n   *\t\t];\n   *\n   * A reducer obtains a normalized style value:\n   *\n   *\t\t// Simplified reducer that always outputs 4 values which are always present:\n   *\t\tstylesProcessor.setReducer( 'margin', margin => {\n   *\t\t\treturn [\n   *\t\t\t\t[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]\n   *\t\t\t]\n   *\t\t} );\n   *\n   * @param {String} name\n   * @param {Function} callback\n   */\n\n\n  setReducer(name, callback) {\n    this._reducers.set(name, callback);\n  }\n  /**\n   * Defines a style shorthand relation to other style notations.\n   *\n   *\t\tstylesProcessor.setStyleRelation( 'margin', [\n   *\t\t\t'margin-top',\n   *\t\t\t'margin-right',\n   *\t\t\t'margin-bottom',\n   *\t\t\t'margin-left'\n   *\t\t] );\n   *\n   * This enables expanding of style names for shorthands. For instance, if defined,\n   * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created\n   * for long-hand margin style notation alongside the `'margin'` item.\n   *\n   * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just\n   * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and\n   * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.\n   * However, once `margin-left` is consumed, `margin` will not be consumable anymore.\n   *\n   * @param {String} shorthandName\n   * @param {Array.<String>} styleNames\n   */\n\n\n  setStyleRelation(shorthandName, styleNames) {\n    this._mapStyleNames(shorthandName, styleNames);\n\n    for (const alsoName of styleNames) {\n      this._mapStyleNames(alsoName, [shorthandName]);\n    }\n  }\n  /**\n   * Set two-way binding of style names.\n   *\n   * @param {String} name\n   * @param {Array.<String>} styleNames\n   * @private\n   */\n\n\n  _mapStyleNames(name, styleNames) {\n    if (!this._consumables.has(name)) {\n      this._consumables.set(name, []);\n    }\n\n    this._consumables.get(name).push(...styleNames);\n  }\n\n} // Parses inline styles and puts property - value pairs into styles map.\n//\n// @param {String} stylesString Styles to parse.\n// @returns {Map.<String, String>} stylesMap Map of parsed properties and values.\n\nfunction parseInlineStyles(stylesString) {\n  // `null` if no quote was found in input string or last found quote was a closing quote. See below.\n  let quoteType = null;\n  let propertyNameStart = 0;\n  let propertyValueStart = 0;\n  let propertyName = null;\n  const stylesMap = new Map(); // Do not set anything if input string is empty.\n\n  if (stylesString === '') {\n    return stylesMap;\n  } // Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n\n\n  if (stylesString.charAt(stylesString.length - 1) != ';') {\n    stylesString = stylesString + ';';\n  } // Seek the whole string for \"special characters\".\n\n\n  for (let i = 0; i < stylesString.length; i++) {\n    const char = stylesString.charAt(i);\n\n    if (quoteType === null) {\n      // No quote found yet or last found quote was a closing quote.\n      switch (char) {\n        case ':':\n          // Most of time colon means that property name just ended.\n          // Sometimes however `:` is found inside property value (for example in background image url).\n          if (!propertyName) {\n            // Treat this as end of property only if property name is not already saved.\n            // Save property name.\n            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart); // Save this point as the start of property value.\n\n            propertyValueStart = i + 1;\n          }\n\n          break;\n\n        case '\"':\n        case '\\'':\n          // Opening quote found (this is an opening quote, because `quoteType` is `null`).\n          quoteType = char;\n          break;\n\n        case ';':\n          {\n            // Property value just ended.\n            // Use previously stored property value start to obtain property value.\n            const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);\n\n            if (propertyName) {\n              // Save parsed part.\n              stylesMap.set(propertyName.trim(), propertyValue.trim());\n            }\n\n            propertyName = null; // Save this point as property name start. Property name starts immediately after previous property value ends.\n\n            propertyNameStart = i + 1;\n            break;\n          }\n      }\n    } else if (char === quoteType) {\n      // If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n      quoteType = null;\n    }\n  }\n\n  return stylesMap;\n} // Return lodash compatible path from style name.\n\n\nfunction toPath(name) {\n  return name.replace('-', '.');\n} // Appends style definition to the styles object.\n//\n// @param {String} nameOrPath\n// @param {String|Object} valueOrObject\n// @private\n\n\nfunction appendStyleValue(stylesObject, nameOrPath, valueOrObject) {\n  let valueToSet = valueOrObject;\n\n  if (isObject(valueOrObject)) {\n    valueToSet = merge({}, get(stylesObject, nameOrPath), valueOrObject);\n  }\n\n  set(stylesObject, nameOrPath, valueToSet);\n}\n/**\n * A CSS style property descriptor that contains tuplet of two strings:\n *\n * - first string describes property name\n * - second string describes property value\n *\n *\t\tconst marginDescriptor = [ 'margin', '2px 3em' ];\n *\t\tconst marginTopDescriptor = [ 'margin-top', '2px' ];\n *\n * @typedef {Array.<String, String>} module:engine/view/stylesmap~PropertyDescriptor\n */\n\n/**\n * An object describing values associated with the sides of a box, for instance margins, paddings,\n * border widths, border colors, etc.\n *\n *\t\tconst margin = {\n *\t\t\ttop: '1px',\n *\t\t\tright: '3px',\n *\t\t\tbottom: '3px',\n *\t\t\tleft: '7px'\n *\t\t};\n *\n *\t\tconst borderColor = {\n *\t\t\ttop: 'red',\n *\t\t\tright: 'blue',\n *\t\t\tbottom: 'blue',\n *\t\t\tleft: 'red'\n *\t\t};\n *\n * @typedef {Object} module:engine/view/stylesmap~BoxSides\n *\n * @property {String} top Top side value.\n * @property {String} right Right side value.\n * @property {String} bottom Bottom side value.\n * @property {String} left Left side value.\n */","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js"],"names":["get","isObject","merge","set","unset","StylesMap","constructor","styleProcessor","_styles","_styleProcessor","isEmpty","entries","Object","from","Array","length","size","getStyleNames","setTo","inlineStyle","clear","parsedStyles","parseInlineStyles","key","value","toNormalizedForm","has","name","styles","getReducedForm","propertyDescriptor","find","property","isArray","nameOrObject","valueOrObject","remove","path","toPath","_cleanEmptyObjectsOnPath","getNormalized","toString","_getStylesEntries","map","arr","join","sort","getAsString","propertyName","parsed","keys","push","pathParts","split","isChildPath","parentPath","splice","parentObject","isParentEmpty","StylesProcessor","_normalizers","Map","_extractors","_reducers","_consumables","propertyValue","appendStyleValue","normalizer","undefined","extractor","normalizedValue","reducer","getRelatedStyles","setNormalizer","callback","setExtractor","callbackOrPath","setReducer","setStyleRelation","shorthandName","styleNames","_mapStyleNames","alsoName","stylesString","quoteType","propertyNameStart","propertyValueStart","stylesMap","charAt","i","char","substr","trim","replace","stylesObject","nameOrPath","valueToSet"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/stylesmap\n */\n\nimport { get, isObject, merge, set, unset } from 'lodash-es';\n\n/**\n * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).\n *\n * The styles map is capable of normalizing style names so e.g. the following operations are possible:\n */\nexport default class StylesMap {\n\t/**\n\t * Creates Styles instance.\n\t *\n\t * @param {module:engine/view/stylesmap~StylesProcessor} styleProcessor\n\t */\n\tconstructor( styleProcessor ) {\n\t\t/**\n\t\t * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and\n\t\t * value access model using lodash's get, set, unset, etc methods.\n\t\t *\n\t\t * When no style processor rules are defined the it acts as simple key-value storage.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._styles = {};\n\n\t\t/**\n\t\t * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis._styleProcessor = styleProcessor;\n\t}\n\n\t/**\n\t * Returns true if style map has no styles set.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget isEmpty() {\n\t\tconst entries = Object.entries( this._styles );\n\t\tconst from = Array.from( entries );\n\n\t\treturn !from.length;\n\t}\n\n\t/**\n\t * Number of styles defined.\n\t *\n\t * @type {Number}\n\t */\n\tget size() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.getStyleNames().length;\n\t}\n\n\t/**\n\t * Set styles map to a new value.\n\t *\n\t *\t\tstyles.setTo( 'border:1px solid blue;margin-top:1px;' );\n\t *\n\t * @param {String} inlineStyle\n\t */\n\tsetTo( inlineStyle ) {\n\t\tthis.clear();\n\n\t\tconst parsedStyles = Array.from( parseInlineStyles( inlineStyle ).entries() );\n\n\t\tfor ( const [ key, value ] of parsedStyles ) {\n\t\t\tthis._styleProcessor.toNormalizedForm( key, value, this._styles );\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a given style is set.\n\t *\n\t *\t\tstyles.setTo( 'margin-left:1px;' );\n\t *\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\t\tstyles.has( 'padding' );        // -> false\n\t *\n\t * **Note**: This check supports normalized style names.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.setTo( 'margin:2px;' );\n\t *\n\t *\t\tstyles.has( 'margin' );         // -> true\n\t *\t\tstyles.has( 'margin-top' );     // -> true\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\n\t *\t\tstyles.has( 'margin' );         // -> false\n\t *\t\tstyles.has( 'margin-top' );     // -> false\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\n\t * @param {String} name Style name.\n\t * @returns {Boolean}\n\t */\n\thas( name ) {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst styles = this._styleProcessor.getReducedForm( name, this._styles );\n\n\t\tconst propertyDescriptor = styles.find( ( [ property ] ) => property === name );\n\n\t\t// Only return a value if it is set;\n\t\treturn Array.isArray( propertyDescriptor );\n\t}\n\n\t/**\n\t * Sets a given style.\n\t *\n\t * Can insert one by one:\n\t *\n\t *\t\tstyles.set( 'color', 'blue' );\n\t *\t\tstyles.set( 'margin-right', '1em' );\n\t *\n\t * or many styles at once:\n\t *\n\t *\t\tstyles.set( {\n\t *\t\t\tcolor: 'blue',\n\t *\t\t\t'margin-right': '1em'\n\t *\t\t} );\n\t *\n\t * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n\t * enabled style processor rules} to normalize passed values.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.set( 'margin', '2px' );\n\t *\n\t * The above code will set margin to:\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );\n\t *\t\t// -> { top: '2px', right: '2px', bottom: '2px', left: '2px' }\n\t *\n\t * Which makes it possible to retrieve a \"sub-value\":\n\t *\n\t *\t\tstyles.get( 'margin-left' );       // -> '2px'\n\t *\n\t * Or modify it:\n\t *\n\t *\t\tstyles.remove( 'margin-left' );\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );  // -> { top: '1px', bottom: '1px', right: '1px' }\n\t *\t\tstyles.toString();                 // -> 'margin-bottom:1px;margin-right:1px;margin-top:1px;'\n\t *\n\t * This method also allows to set normalized values directly (if a particular styles processor rule was enabled):\n\t *\n\t *\t\tstyles.set( 'border-color', { top: 'blue' } );\n\t *\t\tstyles.set( 'margin', { right: '2em' } );\n\t *\n\t *\t\tstyles.toString();                 // -> 'border-color-top:blue;margin-right:2em;'\n\t *\n\t * @param {String|Object} nameOrObject Style property name or object with multiple properties.\n\t * @param {String|Object} valueOrObject Value to set.\n\t */\n\tset( nameOrObject, valueOrObject ) {\n\t\tif ( isObject( nameOrObject ) ) {\n\t\t\tfor ( const [ key, value ] of Object.entries( nameOrObject ) ) {\n\t\t\t\tthis._styleProcessor.toNormalizedForm( key, value, this._styles );\n\t\t\t}\n\t\t} else {\n\t\t\tthis._styleProcessor.toNormalizedForm( nameOrObject, valueOrObject, this._styles );\n\t\t}\n\t}\n\n\t/**\n\t * Removes given style.\n\t *\n\t *\t\tstyles.setTo( 'background:#f00;margin-right:2px;' );\n\t *\n\t *\t\tstyles.remove( 'background' );\n\t *\n\t *\t\tstyles.toString();   // -> 'margin-right:2px;'\n\t *\n\t * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n\t * enabled style processor rules} to normalize passed values.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.setTo( 'margin:1px' );\n\t *\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\t\tstyles.remove( 'margin-right' );\n\t *\n\t *\t\tstyles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'\n\t *\n\t * @param {String} name Style name.\n\t */\n\tremove( name ) {\n\t\tconst path = toPath( name );\n\n\t\tunset( this._styles, path );\n\t\tdelete this._styles[ name ];\n\n\t\tthis._cleanEmptyObjectsOnPath( path );\n\t}\n\n\t/**\n\t * Returns a normalized style object or a single value.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px 2px 3em;' );\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );\n\t *\t\t// will log:\n\t *\t\t// {\n\t *\t\t//     top: '1px',\n\t *\t\t//     right: '2px',\n\t *\t\t//     bottom: '3em',\n\t *\t\t//     left: '2px'     // normalized value from margin shorthand\n\t *\t\t// }\n\t *\n\t *\t\tstyles.getNormalized( 'margin-left' ); // -> '2px'\n\t *\n\t * **Note**: This method will only return normalized styles if a style processor was defined.\n\t *\n\t * @param {String} name Style name.\n\t * @returns {Object|String|undefined}\n\t */\n\tgetNormalized( name ) {\n\t\treturn this._styleProcessor.getNormalized( name, this._styles );\n\t}\n\n\t/**\n\t * Returns a normalized style string. Styles are sorted by name.\n\t *\n\t *\t\tstyles.set( 'margin' , '1px' );\n\t *\t\tstyles.set( 'background', '#f00' );\n\t *\n\t *\t\tstyles.toString(); // -> 'background:#f00;margin:1px;'\n\t *\n\t * **Note**: This method supports normalized styles if defined.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.set( 'margin' , '1px' );\n\t *\t\tstyles.set( 'background', '#f00' );\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\t\tstyles.remove( 'margin-right' );\n\t *\n\t *\t\tstyles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'\n\t *\n\t * @returns {String}\n\t */\n\ttoString() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this._getStylesEntries()\n\t\t\t.map( arr => arr.join( ':' ) )\n\t\t\t.sort()\n\t\t\t.join( ';' ) + ';';\n\t}\n\n\t/**\n\t * Returns property as a value string or undefined if property is not set.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.set( 'margin-bottom', '3em' );\n\t *\n\t *\t\tstyles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'\n\t *\n\t * Note, however, that all sub-values must be set for the longhand property name to return a value:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.remove( 'margin-bottom' );\n\t *\n\t *\t\tstyles.getAsString( 'margin' ); // -> undefined\n\t *\n\t * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.\n\t * Instead, you should use:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.remove( 'margin-bottom' );\n\t *\n\t *\t\tfor ( const styleName of styles.getStyleNames() ) {\n\t *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n\t *\t\t}\n\t *\t\t// 'margin-top', '1px'\n\t *\t\t// 'margin-right', '1px'\n\t *\t\t// 'margin-left', '1px'\n\t *\n\t * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all\n\t * the currently set style values. So, if all the 4 margin values would be set\n\t * the for-of loop above would yield only `'margin'`, `'1px'`:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\n\t *\t\tfor ( const styleName of styles.getStyleNames() ) {\n\t *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n\t *\t\t}\n\t *\t\t// 'margin', '1px'\n\t *\n\t * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.\n\t *\n\t * @param {String} propertyName\n\t * @returns {String|undefined}\n\t */\n\tgetAsString( propertyName ) {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._styles[ propertyName ] && !isObject( this._styles[ propertyName ] ) ) {\n\t\t\t// Try return styles set directly - values that are not parsed.\n\t\t\treturn this._styles[ propertyName ];\n\t\t}\n\n\t\tconst styles = this._styleProcessor.getReducedForm( propertyName, this._styles );\n\n\t\tconst propertyDescriptor = styles.find( ( [ property ] ) => property === propertyName );\n\n\t\t// Only return a value if it is set;\n\t\tif ( Array.isArray( propertyDescriptor ) ) {\n\t\t\treturn propertyDescriptor[ 1 ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns style property names as they would appear when using {@link #toString `#toString()`}.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tgetStyleNames() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst entries = this._getStylesEntries();\n\n\t\treturn entries.map( ( [ key ] ) => key );\n\t}\n\n\t/**\n\t * Removes all styles.\n\t */\n\tclear() {\n\t\tthis._styles = {};\n\t}\n\n\t/**\n\t * Returns normalized styles entries for further processing.\n\t *\n\t * @private\n\t * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n\t */\n\t_getStylesEntries() {\n\t\tconst parsed = [];\n\n\t\tconst keys = Object.keys( this._styles );\n\n\t\tfor ( const key of keys ) {\n\t\t\tparsed.push( ...this._styleProcessor.getReducedForm( key, this._styles ) );\n\t\t}\n\n\t\treturn parsed;\n\t}\n\n\t/**\n\t * Removes empty objects upon removing an entry from internal object.\n\t *\n\t * @param {String} path\n\t * @private\n\t */\n\t_cleanEmptyObjectsOnPath( path ) {\n\t\tconst pathParts = path.split( '.' );\n\t\tconst isChildPath = pathParts.length > 1;\n\n\t\tif ( !isChildPath ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst parentPath = pathParts.splice( 0, pathParts.length - 1 ).join( '.' );\n\n\t\tconst parentObject = get( this._styles, parentPath );\n\n\t\tif ( !parentObject ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isParentEmpty = !Array.from( Object.keys( parentObject ) ).length;\n\n\t\tif ( isParentEmpty ) {\n\t\t\tthis.remove( parentPath );\n\t\t}\n\t}\n}\n\n/**\n * Style processor is responsible for writing and reading a normalized styles object.\n */\nexport class StylesProcessor {\n\t/**\n\t * Creates StylesProcessor instance.\n\t *\n\t * @private\n\t */\n\tconstructor() {\n\t\tthis._normalizers = new Map();\n\t\tthis._extractors = new Map();\n\t\tthis._reducers = new Map();\n\t\tthis._consumables = new Map();\n\t}\n\n\t/**\n\t * Parse style string value to a normalized object and appends it to styles object.\n\t *\n\t *\t\tconst styles = {};\n\t *\n\t *\t\tstylesProcessor.toNormalizedForm( 'margin', '1px', styles );\n\t *\n\t *\t\t// styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }\n\t *\n\t * **Note**: To define normalizer callbacks use {@link #setNormalizer}.\n\t *\n\t * @param {String} name Name of style property.\n\t * @param {String} propertyValue Value of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t */\n\ttoNormalizedForm( name, propertyValue, styles ) {\n\t\tif ( isObject( propertyValue ) ) {\n\t\t\tappendStyleValue( styles, toPath( name ), propertyValue );\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._normalizers.has( name ) ) {\n\t\t\tconst normalizer = this._normalizers.get( name );\n\n\t\t\tconst { path, value } = normalizer( propertyValue );\n\n\t\t\tappendStyleValue( styles, path, value );\n\t\t} else {\n\t\t\tappendStyleValue( styles, name, propertyValue );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a normalized version of a style property.\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },\n\t *\t\t\tbackground: { color: '#f00' }\n\t *\t\t};\n\t *\n\t *\t\tstylesProcessor.getNormalized( 'background' );\n\t *\t\t// will return: { color: '#f00' }\n\t *\n\t *\t\tstylesProcessor.getNormalized( 'margin-top' );\n\t *\t\t// will return: '1px'\n\t *\n\t * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.\n\t *\n\t * @param {String} name Name of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t * @returns {*}\n\t */\n\tgetNormalized( name, styles ) {\n\t\tif ( !name ) {\n\t\t\treturn merge( {}, styles );\n\t\t}\n\n\t\t// Might be empty string.\n\t\tif ( styles[ name ] !== undefined ) {\n\t\t\treturn styles[ name ];\n\t\t}\n\n\t\tif ( this._extractors.has( name ) ) {\n\t\t\tconst extractor = this._extractors.get( name );\n\n\t\t\tif ( typeof extractor === 'string' ) {\n\t\t\t\treturn get( styles, extractor );\n\t\t\t}\n\n\t\t\tconst value = extractor( name, styles );\n\n\t\t\tif ( value ) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\treturn get( styles, toPath( name ) );\n\t}\n\n\t/**\n\t * Returns a reduced form of style property form normalized object.\n\t *\n\t * For default margin reducer, the below code:\n\t *\n\t *\t\tstylesProcessor.getReducedForm( 'margin', {\n\t *\t\t\tmargin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }\n\t *\t\t} );\n\t *\n\t * will return:\n\t *\n\t *\t\t[\n\t *\t\t\t[ 'margin', '1px 1px 2px' ]\n\t *\t\t]\n\t *\n\t * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:\n\t *\n\t *\t\t[\n\t *\t\t\t[ 'margin-top', '1px' ],\n\t *\t\t\t[ 'margin-right', '1px' ],\n\t *\t\t\t[ 'margin-bottom', '2px' ]\n\t *\t\t\t// the 'left' value is missing - cannot use 'margin' shorthand.\n\t *\t\t]\n\t *\n\t * **Note**: To define reducer callbacks use {@link #setReducer}.\n\t *\n\t * @param {String} name\n\t * @param {String} name Name of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n\t */\n\tgetReducedForm( name, styles ) {\n\t\tconst normalizedValue = this.getNormalized( name, styles );\n\n\t\t// Might be empty string.\n\t\tif ( normalizedValue === undefined ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( this._reducers.has( name ) ) {\n\t\t\tconst reducer = this._reducers.get( name );\n\n\t\t\treturn reducer( normalizedValue );\n\t\t}\n\n\t\treturn [ [ name, normalizedValue ] ];\n\t}\n\n\t/**\n\t * Returns related style names.\n\t *\n\t *\t\tstylesProcessor.getRelatedStyles( 'margin' );\n\t *\t\t// will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];\n\t *\n\t *\t\tstylesProcessor.getRelatedStyles( 'margin-top' );\n\t *\t\t// will return: [ 'margin' ];\n\t *\n\t * **Note**: To define new style relations load an existing style processor or use\n\t * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.\n\t *\n\t * @param {String} name\n\t * @returns {Array.<String>}\n\t */\n\tgetRelatedStyles( name ) {\n\t\treturn this._consumables.get( name ) || [];\n\t}\n\n\t/**\n\t * Adds a normalizer method for a style property.\n\t *\n\t * A normalizer returns describing how the value should be normalized.\n\t *\n\t * For instance 'margin' style is a shorthand for four margin values:\n\t *\n\t * - 'margin-top'\n\t * - 'margin-right'\n\t * - 'margin-bottom'\n\t * - 'margin-left'\n\t *\n\t * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for\n\t * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.\n\t *\n\t * A normalizer should parse various margin notations as a single object:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: {\n\t *\t\t\t\ttop: '1px',\n\t *\t\t\t\tright: '2em',\n\t *\t\t\t\tbottom: '1px',\n\t *\t\t\t\tleft: '2em'\n\t *\t\t\t}\n\t *\t\t};\n\t *\n\t * Thus a normalizer for 'margin' style should return an object defining style path and value to store:\n\t *\n\t *\t\tconst returnValue = {\n\t *\t\t\tpath: 'margin',\n\t *\t\t\tvalue: {\n\t *\t\t\t\ttop: '1px',\n\t *\t\t\t\tright: '2em',\n\t *\t\t\t\tbottom: '1px',\n\t *\t\t\t\tleft: '2em'\n\t *\t\t\t}\n\t *\t\t};\n\t *\n\t * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below\n\t * is an example for 'margin-top' style property normalizer:\n\t *\n\t *\t\tstylesProcessor.setNormalizer( 'margin-top', valueString => {\n\t *\t\t\treturn {\n\t *\t\t\t\tpath: 'margin.top',\n\t *\t\t\t\tvalue: valueString\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function} callback\n\t */\n\tsetNormalizer( name, callback ) {\n\t\tthis._normalizers.set( name, callback );\n\t}\n\n\t/**\n\t * Adds a extractor callback for a style property.\n\t *\n\t * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: {\n\t *\t\t\t\ttop: 'value'\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance\n\t * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`\n\t * shorthands. The default border styles processors stores styles as:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tborder: {\n\t *\t\t\t\tstyle: {\n\t *\t\t\t\t\ttop: 'solid'\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * as it is better to modify border style independently from other values. On the other part the output of the border might be\n\t * desired as `border-top`, `border-left`, etc notation.\n\t *\n\t * In the above example a reducer should return a side border value that combines style, color and width:\n\t *\n\t *\t\tstyleProcessor.setExtractor( 'border-top', styles => {\n\t *\t\t\treturn {\n\t *\t\t\t\tcolor: styles.border.color.top,\n\t *\t\t\t\tstyle: styles.border.style.top,\n\t *\t\t\t\twidth: styles.border.width.top\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function|String} callbackOrPath Callback that return a requested value or path string for single values.\n\t */\n\tsetExtractor( name, callbackOrPath ) {\n\t\tthis._extractors.set( name, callbackOrPath );\n\t}\n\n\t/**\n\t * Adds a reducer callback for a style property.\n\t *\n\t * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as\n\t * by default the direct value from style path is taken.\n\t *\n\t * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples\n\t * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:\n\t *\n\t *\t\tconst marginShortHandTuple = [\n\t *\t\t\t[ 'margin', '1px 1px 2px' ]\n\t *\t\t];\n\t *\n\t * or a longhand tuples for defined values:\n\t *\n\t *\t\t// Considering margin.bottom and margin.left are undefined.\n\t *\t\tconst marginLonghandsTuples = [\n\t *\t\t\t[ 'margin-top', '1px' ],\n\t *\t\t\t[ 'margin-right', '1px' ]\n\t *\t\t];\n\t *\n\t * A reducer obtains a normalized style value:\n\t *\n\t *\t\t// Simplified reducer that always outputs 4 values which are always present:\n\t *\t\tstylesProcessor.setReducer( 'margin', margin => {\n\t *\t\t\treturn [\n\t *\t\t\t\t[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function} callback\n\t */\n\tsetReducer( name, callback ) {\n\t\tthis._reducers.set( name, callback );\n\t}\n\n\t/**\n\t * Defines a style shorthand relation to other style notations.\n\t *\n\t *\t\tstylesProcessor.setStyleRelation( 'margin', [\n\t *\t\t\t'margin-top',\n\t *\t\t\t'margin-right',\n\t *\t\t\t'margin-bottom',\n\t *\t\t\t'margin-left'\n\t *\t\t] );\n\t *\n\t * This enables expanding of style names for shorthands. For instance, if defined,\n\t * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created\n\t * for long-hand margin style notation alongside the `'margin'` item.\n\t *\n\t * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just\n\t * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and\n\t * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.\n\t * However, once `margin-left` is consumed, `margin` will not be consumable anymore.\n\t *\n\t * @param {String} shorthandName\n\t * @param {Array.<String>} styleNames\n\t */\n\tsetStyleRelation( shorthandName, styleNames ) {\n\t\tthis._mapStyleNames( shorthandName, styleNames );\n\n\t\tfor ( const alsoName of styleNames ) {\n\t\t\tthis._mapStyleNames( alsoName, [ shorthandName ] );\n\t\t}\n\t}\n\n\t/**\n\t * Set two-way binding of style names.\n\t *\n\t * @param {String} name\n\t * @param {Array.<String>} styleNames\n\t * @private\n\t */\n\t_mapStyleNames( name, styleNames ) {\n\t\tif ( !this._consumables.has( name ) ) {\n\t\t\tthis._consumables.set( name, [] );\n\t\t}\n\n\t\tthis._consumables.get( name ).push( ...styleNames );\n\t}\n}\n\n// Parses inline styles and puts property - value pairs into styles map.\n//\n// @param {String} stylesString Styles to parse.\n// @returns {Map.<String, String>} stylesMap Map of parsed properties and values.\nfunction parseInlineStyles( stylesString ) {\n\t// `null` if no quote was found in input string or last found quote was a closing quote. See below.\n\tlet quoteType = null;\n\tlet propertyNameStart = 0;\n\tlet propertyValueStart = 0;\n\tlet propertyName = null;\n\n\tconst stylesMap = new Map();\n\n\t// Do not set anything if input string is empty.\n\tif ( stylesString === '' ) {\n\t\treturn stylesMap;\n\t}\n\n\t// Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n\tif ( stylesString.charAt( stylesString.length - 1 ) != ';' ) {\n\t\tstylesString = stylesString + ';';\n\t}\n\n\t// Seek the whole string for \"special characters\".\n\tfor ( let i = 0; i < stylesString.length; i++ ) {\n\t\tconst char = stylesString.charAt( i );\n\n\t\tif ( quoteType === null ) {\n\t\t\t// No quote found yet or last found quote was a closing quote.\n\t\t\tswitch ( char ) {\n\t\t\t\tcase ':':\n\t\t\t\t\t// Most of time colon means that property name just ended.\n\t\t\t\t\t// Sometimes however `:` is found inside property value (for example in background image url).\n\t\t\t\t\tif ( !propertyName ) {\n\t\t\t\t\t\t// Treat this as end of property only if property name is not already saved.\n\t\t\t\t\t\t// Save property name.\n\t\t\t\t\t\tpropertyName = stylesString.substr( propertyNameStart, i - propertyNameStart );\n\t\t\t\t\t\t// Save this point as the start of property value.\n\t\t\t\t\t\tpropertyValueStart = i + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\t// Opening quote found (this is an opening quote, because `quoteType` is `null`).\n\t\t\t\t\tquoteType = char;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ';': {\n\t\t\t\t\t// Property value just ended.\n\t\t\t\t\t// Use previously stored property value start to obtain property value.\n\t\t\t\t\tconst propertyValue = stylesString.substr( propertyValueStart, i - propertyValueStart );\n\n\t\t\t\t\tif ( propertyName ) {\n\t\t\t\t\t\t// Save parsed part.\n\t\t\t\t\t\tstylesMap.set( propertyName.trim(), propertyValue.trim() );\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyName = null;\n\n\t\t\t\t\t// Save this point as property name start. Property name starts immediately after previous property value ends.\n\t\t\t\t\tpropertyNameStart = i + 1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( char === quoteType ) {\n\t\t\t// If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n\t\t\tquoteType = null;\n\t\t}\n\t}\n\n\treturn stylesMap;\n}\n\n// Return lodash compatible path from style name.\nfunction toPath( name ) {\n\treturn name.replace( '-', '.' );\n}\n\n// Appends style definition to the styles object.\n//\n// @param {String} nameOrPath\n// @param {String|Object} valueOrObject\n// @private\nfunction appendStyleValue( stylesObject, nameOrPath, valueOrObject ) {\n\tlet valueToSet = valueOrObject;\n\n\tif ( isObject( valueOrObject ) ) {\n\t\tvalueToSet = merge( {}, get( stylesObject, nameOrPath ), valueOrObject );\n\t}\n\n\tset( stylesObject, nameOrPath, valueToSet );\n}\n\n/**\n * A CSS style property descriptor that contains tuplet of two strings:\n *\n * - first string describes property name\n * - second string describes property value\n *\n *\t\tconst marginDescriptor = [ 'margin', '2px 3em' ];\n *\t\tconst marginTopDescriptor = [ 'margin-top', '2px' ];\n *\n * @typedef {Array.<String, String>} module:engine/view/stylesmap~PropertyDescriptor\n */\n\n/**\n * An object describing values associated with the sides of a box, for instance margins, paddings,\n * border widths, border colors, etc.\n *\n *\t\tconst margin = {\n *\t\t\ttop: '1px',\n *\t\t\tright: '3px',\n *\t\t\tbottom: '3px',\n *\t\t\tleft: '7px'\n *\t\t};\n *\n *\t\tconst borderColor = {\n *\t\t\ttop: 'red',\n *\t\t\tright: 'blue',\n *\t\t\tbottom: 'blue',\n *\t\t\tleft: 'red'\n *\t\t};\n *\n * @typedef {Object} module:engine/view/stylesmap~BoxSides\n *\n * @property {String} top Top side value.\n * @property {String} right Right side value.\n * @property {String} bottom Bottom side value.\n * @property {String} left Left side value.\n */\n"]},"metadata":{},"sourceType":"module"}