{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n */\n\nexport default function deleteContent(model, selection, options = {}) {\n  if (selection.isCollapsed) {\n    return;\n  }\n\n  const selRange = selection.getFirstRange(); // If the selection is already removed, don't do anything.\n\n  if (selRange.root.rootName == '$graveyard') {\n    return;\n  }\n\n  const schema = model.schema;\n  model.change(writer => {\n    // 1. Replace the entire content with paragraph.\n    // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {\n      replaceEntireContentWithParagraph(writer, selection, schema);\n      return;\n    } // Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n\n\n    const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange); // 2. Remove the content if there is any.\n\n    if (!selRange.start.isTouching(selRange.end)) {\n      writer.remove(selRange);\n    } // 3. Merge elements in the right branch to the elements in the left branch.\n    // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n    //\n    // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n    //\n    // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n    // as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n    // want to override that behavior anyway.\n\n\n    if (!options.leaveUnmerged) {\n      mergeBranches(writer, startPosition, endPosition); // TMP this will be replaced with a postfixer.\n      // We need to check and strip disallowed attributes in all nested nodes because after merge\n      // some attributes could end up in a path where are disallowed.\n      //\n      // e.g. bold is disallowed for <H1>\n      // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\n      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);\n    }\n\n    collapseSelectionAt(writer, selection, startPosition); // 4. Add a paragraph to set selection in it.\n    // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n    // If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n\n    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {\n      insertParagraph(writer, startPosition, selection);\n    }\n\n    startPosition.detach();\n    endPosition.detach();\n  });\n} // Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\n\nfunction getLivePositionsForSelectedBlocks(range) {\n  const model = range.root.document.model;\n  const startPosition = range.start;\n  let endPosition = range.end; // If the end of selection is at the start position of last block in the selection, then\n  // shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n\n  if (model.hasContent(range, {\n    ignoreMarkers: true\n  })) {\n    const endBlock = getParentBlock(endPosition);\n\n    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {\n      // Create forward selection as a probe to find a valid position after excluding last block from the range.\n      const selection = model.createSelection(range); // Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n      // This is how modifySelection works and here we are making use of it.\n\n      model.modifySelection(selection, {\n        direction: 'backward'\n      });\n      endPosition = selection.getLastPosition();\n    }\n  }\n\n  return [LivePosition.fromPosition(startPosition, 'toPrevious'), LivePosition.fromPosition(endPosition, 'toNext')];\n} // Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\n\n\nfunction getParentBlock(position) {\n  const element = position.parent;\n  const schema = element.root.document.model.schema;\n  const ancestors = element.getAncestors({\n    parentFirst: true,\n    includeSelf: true\n  });\n\n  for (const element of ancestors) {\n    if (schema.isLimit(element)) {\n      return null;\n    }\n\n    if (schema.isBlock(element)) {\n      return element;\n    }\n  }\n} // This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\n\n\nfunction mergeBranches(writer, startPosition, endPosition) {\n  const model = writer.model; // Verify if there is a need and possibility to merge.\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n  // then merge those to the right element so that it's properties are preserved (name, attributes).\n  // Because of OT merging is used instead of removing elements.\n  //\n  // Merge left:\n  //     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n  //     <paragraph>]bar</paragraph>  ->               --^\n  //\n  // Merge right:\n  //     <heading1>[</heading1>       ->\n  //     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n  //\n  // Merge left:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n  //         <paragraph>]bar</paragraph>  ->                   --^\n  //     </blockQuote>                    ->  </blockQuote>\n  //\n  // Merge right:\n  //     <blockQuote>                     ->  <blockQuote>\n  //         <heading1>[</heading1>       ->\n  //         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n  //     </blockQuote>                    ->  </blockQuote>\n  // Merging should not go deeper than common ancestor.\n\n\n  const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition);\n\n  if (!model.hasContent(startAncestor, {\n    ignoreMarkers: true\n  }) && model.hasContent(endAncestor, {\n    ignoreMarkers: true\n  })) {\n    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);\n  } else {\n    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);\n  }\n} // Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\n\n\nfunction mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.\n\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  } // Remember next positions to merge in next recursive step (also used as modification points pointers).\n\n\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement); // Move endElement just after startElement if they aren't siblings.\n\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n    //     </blockQuote>                    ->  </blockQuote>                ^\n    //     <blockBlock>                     ->  <blockBlock>                 |\n    //         <paragraph>]bar</paragraph>  ->      ]                     ---\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(endElement, startPosition);\n  } // Merge two siblings (nodes on sides of startPosition):\n  //\n  //     <blockQuote>                                             ->  <blockQuote>\n  //         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                                            ->  </blockQuote>\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         ]                                                    ->      ]\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n  //\n\n\n  writer.merge(startPosition); // Remove empty end ancestors:\n  //\n  //     <blockQuote>                      ->  <blockQuote>\n  //         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n  //     </blockQuote>                     ->  </blockQuote>\n  //     <blockBlock>                      ->\n  //         ]                             ->  ]\n  //     </blockBlock>                     ->\n  //\n\n  while (endPosition.parent.isEmpty) {\n    const parentToRemove = endPosition.parent;\n    endPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Verify if there is a need and possibility to merge next level.\n\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\n\n  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);\n} // Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\n\n\nfunction mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.\n\n  if (startElement == commonAncestor || endElement == commonAncestor) {\n    return;\n  } // Remember next positions to merge in next recursive step (also used as modification points pointers).\n\n\n  startPosition = writer.createPositionAfter(startElement);\n  endPosition = writer.createPositionBefore(endElement); // Move startElement just before endElement if they aren't siblings.\n\n  if (!endPosition.isEqual(startPosition)) {\n    //\n    //     <blockQuote>                     ->  <blockQuote>\n    //         <heading1>foo[</heading1>    ->      [                   ---\n    //     </blockQuote>                    ->  </blockQuote>              |\n    //     <blockBlock>                     ->  <blockBlock>               v\n    //         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n    //     </blockBlock>                    ->  </blockBlock>\n    //\n    writer.insert(startElement, endPosition);\n  } // Remove empty end ancestors:\n  //\n  //     <blockQuote>                                             ->\n  //         [                                                    ->  [\n  //     </blockQuote>                                            ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n\n\n  while (startPosition.parent.isEmpty) {\n    const parentToRemove = startPosition.parent;\n    startPosition = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Update endPosition after inserting and removing elements.\n\n\n  endPosition = writer.createPositionBefore(endElement); // Merge right two siblings (nodes on sides of endPosition):\n  //                                                              ->\n  //     [                                                        ->  [\n  //                                                              ->\n  //     <blockBlock>                                             ->  <blockBlock>\n  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n  //     </blockBlock>                                            ->  </blockBlock>\n  //\n  // Or in simple case (without moving elements in above if):\n  //     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n  //\n\n  mergeRight(writer, endPosition); // Verify if there is a need and possibility to merge next level.\n\n  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {\n    return;\n  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\n\n  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);\n} // There is no right merge operation so we need to simulate it.\n\n\nfunction mergeRight(writer, position) {\n  const startElement = position.nodeBefore;\n  const endElement = position.nodeAfter;\n\n  if (startElement.name != endElement.name) {\n    writer.rename(startElement, endElement.name);\n  }\n\n  writer.clearAttributes(startElement);\n  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);\n  writer.merge(position);\n} // Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\n\n\nfunction checkShouldMerge(schema, startPosition, endPosition) {\n  const startElement = startPosition.parent;\n  const endElement = endPosition.parent; // If both positions ended up in the same parent, then there's nothing more to merge:\n  // <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n\n  if (startElement == endElement) {\n    return false;\n  } // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\n\n  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {\n    return false;\n  } // Check if operations we'll need to do won't need to cross object or limit boundaries.\n  // E.g., we can't merge endElement into startElement in this case:\n  // <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n\n\n  return isCrossingLimitElement(startPosition, endPosition, schema);\n} // Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\n\n\nfunction getAncestorsJustBelowCommonAncestor(positionA, positionB) {\n  const ancestorsA = positionA.getAncestors();\n  const ancestorsB = positionB.getAncestors();\n  let i = 0;\n\n  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {\n    i++;\n  }\n\n  return [ancestorsA[i], ancestorsB[i]];\n}\n\nfunction shouldAutoparagraph(schema, position) {\n  const isTextAllowed = schema.checkChild(position, '$text');\n  const isParagraphAllowed = schema.checkChild(position, 'paragraph');\n  return !isTextAllowed && isParagraphAllowed;\n} // Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\n\n\nfunction isCrossingLimitElement(leftPos, rightPos, schema) {\n  const rangeToCheck = new Range(leftPos, rightPos);\n\n  for (const value of rangeToCheck.getWalker()) {\n    if (schema.isLimit(value.item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction insertParagraph(writer, position, selection) {\n  const paragraph = writer.createElement('paragraph');\n  writer.insert(paragraph, position);\n  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));\n}\n\nfunction replaceEntireContentWithParagraph(writer, selection) {\n  const limitElement = writer.model.schema.getLimitElement(selection);\n  writer.remove(writer.createRangeIn(limitElement));\n  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);\n} // We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\n\n\nfunction shouldEntireContentBeReplacedWithParagraph(schema, selection) {\n  const limitElement = schema.getLimitElement(selection);\n\n  if (!selection.containsEntireContent(limitElement)) {\n    return false;\n  }\n\n  const range = selection.getFirstRange();\n\n  if (range.start.parent == range.end.parent) {\n    return false;\n  }\n\n  return schema.checkChild(limitElement, 'paragraph');\n} // Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\n\n\nfunction collapseSelectionAt(writer, selection, positionOrRange) {\n  if (selection instanceof DocumentSelection) {\n    writer.setSelection(positionOrRange);\n  } else {\n    selection.setTo(positionOrRange);\n  }\n}","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js"],"names":["LivePosition","Range","DocumentSelection","deleteContent","model","selection","options","isCollapsed","selRange","getFirstRange","root","rootName","schema","change","writer","doNotResetEntireContent","shouldEntireContentBeReplacedWithParagraph","replaceEntireContentWithParagraph","startPosition","endPosition","getLivePositionsForSelectedBlocks","start","isTouching","end","remove","leaveUnmerged","mergeBranches","removeDisallowedAttributes","parent","getChildren","collapseSelectionAt","doNotAutoparagraph","shouldAutoparagraph","insertParagraph","detach","range","document","hasContent","ignoreMarkers","endBlock","getParentBlock","createPositionAt","createSelection","modifySelection","direction","getLastPosition","fromPosition","position","element","ancestors","getAncestors","parentFirst","includeSelf","isLimit","isBlock","checkShouldMerge","startAncestor","endAncestor","getAncestorsJustBelowCommonAncestor","mergeBranchesRight","mergeBranchesLeft","commonAncestor","startElement","endElement","createPositionAfter","createPositionBefore","isEqual","insert","merge","isEmpty","parentToRemove","mergeRight","nodeBefore","nodeAfter","name","rename","clearAttributes","setAttributes","Object","fromEntries","getAttributes","isCrossingLimitElement","positionA","positionB","ancestorsA","ancestorsB","i","isTextAllowed","checkChild","isParagraphAllowed","leftPos","rightPos","rangeToCheck","value","getWalker","item","paragraph","createElement","limitElement","getLimitElement","createRangeIn","containsEntireContent","positionOrRange","setSelection","setTo"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\n\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).\n *\n * If you use this option you need to make sure to handle invalid selections yourself or leave\n * them to the selection post-fixer (may not always work).\n *\n * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n */\nexport default function deleteContent( model, selection, options = {} ) {\n\tif ( selection.isCollapsed ) {\n\t\treturn;\n\t}\n\n\tconst selRange = selection.getFirstRange();\n\n\t// If the selection is already removed, don't do anything.\n\tif ( selRange.root.rootName == '$graveyard' ) {\n\t\treturn;\n\t}\n\n\tconst schema = model.schema;\n\n\tmodel.change( writer => {\n\t\t// 1. Replace the entire content with paragraph.\n\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n\t\tif ( !options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph( schema, selection ) ) {\n\t\t\treplaceEntireContentWithParagraph( writer, selection, schema );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Get the live positions for the range adjusted to span only blocks selected from the user perspective.\n\t\tconst [ startPosition, endPosition ] = getLivePositionsForSelectedBlocks( selRange );\n\n\t\t// 2. Remove the content if there is any.\n\t\tif ( !selRange.start.isTouching( selRange.end ) ) {\n\t\t\twriter.remove( selRange );\n\t\t}\n\n\t\t// 3. Merge elements in the right branch to the elements in the left branch.\n\t\t// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n\t\t//\n\t\t// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n\t\t//\n\t\t// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n\t\t// as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n\t\t// want to override that behavior anyway.\n\t\tif ( !options.leaveUnmerged ) {\n\t\t\tmergeBranches( writer, startPosition, endPosition );\n\n\t\t\t// TMP this will be replaced with a postfixer.\n\t\t\t// We need to check and strip disallowed attributes in all nested nodes because after merge\n\t\t\t// some attributes could end up in a path where are disallowed.\n\t\t\t//\n\t\t\t// e.g. bold is disallowed for <H1>\n\t\t\t// <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\t\t\tschema.removeDisallowedAttributes( startPosition.parent.getChildren(), writer );\n\t\t}\n\n\t\tcollapseSelectionAt( writer, selection, startPosition );\n\n\t\t// 4. Add a paragraph to set selection in it.\n\t\t// Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n\t\t// If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.\n\t\tif ( !options.doNotAutoparagraph && shouldAutoparagraph( schema, startPosition ) ) {\n\t\t\tinsertParagraph( writer, startPosition, selection );\n\t\t}\n\n\t\tstartPosition.detach();\n\t\tendPosition.detach();\n\t} );\n}\n\n// Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:\n//\n//     <heading1>[foo</heading1>\n//     <paragraph>bar</paragraph>\n//     <heading1>]abc</heading1>  <-- this block is not considered as selected\n//\n// This is the same behavior as in Selection#getSelectedBlocks() \"special case\".\nfunction getLivePositionsForSelectedBlocks( range ) {\n\tconst model = range.root.document.model;\n\n\tconst startPosition = range.start;\n\tlet endPosition = range.end;\n\n\t// If the end of selection is at the start position of last block in the selection, then\n\t// shrink it to not include that trailing block. Note that this should happen only for not empty selection.\n\tif ( model.hasContent( range, { ignoreMarkers: true } ) ) {\n\t\tconst endBlock = getParentBlock( endPosition );\n\n\t\tif ( endBlock && endPosition.isTouching( model.createPositionAt( endBlock, 0 ) ) ) {\n\t\t\t// Create forward selection as a probe to find a valid position after excluding last block from the range.\n\t\t\tconst selection = model.createSelection( range );\n\n\t\t\t// Modify the forward selection in backward direction to shrink it and remove first position of following block from it.\n\t\t\t// This is how modifySelection works and here we are making use of it.\n\t\t\tmodel.modifySelection( selection, { direction: 'backward' } );\n\n\t\t\tendPosition = selection.getLastPosition();\n\t\t}\n\t}\n\n\treturn [\n\t\tLivePosition.fromPosition( startPosition, 'toPrevious' ),\n\t\tLivePosition.fromPosition( endPosition, 'toNext' )\n\t];\n}\n\n// Finds the lowest element in position's ancestors which is a block.\n// Returns null if a limit element is encountered before reaching a block element.\nfunction getParentBlock( position ) {\n\tconst element = position.parent;\n\tconst schema = element.root.document.model.schema;\n\tconst ancestors = element.getAncestors( { parentFirst: true, includeSelf: true } );\n\n\tfor ( const element of ancestors ) {\n\t\tif ( schema.isLimit( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( schema.isBlock( element ) ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n\n// This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\nfunction mergeBranches( writer, startPosition, endPosition ) {\n\tconst model = writer.model;\n\n\t// Verify if there is a need and possibility to merge.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// If the start element on the common ancestor level is empty, and the end element on the same level is not empty\n\t// then merge those to the right element so that it's properties are preserved (name, attributes).\n\t// Because of OT merging is used instead of removing elements.\n\t//\n\t// Merge left:\n\t//     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>\n\t//     <paragraph>]bar</paragraph>  ->               --^\n\t//\n\t// Merge right:\n\t//     <heading1>[</heading1>       ->\n\t//     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>\n\t//\n\t// Merge left:\n\t//     <blockQuote>                     ->  <blockQuote>\n\t//         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>\n\t//         <paragraph>]bar</paragraph>  ->                   --^\n\t//     </blockQuote>                    ->  </blockQuote>\n\t//\n\t// Merge right:\n\t//     <blockQuote>                     ->  <blockQuote>\n\t//         <heading1>[</heading1>       ->\n\t//         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>\n\t//     </blockQuote>                    ->  </blockQuote>\n\n\t// Merging should not go deeper than common ancestor.\n\tconst [ startAncestor, endAncestor ] = getAncestorsJustBelowCommonAncestor( startPosition, endPosition );\n\n\tif ( !model.hasContent( startAncestor, { ignoreMarkers: true } ) && model.hasContent( endAncestor, { ignoreMarkers: true } ) ) {\n\t\tmergeBranchesRight( writer, startPosition, endPosition, startAncestor.parent );\n\t} else {\n\t\tmergeBranchesLeft( writer, startPosition, endPosition, startAncestor.parent );\n\t}\n}\n\n// Merging blocks to the left (properties of the left block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]\n//     <paragraph>]bar</paragraph>  ->              --^\n//\n// Nested example:\n//     <blockQuote>                     ->  <blockQuote>\n//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>\n//     </blockQuote>                    ->  </blockQuote>]    ^\n//     <blockBlock>                     ->                    |\n//         <paragraph>]bar</paragraph>  ->                 ---\n//     </blockBlock>                    ->\n//\nfunction mergeBranchesLeft( writer, startPosition, endPosition, commonAncestor ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// Merging reached the common ancestor element, stop here.\n\tif ( startElement == commonAncestor || endElement == commonAncestor ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge in next recursive step (also used as modification points pointers).\n\tstartPosition = writer.createPositionAfter( startElement );\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Move endElement just after startElement if they aren't siblings.\n\tif ( !endPosition.isEqual( startPosition ) ) {\n\t\t//\n\t\t//     <blockQuote>                     ->  <blockQuote>\n\t\t//         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>\n\t\t//     </blockQuote>                    ->  </blockQuote>                ^\n\t\t//     <blockBlock>                     ->  <blockBlock>                 |\n\t\t//         <paragraph>]bar</paragraph>  ->      ]                     ---\n\t\t//     </blockBlock>                    ->  </blockBlock>\n\t\t//\n\t\twriter.insert( endElement, startPosition );\n\t}\n\n\t// Merge two siblings (nodes on sides of startPosition):\n\t//\n\t//     <blockQuote>                                             ->  <blockQuote>\n\t//         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>\n\t//     </blockQuote>                                            ->  </blockQuote>\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         ]                                                    ->      ]\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\t// Or in simple case (without moving elements in above if):\n\t//     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]\n\t//\n\twriter.merge( startPosition );\n\n\t// Remove empty end ancestors:\n\t//\n\t//     <blockQuote>                      ->  <blockQuote>\n\t//         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>\n\t//     </blockQuote>                     ->  </blockQuote>\n\t//     <blockBlock>                      ->\n\t//         ]                             ->  ]\n\t//     </blockBlock>                     ->\n\t//\n\twhile ( endPosition.parent.isEmpty ) {\n\t\tconst parentToRemove = endPosition.parent;\n\n\t\tendPosition = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Verify if there is a need and possibility to merge next level.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\tmergeBranchesLeft( writer, startPosition, endPosition, commonAncestor );\n}\n\n// Merging blocks to the right (properties of the right block are preserved).\n// Simple example:\n//     <heading1>foo[</heading1>    ->            --v\n//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>\n//\n// Nested example:\n//     <blockQuote>                     ->\n//         <heading1>foo[</heading1>    ->              ---\n//     </blockQuote>                    ->                 |\n//     <blockBlock>                     ->  [<blockBlock>  v\n//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n//     </blockBlock>                    ->  </blockBlock>\n//\nfunction mergeBranchesRight( writer, startPosition, endPosition, commonAncestor ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// Merging reached the common ancestor element, stop here.\n\tif ( startElement == commonAncestor || endElement == commonAncestor ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge in next recursive step (also used as modification points pointers).\n\tstartPosition = writer.createPositionAfter( startElement );\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Move startElement just before endElement if they aren't siblings.\n\tif ( !endPosition.isEqual( startPosition ) ) {\n\t\t//\n\t\t//     <blockQuote>                     ->  <blockQuote>\n\t\t//         <heading1>foo[</heading1>    ->      [                   ---\n\t\t//     </blockQuote>                    ->  </blockQuote>              |\n\t\t//     <blockBlock>                     ->  <blockBlock>               v\n\t\t//         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n\t\t//     </blockBlock>                    ->  </blockBlock>\n\t\t//\n\t\twriter.insert( startElement, endPosition );\n\t}\n\n\t// Remove empty end ancestors:\n\t//\n\t//     <blockQuote>                                             ->\n\t//         [                                                    ->  [\n\t//     </blockQuote>                                            ->\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\twhile ( startPosition.parent.isEmpty ) {\n\t\tconst parentToRemove = startPosition.parent;\n\n\t\tstartPosition = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Update endPosition after inserting and removing elements.\n\tendPosition = writer.createPositionBefore( endElement );\n\n\t// Merge right two siblings (nodes on sides of endPosition):\n\t//                                                              ->\n\t//     [                                                        ->  [\n\t//                                                              ->\n\t//     <blockBlock>                                             ->  <blockBlock>\n\t//         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>\n\t//     </blockBlock>                                            ->  </blockBlock>\n\t//\n\t// Or in simple case (without moving elements in above if):\n\t//     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>\n\t//\n\tmergeRight( writer, endPosition );\n\n\t// Verify if there is a need and possibility to merge next level.\n\tif ( !checkShouldMerge( writer.model.schema, startPosition, endPosition ) ) {\n\t\treturn;\n\t}\n\n\t// Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).\n\tmergeBranchesRight( writer, startPosition, endPosition, commonAncestor );\n}\n\n// There is no right merge operation so we need to simulate it.\nfunction mergeRight( writer, position ) {\n\tconst startElement = position.nodeBefore;\n\tconst endElement = position.nodeAfter;\n\n\tif ( startElement.name != endElement.name ) {\n\t\twriter.rename( startElement, endElement.name );\n\t}\n\n\twriter.clearAttributes( startElement );\n\twriter.setAttributes( Object.fromEntries( endElement.getAttributes() ), startElement );\n\n\twriter.merge( position );\n}\n\n// Verifies if merging is needed and possible. It's not needed if both positions are in the same element\n// and it's not possible if some element is a limit or the range crosses a limit element.\nfunction checkShouldMerge( schema, startPosition, endPosition ) {\n\tconst startElement = startPosition.parent;\n\tconst endElement = endPosition.parent;\n\n\t// If both positions ended up in the same parent, then there's nothing more to merge:\n\t// <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>\n\tif ( startElement == endElement ) {\n\t\treturn false;\n\t}\n\n\t// If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\tif ( schema.isLimit( startElement ) || schema.isLimit( endElement ) ) {\n\t\treturn false;\n\t}\n\n\t// Check if operations we'll need to do won't need to cross object or limit boundaries.\n\t// E.g., we can't merge endElement into startElement in this case:\n\t// <limit><startElement>x[</startElement></limit><endElement>]</endElement>\n\treturn isCrossingLimitElement( startPosition, endPosition, schema );\n}\n\n// Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.\nfunction getAncestorsJustBelowCommonAncestor( positionA, positionB ) {\n\tconst ancestorsA = positionA.getAncestors();\n\tconst ancestorsB = positionB.getAncestors();\n\n\tlet i = 0;\n\n\twhile ( ancestorsA[ i ] && ancestorsA[ i ] == ancestorsB[ i ] ) {\n\t\ti++;\n\t}\n\n\treturn [ ancestorsA[ i ], ancestorsB[ i ] ];\n}\n\nfunction shouldAutoparagraph( schema, position ) {\n\tconst isTextAllowed = schema.checkChild( position, '$text' );\n\tconst isParagraphAllowed = schema.checkChild( position, 'paragraph' );\n\n\treturn !isTextAllowed && isParagraphAllowed;\n}\n\n// Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\nfunction isCrossingLimitElement( leftPos, rightPos, schema ) {\n\tconst rangeToCheck = new Range( leftPos, rightPos );\n\n\tfor ( const value of rangeToCheck.getWalker() ) {\n\t\tif ( schema.isLimit( value.item ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction insertParagraph( writer, position, selection ) {\n\tconst paragraph = writer.createElement( 'paragraph' );\n\n\twriter.insert( paragraph, position );\n\n\tcollapseSelectionAt( writer, selection, writer.createPositionAt( paragraph, 0 ) );\n}\n\nfunction replaceEntireContentWithParagraph( writer, selection ) {\n\tconst limitElement = writer.model.schema.getLimitElement( selection );\n\n\twriter.remove( writer.createRangeIn( limitElement ) );\n\tinsertParagraph( writer, writer.createPositionAt( limitElement, 0 ), selection );\n}\n\n// We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\nfunction shouldEntireContentBeReplacedWithParagraph( schema, selection ) {\n\tconst limitElement = schema.getLimitElement( selection );\n\n\tif ( !selection.containsEntireContent( limitElement ) ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getFirstRange();\n\n\tif ( range.start.parent == range.end.parent ) {\n\t\treturn false;\n\t}\n\n\treturn schema.checkChild( limitElement, 'paragraph' );\n}\n\n// Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\nfunction collapseSelectionAt( writer, selection, positionOrRange ) {\n\tif ( selection instanceof DocumentSelection ) {\n\t\twriter.setSelection( positionOrRange );\n\t} else {\n\t\tselection.setTo( positionOrRange );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}