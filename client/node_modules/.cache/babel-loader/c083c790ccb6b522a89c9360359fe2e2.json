{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * `UpcastDispatcher` is a central point of {@link module:engine/view/view view} conversion, which is a process of\n * converting given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element} into another structure.\n * In default application, {@link module:engine/view/view view} is converted to {@link module:engine/model/model}.\n *\n * During conversion process, for all {@link module:engine/view/node~Node view nodes} from the converted view document fragment,\n * `UpcastDispatcher` fires corresponding events. Special callbacks called \"converters\" should listen to\n * `UpcastDispatcher` for those events.\n *\n * Each callback, as the second argument, is passed a special object `data` that has `viewItem`, `modelCursor` and\n * `modelRange` properties. `viewItem` property contains {@link module:engine/view/node~Node view node} or\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback. `modelRange` property should be used to save the result\n * of conversion and is always a {@link module:engine/model/range~Range} when conversion result is correct.\n * `modelCursor` property is a {@link module:engine/model/position~Position position} on which conversion result will be inserted\n * and is a context according to {@link module:engine/model/schema~Schema schema} will be checked before the conversion.\n * See also {@link ~UpcastDispatcher#convert}. It is also shared by reference by all callbacks listening to given event.\n *\n * The third parameter passed to a callback is an instance of {@link ~UpcastDispatcher}\n * which provides additional tools for converters.\n *\n * Examples of providing callbacks for `UpcastDispatcher`:\n *\n *\t\t// Converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why we need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p>'s font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it's executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Don't go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into paragraph (autoparagraphing).\n *  \teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *  \t \t// When element is already consumed by higher priority converters then do nothing.\n *  \t \tif ( conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *  \t \t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *  \t \t\t\t// Find allowed parent for paragraph that we are going to insert. If current parent does not allow\n *  \t \t\t\t// to insert paragraph but one of the ancestors does then split nodes to allowed parent.\n *  \t \t\t\tconst splitResult = conversionApi.splitToAllowedParent( paragraph, data.modelCursor );\n *\n *  \t \t\t\t// When there is no split result it means that we can't insert paragraph in this position.\n *  \t \t\t\tif ( splitResult ) {\n *  \t \t\t\t\t// Insert paragraph in allowed position.\n *  \t \t\t\t\tconversionApi.writer.insert( paragraph, splitResult.position );\n *\n *  \t \t\t\t\t// Convert children to paragraph.\n *  \t \t\t\t\tconst { modelRange } = conversionApi.convertChildren(\n *  \t \t\t\t\t\tdata.viewItem,\n *  \t \t\t\t\t\tconversionApi.writer.createPositionAt( paragraph, 0 )\n *  \t \t\t\t\t);\n *\n * \t\t\t\t\t\t// Set as conversion result, attribute converters may use this property.\n *  \t \t\t\t\tdata.modelRange = conversionApi.writer.createRange(\n *  \t \t\t\t\t\tconversionApi.writer.createPositionBefore( paragraph ),\n *  \t \t\t\t\t\tmodelRange.end\n *  \t \t\t\t\t);\n *\n *  \t \t\t\t\t// Continue conversion inside paragraph.\n *  \t \t\t\t\tdata.modelCursor = data.modelRange.end;\n *  \t \t\t\t}\n *  \t \t\t}\n *  \t \t}\n *  \t }, { priority: 'low' } );\n *\n * Before each conversion process, `UpcastDispatcher` fires {@link ~UpcastDispatcher#event:viewCleanup}\n * event which can be used to prepare tree view for conversion.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\n\nexport default class UpcastDispatcher {\n  /**\n   * Creates a `UpcastDispatcher` that operates using passed API.\n   *\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n   * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired\n   * by `UpcastDispatcher`.\n   */\n  constructor(conversionApi = {}) {\n    /**\n     * List of the elements that were created during splitting.\n     *\n     * After conversion process the list is cleared.\n     *\n     * @private\n     * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n     */\n    this._splitParts = new Map();\n    /**\n     * Position in the temporary structure where the converted content is inserted. The structure reflect the context of\n     * the target position where the content will be inserted. This property is build based on the context parameter of the\n     * convert method.\n     *\n     * @private\n     * @type {module:engine/model/position~Position|null}\n     */\n\n    this._modelCursor = null;\n    /**\n     * Interface passed by dispatcher to the events callbacks.\n     *\n     * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n     */\n\n    this.conversionApi = Object.assign({}, conversionApi); // `convertItem`, `convertChildren` and `splitToAllowedParent` are bound to this `UpcastDispatcher`\n    // instance and set on `conversionApi`. This way only a part of `UpcastDispatcher` API is exposed.\n\n    this.conversionApi.convertItem = this._convertItem.bind(this);\n    this.conversionApi.convertChildren = this._convertChildren.bind(this);\n    this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this);\n    this.conversionApi.getSplitParts = this._getSplitParts.bind(this);\n  }\n  /**\n   * Starts the conversion process. The entry point for the conversion.\n   *\n   * @fires element\n   * @fires text\n   * @fires documentFragment\n   * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n   * Part of the view to be converted.\n   * @param {module:engine/model/writer~Writer} writer Instance of model writer.\n   * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n   * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is a result of the conversion process\n   * wrapped in `DocumentFragment`. Converted marker elements will be set as that document fragment's\n   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n   */\n\n\n  convert(viewItem, writer, context = ['$root']) {\n    this.fire('viewCleanup', viewItem); // Create context tree and set position in the top element.\n    // Items will be converted according to this position.\n\n    this._modelCursor = createContextTree(context, writer); // Store writer in conversion as a conversion API\n    // to be sure that conversion process will use the same batch.\n\n    this.conversionApi.writer = writer; // Create consumable values list for conversion process.\n\n    this.conversionApi.consumable = ViewConsumable.createFrom(viewItem); // Custom data stored by converter for conversion process.\n\n    this.conversionApi.store = {}; // Do the conversion.\n\n    const {\n      modelRange\n    } = this._convertItem(viewItem, this._modelCursor); // Conversion result is always a document fragment so let's create it.\n\n\n    const documentFragment = writer.createDocumentFragment(); // When there is a conversion result.\n\n    if (modelRange) {\n      // Remove all empty elements that were create while splitting.\n      this._removeEmptyElements(); // Move all items that were converted in context tree to the document fragment.\n\n\n      for (const item of Array.from(this._modelCursor.parent.getChildren())) {\n        writer.append(item, documentFragment);\n      } // Extract temporary markers elements from model and set as static markers collection.\n\n\n      documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);\n    } // Clear context position.\n\n\n    this._modelCursor = null; // Clear split elements lists.\n\n    this._splitParts.clear(); // Clear conversion API.\n\n\n    this.conversionApi.writer = null;\n    this.conversionApi.store = null; // Return fragment as conversion result.\n\n    return documentFragment;\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n   */\n\n\n  _convertItem(viewItem, modelCursor) {\n    const data = Object.assign({\n      viewItem,\n      modelCursor,\n      modelRange: null\n    });\n\n    if (viewItem.is('element')) {\n      this.fire('element:' + viewItem.name, data, this.conversionApi);\n    } else if (viewItem.is('text')) {\n      this.fire('text', data, this.conversionApi);\n    } else {\n      this.fire('documentFragment', data, this.conversionApi);\n    } // Handle incorrect conversion result.\n\n\n    if (data.modelRange && !(data.modelRange instanceof ModelRange)) {\n      /**\n       * Incorrect conversion result was dropped.\n       *\n       * {@link module:engine/model/range~Range Model range} should be a conversion result.\n       *\n       * @error view-conversion-dispatcher-incorrect-result\n       */\n      throw new CKEditorError('view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.', this);\n    }\n\n    return {\n      modelRange: data.modelRange,\n      modelCursor: data.modelCursor\n    };\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n   */\n\n\n  _convertChildren(viewItem, modelCursor) {\n    const modelRange = new ModelRange(modelCursor);\n    let nextModelCursor = modelCursor;\n\n    for (const viewChild of Array.from(viewItem.getChildren())) {\n      const result = this._convertItem(viewChild, nextModelCursor);\n\n      if (result.modelRange instanceof ModelRange) {\n        modelRange.end = result.modelRange.end;\n        nextModelCursor = result.modelCursor;\n      }\n    }\n\n    return {\n      modelRange,\n      modelCursor: nextModelCursor\n    };\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n   */\n\n\n  _splitToAllowedParent(node, modelCursor) {\n    // Try to find allowed parent.\n    const allowedParent = this.conversionApi.schema.findAllowedParent(modelCursor, node); // When there is no parent that allows to insert node then return `null`.\n\n    if (!allowedParent) {\n      return null;\n    } // When current position parent allows to insert node then return this position.\n\n\n    if (allowedParent === modelCursor.parent) {\n      return {\n        position: modelCursor\n      };\n    } // When allowed parent is in context tree.\n\n\n    if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {\n      return null;\n    } // Split element to allowed parent.\n\n\n    const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent); // Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n    //\n    // The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n    // that got split) to the beginning of the other part of that element:\n    //\n    // <limit><a><b><c>X[]Y</c></b><a></limit> ->\n    // <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n    //\n    // After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n    // Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n    // Also, since we split all those elements, each of them has to have the other part.\n    //\n    // With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n    // them with \"opening tags\" in the reverse order. For that we can use a stack.\n\n    const stack = [];\n\n    for (const treeWalkerValue of splitResult.range.getWalker()) {\n      if (treeWalkerValue.type == 'elementEnd') {\n        stack.push(treeWalkerValue.item);\n      } else {\n        // There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n        const originalPart = stack.pop();\n        const splitPart = treeWalkerValue.item;\n\n        this._registerSplitPair(originalPart, splitPart);\n      }\n    }\n\n    return {\n      position: splitResult.position,\n      cursorParent: splitResult.range.end.parent\n    };\n  }\n  /**\n   * Registers that `splitPart` element is a split part of the `originalPart` element.\n   *\n   * Data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} originalPart\n   * @param {module:engine/model/element~Element} splitPart\n   */\n\n\n  _registerSplitPair(originalPart, splitPart) {\n    if (!this._splitParts.has(originalPart)) {\n      this._splitParts.set(originalPart, [originalPart]);\n    }\n\n    const list = this._splitParts.get(originalPart);\n\n    this._splitParts.set(splitPart, list);\n\n    list.push(splitPart);\n  }\n  /**\n   * @private\n   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n   */\n\n\n  _getSplitParts(element) {\n    let parts;\n\n    if (!this._splitParts.has(element)) {\n      parts = [element];\n    } else {\n      parts = this._splitParts.get(element);\n    }\n\n    return parts;\n  }\n  /**\n   * Checks if there are any empty elements created while splitting and removes them.\n   *\n   * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n   * as some elements might have become empty after other empty elements were removed from them.\n   *\n   * @private\n   */\n\n\n  _removeEmptyElements() {\n    let anyRemoved = false;\n\n    for (const element of this._splitParts.keys()) {\n      if (element.isEmpty) {\n        this.conversionApi.writer.remove(element);\n\n        this._splitParts.delete(element);\n\n        anyRemoved = true;\n      }\n    }\n\n    if (anyRemoved) {\n      this._removeEmptyElements();\n    }\n  }\n  /**\n   * Fired before the first conversion event, at the beginning of upcast (view to model conversion) process.\n   *\n   * @event viewCleanup\n   * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n   * viewItem Part of the view to be converted.\n   */\n\n  /**\n   * Fired when {@link module:engine/view/element~Element} is converted.\n   *\n   * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:\n   * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to\n   * all elements conversion or to conversion of specific elements.\n   *\n   * @event element\n   * @param {Object} data Conversion data. Keep in mind that this object is shared by reference between all\n   * callbacks that will be called. This means that callbacks can override values if needed, and those values will\n   * be available in other callbacks.\n   * @param {module:engine/view/item~Item} data.viewItem Converted item.\n   * @param {module:engine/model/position~Position} data.modelCursor Position where a converter should start changes.\n   * Change this value for the next converter to tell where the conversion should continue.\n   * @param {module:engine/model/range~Range} data.modelRange The current state of conversion result. Every change to\n   * converted element should be reflected by setting or modifying this property.\n   * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by callback.\n   */\n\n  /**\n   * Fired when {@link module:engine/view/text~Text} is converted.\n   *\n   * @event text\n   * @see #event:element\n   */\n\n  /**\n   * Fired when {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n   *\n   * @event documentFragment\n   * @see #event:element\n   */\n\n\n}\nmix(UpcastDispatcher, EmitterMixin); // Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\n\nfunction extractMarkersFromModelFragment(modelItem, writer) {\n  const markerElements = new Set();\n  const markers = new Map(); // Create ModelTreeWalker.\n\n  const range = ModelRange._createIn(modelItem).getItems(); // Walk through DocumentFragment and collect marker elements.\n\n\n  for (const item of range) {\n    // Check if current element is a marker.\n    if (item.name == '$marker') {\n      markerElements.add(item);\n    }\n  } // Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\n\n  for (const markerElement of markerElements) {\n    const markerName = markerElement.getAttribute('data-name');\n    const currentPosition = writer.createPositionBefore(markerElement); // When marker of given name is not stored it means that we have found the beginning of the range.\n\n    if (!markers.has(markerName)) {\n      markers.set(markerName, new ModelRange(currentPosition.clone())); // Otherwise is means that we have found end of the marker range.\n    } else {\n      markers.get(markerName).end = currentPosition.clone();\n    } // Remove marker element from DocumentFragment.\n\n\n    writer.remove(markerElement);\n  }\n\n  return markers;\n} // Creates model fragment according to given context and returns position in the bottom (the deepest) element.\n\n\nfunction createContextTree(contextDefinition, writer) {\n  let position;\n\n  for (const item of new SchemaContext(contextDefinition)) {\n    const attributes = {};\n\n    for (const key of item.getAttributeKeys()) {\n      attributes[key] = item.getAttribute(key);\n    }\n\n    const current = writer.createElement(item.name, attributes);\n\n    if (position) {\n      writer.append(current, position);\n    }\n\n    position = ModelPosition._createAt(current, 0);\n  }\n\n  return position;\n}\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi\n */\n\n/**\n * Starts conversion of given item by firing an appropriate event.\n *\n * Every fired event is passed (as first parameter) an object with `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of `modelRange` property is returned by this method.\n * The `modelRange` must be {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange Model range containing result of item conversion,\n * created and modified by callbacks attached to fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Starts conversion of all children of given item by firing appropriate events for all those children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Element which children should be converted.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange Model range containing results of conversion of all children of given item.\n * When no children was converted then range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Checks {@link module:engine/model/schema~Schema schema} to find allowed parent for element that we are going to insert\n * starting from given position. If current parent does not allow to insert element but one of the ancestors does then\n * split nodes to allowed parent.\n *\n * If schema allows to insert node in given position, nothing is split and object with that position is returned.\n *\n * If it was not possible to find allowed parent, `null` is returned, nothing is split.\n *\n * Otherwise, ancestors are split and object with position and the copy of the split element is returned.\n *\n * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *  \t-> split for `<image>` ->\n *\n *  \t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the sample above position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position Position on which element is going to be inserted.\n * @param {module:engine/model/node~Node} node Node to insert.\n * @returns {Object|null} Split result. If it was not possible to find allowed position `null` is returned.\n * @returns {module:engine/model/position~Position} position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] Element inside which cursor should be placed to\n * continue conversion. When element is not defined it means that there was no split.\n */\n\n/**\n * Returns all the split parts of given `element` that were created during upcasting through using {@link #splitToAllowedParent}.\n * It enables you to easily track those elements and continue processing them after they are split during their children conversion.\n *\n *\t\t<paragraph>Foo<image />bar<image />baz</paragraph> ->\n *\t\t<paragraph>Foo</paragraph><image /><paragraph>bar</paragraph><image /><paragraph>baz</paragraph>\n *\n * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),\n * sorted in the order of their creation (the original element is the first one).\n *\n * If given `element` was not split, an array with single element is returned.\n *\n * Example of a usage in a converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( myElement, modelCursor );\n *\n *\t\tconst splitParts = conversionApi.getSplitParts( myElement );\n *\t\tconst lastSplitPart = splitParts[ splitParts.length - 1 ];\n *\n *\t\t// Setting `data.modelRange` basing on split parts:\n *\t\tdata.modelRange = conversionApi.writer.createRange(\n *\t\t\tconversionApi.writer.createPositionBefore( myElement ),\n *\t\t\tconversionApi.writer.createPositionAfter( lastSplitPart )\n *\t\t);\n *\n *\t\t// Setting `data.modelCursor` to continue after the last split element:\n *\t\tdata.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );\n *\n * **Tip:** if you are unable to get a reference to the original element (for example because the code is split into multiple converters\n * or even classes) but it was already converted, you might want to check first element in `data.modelRange`. This is a common situation\n * if an attribute converter is separated from an element converter.\n *\n * @method #getSplitParts\n * @param {module:engine/model/element~Element} element\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\n/**\n * Stores information about what parts of processed view item are still waiting to be handled. After a piece of view item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable\n */\n\n/**\n * Custom data stored by converters for conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that `data` parameters allows you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @member {Object} #store\n */\n\n/**\n * The model's schema instance.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/model/writer~Writer} instance used to manipulate data during conversion.\n *\n * @member {module:engine/model/writer~Writer} #writer\n */","map":{"version":3,"sources":["D:/Tai_lieu_hoc_vu/blog_me/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js"],"names":["ViewConsumable","ModelRange","ModelPosition","SchemaContext","CKEditorError","EmitterMixin","mix","UpcastDispatcher","constructor","conversionApi","_splitParts","Map","_modelCursor","Object","assign","convertItem","_convertItem","bind","convertChildren","_convertChildren","splitToAllowedParent","_splitToAllowedParent","getSplitParts","_getSplitParts","convert","viewItem","writer","context","fire","createContextTree","consumable","createFrom","store","modelRange","documentFragment","createDocumentFragment","_removeEmptyElements","item","Array","from","parent","getChildren","append","markers","extractMarkersFromModelFragment","clear","modelCursor","data","is","name","nextModelCursor","viewChild","result","end","node","allowedParent","schema","findAllowedParent","position","getAncestors","includes","splitResult","split","stack","treeWalkerValue","range","getWalker","type","push","originalPart","pop","splitPart","_registerSplitPair","cursorParent","has","set","list","get","element","parts","anyRemoved","keys","isEmpty","remove","delete","modelItem","markerElements","Set","_createIn","getItems","add","markerElement","markerName","getAttribute","currentPosition","createPositionBefore","clone","contextDefinition","attributes","key","getAttributeKeys","current","createElement","_createAt"],"mappings":"AAAA;;;;;AAKA;;;AAIA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,OAAOC,UAAP,MAAuB,gBAAvB;AACA,OAAOC,aAAP,MAA0B,mBAA1B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AAEA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuGA,eAAe,MAAMC,gBAAN,CAAuB;AACrC;;;;;;;AAOAC,EAAAA,WAAW,CAAEC,aAAa,GAAG,EAAlB,EAAuB;AACjC;;;;;;;;AAQA,SAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;AAEA;;;;;;;;;AAQA,SAAKC,YAAL,GAAoB,IAApB;AAEA;;;;;;AAKA,SAAKH,aAAL,GAAqBI,MAAM,CAACC,MAAP,CAAe,EAAf,EAAmBL,aAAnB,CAArB,CA1BiC,CA4BjC;AACA;;AACA,SAAKA,aAAL,CAAmBM,WAAnB,GAAiC,KAAKC,YAAL,CAAkBC,IAAlB,CAAwB,IAAxB,CAAjC;AACA,SAAKR,aAAL,CAAmBS,eAAnB,GAAqC,KAAKC,gBAAL,CAAsBF,IAAtB,CAA4B,IAA5B,CAArC;AACA,SAAKR,aAAL,CAAmBW,oBAAnB,GAA0C,KAAKC,qBAAL,CAA2BJ,IAA3B,CAAiC,IAAjC,CAA1C;AACA,SAAKR,aAAL,CAAmBa,aAAnB,GAAmC,KAAKC,cAAL,CAAoBN,IAApB,CAA0B,IAA1B,CAAnC;AACA;AAED;;;;;;;;;;;;;;;;AAcAO,EAAAA,OAAO,CAAEC,QAAF,EAAYC,MAAZ,EAAoBC,OAAO,GAAG,CAAE,OAAF,CAA9B,EAA4C;AAClD,SAAKC,IAAL,CAAW,aAAX,EAA0BH,QAA1B,EADkD,CAGlD;AACA;;AACA,SAAKb,YAAL,GAAoBiB,iBAAiB,CAAEF,OAAF,EAAWD,MAAX,CAArC,CALkD,CAOlD;AACA;;AACA,SAAKjB,aAAL,CAAmBiB,MAAnB,GAA4BA,MAA5B,CATkD,CAWlD;;AACA,SAAKjB,aAAL,CAAmBqB,UAAnB,GAAgC9B,cAAc,CAAC+B,UAAf,CAA2BN,QAA3B,CAAhC,CAZkD,CAclD;;AACA,SAAKhB,aAAL,CAAmBuB,KAAnB,GAA2B,EAA3B,CAfkD,CAiBlD;;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAiB,KAAKjB,YAAL,CAAmBS,QAAnB,EAA6B,KAAKb,YAAlC,CAAvB,CAlBkD,CAoBlD;;;AACA,UAAMsB,gBAAgB,GAAGR,MAAM,CAACS,sBAAP,EAAzB,CArBkD,CAuBlD;;AACA,QAAKF,UAAL,EAAkB;AACjB;AACA,WAAKG,oBAAL,GAFiB,CAIjB;;;AACA,WAAM,MAAMC,IAAZ,IAAoBC,KAAK,CAACC,IAAN,CAAY,KAAK3B,YAAL,CAAkB4B,MAAlB,CAAyBC,WAAzB,EAAZ,CAApB,EAA2E;AAC1Ef,QAAAA,MAAM,CAACgB,MAAP,CAAeL,IAAf,EAAqBH,gBAArB;AACA,OAPgB,CASjB;;;AACAA,MAAAA,gBAAgB,CAACS,OAAjB,GAA2BC,+BAA+B,CAAEV,gBAAF,EAAoBR,MAApB,CAA1D;AACA,KAnCiD,CAqClD;;;AACA,SAAKd,YAAL,GAAoB,IAApB,CAtCkD,CAwClD;;AACA,SAAKF,WAAL,CAAiBmC,KAAjB,GAzCkD,CA2ClD;;;AACA,SAAKpC,aAAL,CAAmBiB,MAAnB,GAA4B,IAA5B;AACA,SAAKjB,aAAL,CAAmBuB,KAAnB,GAA2B,IAA3B,CA7CkD,CA+ClD;;AACA,WAAOE,gBAAP;AACA;AAED;;;;;;AAIAlB,EAAAA,YAAY,CAAES,QAAF,EAAYqB,WAAZ,EAA0B;AACrC,UAAMC,IAAI,GAAGlC,MAAM,CAACC,MAAP,CAAe;AAAEW,MAAAA,QAAF;AAAYqB,MAAAA,WAAZ;AAAyBb,MAAAA,UAAU,EAAE;AAArC,KAAf,CAAb;;AAEA,QAAKR,QAAQ,CAACuB,EAAT,CAAa,SAAb,CAAL,EAAgC;AAC/B,WAAKpB,IAAL,CAAW,aAAaH,QAAQ,CAACwB,IAAjC,EAAuCF,IAAvC,EAA6C,KAAKtC,aAAlD;AACA,KAFD,MAEO,IAAKgB,QAAQ,CAACuB,EAAT,CAAa,MAAb,CAAL,EAA6B;AACnC,WAAKpB,IAAL,CAAW,MAAX,EAAmBmB,IAAnB,EAAyB,KAAKtC,aAA9B;AACA,KAFM,MAEA;AACN,WAAKmB,IAAL,CAAW,kBAAX,EAA+BmB,IAA/B,EAAqC,KAAKtC,aAA1C;AACA,KAToC,CAWrC;;;AACA,QAAKsC,IAAI,CAACd,UAAL,IAAmB,EAAGc,IAAI,CAACd,UAAL,YAA2BhC,UAA9B,CAAxB,EAAqE;AACpE;;;;;;;AAOA,YAAM,IAAIG,aAAJ,CAAmB,uFAAnB,EAA4G,IAA5G,CAAN;AACA;;AAED,WAAO;AAAE6B,MAAAA,UAAU,EAAEc,IAAI,CAACd,UAAnB;AAA+Ba,MAAAA,WAAW,EAAEC,IAAI,CAACD;AAAjD,KAAP;AACA;AAED;;;;;;AAIA3B,EAAAA,gBAAgB,CAAEM,QAAF,EAAYqB,WAAZ,EAA0B;AACzC,UAAMb,UAAU,GAAG,IAAIhC,UAAJ,CAAgB6C,WAAhB,CAAnB;AACA,QAAII,eAAe,GAAGJ,WAAtB;;AAEA,SAAM,MAAMK,SAAZ,IAAyBb,KAAK,CAACC,IAAN,CAAYd,QAAQ,CAACgB,WAAT,EAAZ,CAAzB,EAAgE;AAC/D,YAAMW,MAAM,GAAG,KAAKpC,YAAL,CAAmBmC,SAAnB,EAA8BD,eAA9B,CAAf;;AAEA,UAAKE,MAAM,CAACnB,UAAP,YAA6BhC,UAAlC,EAA+C;AAC9CgC,QAAAA,UAAU,CAACoB,GAAX,GAAiBD,MAAM,CAACnB,UAAP,CAAkBoB,GAAnC;AACAH,QAAAA,eAAe,GAAGE,MAAM,CAACN,WAAzB;AACA;AACD;;AAED,WAAO;AAAEb,MAAAA,UAAF;AAAca,MAAAA,WAAW,EAAEI;AAA3B,KAAP;AACA;AAED;;;;;;AAIA7B,EAAAA,qBAAqB,CAAEiC,IAAF,EAAQR,WAAR,EAAsB;AAC1C;AACA,UAAMS,aAAa,GAAG,KAAK9C,aAAL,CAAmB+C,MAAnB,CAA0BC,iBAA1B,CAA6CX,WAA7C,EAA0DQ,IAA1D,CAAtB,CAF0C,CAI1C;;AACA,QAAK,CAACC,aAAN,EAAsB;AACrB,aAAO,IAAP;AACA,KAPyC,CAS1C;;;AACA,QAAKA,aAAa,KAAKT,WAAW,CAACN,MAAnC,EAA4C;AAC3C,aAAO;AAAEkB,QAAAA,QAAQ,EAAEZ;AAAZ,OAAP;AACA,KAZyC,CAc1C;;;AACA,QAAK,KAAKlC,YAAL,CAAkB4B,MAAlB,CAAyBmB,YAAzB,GAAwCC,QAAxC,CAAkDL,aAAlD,CAAL,EAAyE;AACxE,aAAO,IAAP;AACA,KAjByC,CAmB1C;;;AACA,UAAMM,WAAW,GAAG,KAAKpD,aAAL,CAAmBiB,MAAnB,CAA0BoC,KAA1B,CAAiChB,WAAjC,EAA8CS,aAA9C,CAApB,CApB0C,CAsB1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMQ,KAAK,GAAG,EAAd;;AAEA,SAAM,MAAMC,eAAZ,IAA+BH,WAAW,CAACI,KAAZ,CAAkBC,SAAlB,EAA/B,EAA+D;AAC9D,UAAKF,eAAe,CAACG,IAAhB,IAAwB,YAA7B,EAA4C;AAC3CJ,QAAAA,KAAK,CAACK,IAAN,CAAYJ,eAAe,CAAC3B,IAA5B;AACA,OAFD,MAEO;AACN;AACA,cAAMgC,YAAY,GAAGN,KAAK,CAACO,GAAN,EAArB;AACA,cAAMC,SAAS,GAAGP,eAAe,CAAC3B,IAAlC;;AAEA,aAAKmC,kBAAL,CAAyBH,YAAzB,EAAuCE,SAAvC;AACA;AACD;;AAED,WAAO;AACNb,MAAAA,QAAQ,EAAEG,WAAW,CAACH,QADhB;AAENe,MAAAA,YAAY,EAAEZ,WAAW,CAACI,KAAZ,CAAkBZ,GAAlB,CAAsBb;AAF9B,KAAP;AAIA;AAED;;;;;;;;;;;AASAgC,EAAAA,kBAAkB,CAAEH,YAAF,EAAgBE,SAAhB,EAA4B;AAC7C,QAAK,CAAC,KAAK7D,WAAL,CAAiBgE,GAAjB,CAAsBL,YAAtB,CAAN,EAA6C;AAC5C,WAAK3D,WAAL,CAAiBiE,GAAjB,CAAsBN,YAAtB,EAAoC,CAAEA,YAAF,CAApC;AACA;;AAED,UAAMO,IAAI,GAAG,KAAKlE,WAAL,CAAiBmE,GAAjB,CAAsBR,YAAtB,CAAb;;AAEA,SAAK3D,WAAL,CAAiBiE,GAAjB,CAAsBJ,SAAtB,EAAiCK,IAAjC;;AACAA,IAAAA,IAAI,CAACR,IAAL,CAAWG,SAAX;AACA;AAED;;;;;;AAIAhD,EAAAA,cAAc,CAAEuD,OAAF,EAAY;AACzB,QAAIC,KAAJ;;AAEA,QAAK,CAAC,KAAKrE,WAAL,CAAiBgE,GAAjB,CAAsBI,OAAtB,CAAN,EAAwC;AACvCC,MAAAA,KAAK,GAAG,CAAED,OAAF,CAAR;AACA,KAFD,MAEO;AACNC,MAAAA,KAAK,GAAG,KAAKrE,WAAL,CAAiBmE,GAAjB,CAAsBC,OAAtB,CAAR;AACA;;AAED,WAAOC,KAAP;AACA;AAED;;;;;;;;;;AAQA3C,EAAAA,oBAAoB,GAAG;AACtB,QAAI4C,UAAU,GAAG,KAAjB;;AAEA,SAAM,MAAMF,OAAZ,IAAuB,KAAKpE,WAAL,CAAiBuE,IAAjB,EAAvB,EAAiD;AAChD,UAAKH,OAAO,CAACI,OAAb,EAAuB;AACtB,aAAKzE,aAAL,CAAmBiB,MAAnB,CAA0ByD,MAA1B,CAAkCL,OAAlC;;AACA,aAAKpE,WAAL,CAAiB0E,MAAjB,CAAyBN,OAAzB;;AAEAE,QAAAA,UAAU,GAAG,IAAb;AACA;AACD;;AAED,QAAKA,UAAL,EAAkB;AACjB,WAAK5C,oBAAL;AACA;AACD;AAED;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;AAOA;;;;;;;;AA1TqC;AAkUtC9B,GAAG,CAAEC,gBAAF,EAAoBF,YAApB,CAAH,C,CAEA;AACA;AACA;AACA;AACA;;AACA,SAASuC,+BAAT,CAA0CyC,SAA1C,EAAqD3D,MAArD,EAA8D;AAC7D,QAAM4D,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AACA,QAAM5C,OAAO,GAAG,IAAIhC,GAAJ,EAAhB,CAF6D,CAI7D;;AACA,QAAMsD,KAAK,GAAGhE,UAAU,CAACuF,SAAX,CAAsBH,SAAtB,EAAkCI,QAAlC,EAAd,CAL6D,CAO7D;;;AACA,OAAM,MAAMpD,IAAZ,IAAoB4B,KAApB,EAA4B;AAC3B;AACA,QAAK5B,IAAI,CAACY,IAAL,IAAa,SAAlB,EAA8B;AAC7BqC,MAAAA,cAAc,CAACI,GAAf,CAAoBrD,IAApB;AACA;AACD,GAb4D,CAe7D;;;AACA,OAAM,MAAMsD,aAAZ,IAA6BL,cAA7B,EAA8C;AAC7C,UAAMM,UAAU,GAAGD,aAAa,CAACE,YAAd,CAA4B,WAA5B,CAAnB;AACA,UAAMC,eAAe,GAAGpE,MAAM,CAACqE,oBAAP,CAA6BJ,aAA7B,CAAxB,CAF6C,CAI7C;;AACA,QAAK,CAAChD,OAAO,CAAC+B,GAAR,CAAakB,UAAb,CAAN,EAAkC;AACjCjD,MAAAA,OAAO,CAACgC,GAAR,CAAaiB,UAAb,EAAyB,IAAI3F,UAAJ,CAAgB6F,eAAe,CAACE,KAAhB,EAAhB,CAAzB,EADiC,CAElC;AACC,KAHD,MAGO;AACNrD,MAAAA,OAAO,CAACkC,GAAR,CAAae,UAAb,EAA0BvC,GAA1B,GAAgCyC,eAAe,CAACE,KAAhB,EAAhC;AACA,KAV4C,CAY7C;;;AACAtE,IAAAA,MAAM,CAACyD,MAAP,CAAeQ,aAAf;AACA;;AAED,SAAOhD,OAAP;AACA,C,CAED;;;AACA,SAASd,iBAAT,CAA4BoE,iBAA5B,EAA+CvE,MAA/C,EAAwD;AACvD,MAAIgC,QAAJ;;AAEA,OAAM,MAAMrB,IAAZ,IAAoB,IAAIlC,aAAJ,CAAmB8F,iBAAnB,CAApB,EAA6D;AAC5D,UAAMC,UAAU,GAAG,EAAnB;;AAEA,SAAM,MAAMC,GAAZ,IAAmB9D,IAAI,CAAC+D,gBAAL,EAAnB,EAA6C;AAC5CF,MAAAA,UAAU,CAAEC,GAAF,CAAV,GAAoB9D,IAAI,CAACwD,YAAL,CAAmBM,GAAnB,CAApB;AACA;;AAED,UAAME,OAAO,GAAG3E,MAAM,CAAC4E,aAAP,CAAsBjE,IAAI,CAACY,IAA3B,EAAiCiD,UAAjC,CAAhB;;AAEA,QAAKxC,QAAL,EAAgB;AACfhC,MAAAA,MAAM,CAACgB,MAAP,CAAe2D,OAAf,EAAwB3C,QAAxB;AACA;;AAEDA,IAAAA,QAAQ,GAAGxD,aAAa,CAACqG,SAAd,CAAyBF,OAAzB,EAAkC,CAAlC,CAAX;AACA;;AAED,SAAO3C,QAAP;AACA;AAED;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA;;;;;;;AAOA;;;;;;;;;;;AAWA;;;;;;AAMA","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\n\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * `UpcastDispatcher` is a central point of {@link module:engine/view/view view} conversion, which is a process of\n * converting given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element} into another structure.\n * In default application, {@link module:engine/view/view view} is converted to {@link module:engine/model/model}.\n *\n * During conversion process, for all {@link module:engine/view/node~Node view nodes} from the converted view document fragment,\n * `UpcastDispatcher` fires corresponding events. Special callbacks called \"converters\" should listen to\n * `UpcastDispatcher` for those events.\n *\n * Each callback, as the second argument, is passed a special object `data` that has `viewItem`, `modelCursor` and\n * `modelRange` properties. `viewItem` property contains {@link module:engine/view/node~Node view node} or\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback. `modelRange` property should be used to save the result\n * of conversion and is always a {@link module:engine/model/range~Range} when conversion result is correct.\n * `modelCursor` property is a {@link module:engine/model/position~Position position} on which conversion result will be inserted\n * and is a context according to {@link module:engine/model/schema~Schema schema} will be checked before the conversion.\n * See also {@link ~UpcastDispatcher#convert}. It is also shared by reference by all callbacks listening to given event.\n *\n * The third parameter passed to a callback is an instance of {@link ~UpcastDispatcher}\n * which provides additional tools for converters.\n *\n * Examples of providing callbacks for `UpcastDispatcher`:\n *\n *\t\t// Converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why we need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p>'s font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it's executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Don't go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into paragraph (autoparagraphing).\n *  \teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *  \t \t// When element is already consumed by higher priority converters then do nothing.\n *  \t \tif ( conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *  \t \t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *  \t \t\t\t// Find allowed parent for paragraph that we are going to insert. If current parent does not allow\n *  \t \t\t\t// to insert paragraph but one of the ancestors does then split nodes to allowed parent.\n *  \t \t\t\tconst splitResult = conversionApi.splitToAllowedParent( paragraph, data.modelCursor );\n *\n *  \t \t\t\t// When there is no split result it means that we can't insert paragraph in this position.\n *  \t \t\t\tif ( splitResult ) {\n *  \t \t\t\t\t// Insert paragraph in allowed position.\n *  \t \t\t\t\tconversionApi.writer.insert( paragraph, splitResult.position );\n *\n *  \t \t\t\t\t// Convert children to paragraph.\n *  \t \t\t\t\tconst { modelRange } = conversionApi.convertChildren(\n *  \t \t\t\t\t\tdata.viewItem,\n *  \t \t\t\t\t\tconversionApi.writer.createPositionAt( paragraph, 0 )\n *  \t \t\t\t\t);\n *\n * \t\t\t\t\t\t// Set as conversion result, attribute converters may use this property.\n *  \t \t\t\t\tdata.modelRange = conversionApi.writer.createRange(\n *  \t \t\t\t\t\tconversionApi.writer.createPositionBefore( paragraph ),\n *  \t \t\t\t\t\tmodelRange.end\n *  \t \t\t\t\t);\n *\n *  \t \t\t\t\t// Continue conversion inside paragraph.\n *  \t \t\t\t\tdata.modelCursor = data.modelRange.end;\n *  \t \t\t\t}\n *  \t \t\t}\n *  \t \t}\n *  \t }, { priority: 'low' } );\n *\n * Before each conversion process, `UpcastDispatcher` fires {@link ~UpcastDispatcher#event:viewCleanup}\n * event which can be used to prepare tree view for conversion.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\nexport default class UpcastDispatcher {\n\t/**\n\t * Creates a `UpcastDispatcher` that operates using passed API.\n\t *\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n\t * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired\n\t * by `UpcastDispatcher`.\n\t */\n\tconstructor( conversionApi = {} ) {\n\t\t/**\n\t\t * List of the elements that were created during splitting.\n\t\t *\n\t\t * After conversion process the list is cleared.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n\t\t */\n\t\tthis._splitParts = new Map();\n\n\t\t/**\n\t\t * Position in the temporary structure where the converted content is inserted. The structure reflect the context of\n\t\t * the target position where the content will be inserted. This property is build based on the context parameter of the\n\t\t * convert method.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/position~Position|null}\n\t\t */\n\t\tthis._modelCursor = null;\n\n\t\t/**\n\t\t * Interface passed by dispatcher to the events callbacks.\n\t\t *\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n\t\t */\n\t\tthis.conversionApi = Object.assign( {}, conversionApi );\n\n\t\t// `convertItem`, `convertChildren` and `splitToAllowedParent` are bound to this `UpcastDispatcher`\n\t\t// instance and set on `conversionApi`. This way only a part of `UpcastDispatcher` API is exposed.\n\t\tthis.conversionApi.convertItem = this._convertItem.bind( this );\n\t\tthis.conversionApi.convertChildren = this._convertChildren.bind( this );\n\t\tthis.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind( this );\n\t\tthis.conversionApi.getSplitParts = this._getSplitParts.bind( this );\n\t}\n\n\t/**\n\t * Starts the conversion process. The entry point for the conversion.\n\t *\n\t * @fires element\n\t * @fires text\n\t * @fires documentFragment\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n\t * Part of the view to be converted.\n\t * @param {module:engine/model/writer~Writer} writer Instance of model writer.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is a result of the conversion process\n\t * wrapped in `DocumentFragment`. Converted marker elements will be set as that document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t */\n\tconvert( viewItem, writer, context = [ '$root' ] ) {\n\t\tthis.fire( 'viewCleanup', viewItem );\n\n\t\t// Create context tree and set position in the top element.\n\t\t// Items will be converted according to this position.\n\t\tthis._modelCursor = createContextTree( context, writer );\n\n\t\t// Store writer in conversion as a conversion API\n\t\t// to be sure that conversion process will use the same batch.\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create consumable values list for conversion process.\n\t\tthis.conversionApi.consumable = ViewConsumable.createFrom( viewItem );\n\n\t\t// Custom data stored by converter for conversion process.\n\t\tthis.conversionApi.store = {};\n\n\t\t// Do the conversion.\n\t\tconst { modelRange } = this._convertItem( viewItem, this._modelCursor );\n\n\t\t// Conversion result is always a document fragment so let's create it.\n\t\tconst documentFragment = writer.createDocumentFragment();\n\n\t\t// When there is a conversion result.\n\t\tif ( modelRange ) {\n\t\t\t// Remove all empty elements that were create while splitting.\n\t\t\tthis._removeEmptyElements();\n\n\t\t\t// Move all items that were converted in context tree to the document fragment.\n\t\t\tfor ( const item of Array.from( this._modelCursor.parent.getChildren() ) ) {\n\t\t\t\twriter.append( item, documentFragment );\n\t\t\t}\n\n\t\t\t// Extract temporary markers elements from model and set as static markers collection.\n\t\t\tdocumentFragment.markers = extractMarkersFromModelFragment( documentFragment, writer );\n\t\t}\n\n\t\t// Clear context position.\n\t\tthis._modelCursor = null;\n\n\t\t// Clear split elements lists.\n\t\tthis._splitParts.clear();\n\n\t\t// Clear conversion API.\n\t\tthis.conversionApi.writer = null;\n\t\tthis.conversionApi.store = null;\n\n\t\t// Return fragment as conversion result.\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n\t */\n\t_convertItem( viewItem, modelCursor ) {\n\t\tconst data = Object.assign( { viewItem, modelCursor, modelRange: null } );\n\n\t\tif ( viewItem.is( 'element' ) ) {\n\t\t\tthis.fire( 'element:' + viewItem.name, data, this.conversionApi );\n\t\t} else if ( viewItem.is( 'text' ) ) {\n\t\t\tthis.fire( 'text', data, this.conversionApi );\n\t\t} else {\n\t\t\tthis.fire( 'documentFragment', data, this.conversionApi );\n\t\t}\n\n\t\t// Handle incorrect conversion result.\n\t\tif ( data.modelRange && !( data.modelRange instanceof ModelRange ) ) {\n\t\t\t/**\n\t\t\t * Incorrect conversion result was dropped.\n\t\t\t *\n\t\t\t * {@link module:engine/model/range~Range Model range} should be a conversion result.\n\t\t\t *\n\t\t\t * @error view-conversion-dispatcher-incorrect-result\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.', this );\n\t\t}\n\n\t\treturn { modelRange: data.modelRange, modelCursor: data.modelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n\t */\n\t_convertChildren( viewItem, modelCursor ) {\n\t\tconst modelRange = new ModelRange( modelCursor );\n\t\tlet nextModelCursor = modelCursor;\n\n\t\tfor ( const viewChild of Array.from( viewItem.getChildren() ) ) {\n\t\t\tconst result = this._convertItem( viewChild, nextModelCursor );\n\n\t\t\tif ( result.modelRange instanceof ModelRange ) {\n\t\t\t\tmodelRange.end = result.modelRange.end;\n\t\t\t\tnextModelCursor = result.modelCursor;\n\t\t\t}\n\t\t}\n\n\t\treturn { modelRange, modelCursor: nextModelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n\t */\n\t_splitToAllowedParent( node, modelCursor ) {\n\t\t// Try to find allowed parent.\n\t\tconst allowedParent = this.conversionApi.schema.findAllowedParent( modelCursor, node );\n\n\t\t// When there is no parent that allows to insert node then return `null`.\n\t\tif ( !allowedParent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When current position parent allows to insert node then return this position.\n\t\tif ( allowedParent === modelCursor.parent ) {\n\t\t\treturn { position: modelCursor };\n\t\t}\n\n\t\t// When allowed parent is in context tree.\n\t\tif ( this._modelCursor.parent.getAncestors().includes( allowedParent ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Split element to allowed parent.\n\t\tconst splitResult = this.conversionApi.writer.split( modelCursor, allowedParent );\n\n\t\t// Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n\t\t//\n\t\t// The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n\t\t// that got split) to the beginning of the other part of that element:\n\t\t//\n\t\t// <limit><a><b><c>X[]Y</c></b><a></limit> ->\n\t\t// <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n\t\t//\n\t\t// After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n\t\t// Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n\t\t// Also, since we split all those elements, each of them has to have the other part.\n\t\t//\n\t\t// With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n\t\t// them with \"opening tags\" in the reverse order. For that we can use a stack.\n\t\tconst stack = [];\n\n\t\tfor ( const treeWalkerValue of splitResult.range.getWalker() ) {\n\t\t\tif ( treeWalkerValue.type == 'elementEnd' ) {\n\t\t\t\tstack.push( treeWalkerValue.item );\n\t\t\t} else {\n\t\t\t\t// There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n\t\t\t\tconst originalPart = stack.pop();\n\t\t\t\tconst splitPart = treeWalkerValue.item;\n\n\t\t\t\tthis._registerSplitPair( originalPart, splitPart );\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tposition: splitResult.position,\n\t\t\tcursorParent: splitResult.range.end.parent\n\t\t};\n\t}\n\n\t/**\n\t * Registers that `splitPart` element is a split part of the `originalPart` element.\n\t *\n\t * Data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} originalPart\n\t * @param {module:engine/model/element~Element} splitPart\n\t */\n\t_registerSplitPair( originalPart, splitPart ) {\n\t\tif ( !this._splitParts.has( originalPart ) ) {\n\t\t\tthis._splitParts.set( originalPart, [ originalPart ] );\n\t\t}\n\n\t\tconst list = this._splitParts.get( originalPart );\n\n\t\tthis._splitParts.set( splitPart, list );\n\t\tlist.push( splitPart );\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n\t */\n\t_getSplitParts( element ) {\n\t\tlet parts;\n\n\t\tif ( !this._splitParts.has( element ) ) {\n\t\t\tparts = [ element ];\n\t\t} else {\n\t\t\tparts = this._splitParts.get( element );\n\t\t}\n\n\t\treturn parts;\n\t}\n\n\t/**\n\t * Checks if there are any empty elements created while splitting and removes them.\n\t *\n\t * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n\t * as some elements might have become empty after other empty elements were removed from them.\n\t *\n\t * @private\n\t */\n\t_removeEmptyElements() {\n\t\tlet anyRemoved = false;\n\n\t\tfor ( const element of this._splitParts.keys() ) {\n\t\t\tif ( element.isEmpty ) {\n\t\t\t\tthis.conversionApi.writer.remove( element );\n\t\t\t\tthis._splitParts.delete( element );\n\n\t\t\t\tanyRemoved = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( anyRemoved ) {\n\t\t\tthis._removeEmptyElements();\n\t\t}\n\t}\n\n\t/**\n\t * Fired before the first conversion event, at the beginning of upcast (view to model conversion) process.\n\t *\n\t * @event viewCleanup\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n\t * viewItem Part of the view to be converted.\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/element~Element} is converted.\n\t *\n\t * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:\n\t * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to\n\t * all elements conversion or to conversion of specific elements.\n\t *\n\t * @event element\n\t * @param {Object} data Conversion data. Keep in mind that this object is shared by reference between all\n\t * callbacks that will be called. This means that callbacks can override values if needed, and those values will\n\t * be available in other callbacks.\n\t * @param {module:engine/view/item~Item} data.viewItem Converted item.\n\t * @param {module:engine/model/position~Position} data.modelCursor Position where a converter should start changes.\n\t * Change this value for the next converter to tell where the conversion should continue.\n\t * @param {module:engine/model/range~Range} data.modelRange The current state of conversion result. Every change to\n\t * converted element should be reflected by setting or modifying this property.\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by callback.\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/text~Text} is converted.\n\t *\n\t * @event text\n\t * @see #event:element\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n\t *\n\t * @event documentFragment\n\t * @see #event:element\n\t */\n}\n\nmix( UpcastDispatcher, EmitterMixin );\n\n// Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\nfunction extractMarkersFromModelFragment( modelItem, writer ) {\n\tconst markerElements = new Set();\n\tconst markers = new Map();\n\n\t// Create ModelTreeWalker.\n\tconst range = ModelRange._createIn( modelItem ).getItems();\n\n\t// Walk through DocumentFragment and collect marker elements.\n\tfor ( const item of range ) {\n\t\t// Check if current element is a marker.\n\t\tif ( item.name == '$marker' ) {\n\t\t\tmarkerElements.add( item );\n\t\t}\n\t}\n\n\t// Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\tfor ( const markerElement of markerElements ) {\n\t\tconst markerName = markerElement.getAttribute( 'data-name' );\n\t\tconst currentPosition = writer.createPositionBefore( markerElement );\n\n\t\t// When marker of given name is not stored it means that we have found the beginning of the range.\n\t\tif ( !markers.has( markerName ) ) {\n\t\t\tmarkers.set( markerName, new ModelRange( currentPosition.clone() ) );\n\t\t// Otherwise is means that we have found end of the marker range.\n\t\t} else {\n\t\t\tmarkers.get( markerName ).end = currentPosition.clone();\n\t\t}\n\n\t\t// Remove marker element from DocumentFragment.\n\t\twriter.remove( markerElement );\n\t}\n\n\treturn markers;\n}\n\n// Creates model fragment according to given context and returns position in the bottom (the deepest) element.\nfunction createContextTree( contextDefinition, writer ) {\n\tlet position;\n\n\tfor ( const item of new SchemaContext( contextDefinition ) ) {\n\t\tconst attributes = {};\n\n\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\tattributes[ key ] = item.getAttribute( key );\n\t\t}\n\n\t\tconst current = writer.createElement( item.name, attributes );\n\n\t\tif ( position ) {\n\t\t\twriter.append( current, position );\n\t\t}\n\n\t\tposition = ModelPosition._createAt( current, 0 );\n\t}\n\n\treturn position;\n}\n\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi\n */\n\n/**\n * Starts conversion of given item by firing an appropriate event.\n *\n * Every fired event is passed (as first parameter) an object with `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of `modelRange` property is returned by this method.\n * The `modelRange` must be {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange Model range containing result of item conversion,\n * created and modified by callbacks attached to fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Starts conversion of all children of given item by firing appropriate events for all those children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Element which children should be converted.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange Model range containing results of conversion of all children of given item.\n * When no children was converted then range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Checks {@link module:engine/model/schema~Schema schema} to find allowed parent for element that we are going to insert\n * starting from given position. If current parent does not allow to insert element but one of the ancestors does then\n * split nodes to allowed parent.\n *\n * If schema allows to insert node in given position, nothing is split and object with that position is returned.\n *\n * If it was not possible to find allowed parent, `null` is returned, nothing is split.\n *\n * Otherwise, ancestors are split and object with position and the copy of the split element is returned.\n *\n * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *  \t-> split for `<image>` ->\n *\n *  \t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the sample above position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position Position on which element is going to be inserted.\n * @param {module:engine/model/node~Node} node Node to insert.\n * @returns {Object|null} Split result. If it was not possible to find allowed position `null` is returned.\n * @returns {module:engine/model/position~Position} position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] Element inside which cursor should be placed to\n * continue conversion. When element is not defined it means that there was no split.\n */\n\n/**\n * Returns all the split parts of given `element` that were created during upcasting through using {@link #splitToAllowedParent}.\n * It enables you to easily track those elements and continue processing them after they are split during their children conversion.\n *\n *\t\t<paragraph>Foo<image />bar<image />baz</paragraph> ->\n *\t\t<paragraph>Foo</paragraph><image /><paragraph>bar</paragraph><image /><paragraph>baz</paragraph>\n *\n * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),\n * sorted in the order of their creation (the original element is the first one).\n *\n * If given `element` was not split, an array with single element is returned.\n *\n * Example of a usage in a converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( myElement, modelCursor );\n *\n *\t\tconst splitParts = conversionApi.getSplitParts( myElement );\n *\t\tconst lastSplitPart = splitParts[ splitParts.length - 1 ];\n *\n *\t\t// Setting `data.modelRange` basing on split parts:\n *\t\tdata.modelRange = conversionApi.writer.createRange(\n *\t\t\tconversionApi.writer.createPositionBefore( myElement ),\n *\t\t\tconversionApi.writer.createPositionAfter( lastSplitPart )\n *\t\t);\n *\n *\t\t// Setting `data.modelCursor` to continue after the last split element:\n *\t\tdata.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );\n *\n * **Tip:** if you are unable to get a reference to the original element (for example because the code is split into multiple converters\n * or even classes) but it was already converted, you might want to check first element in `data.modelRange`. This is a common situation\n * if an attribute converter is separated from an element converter.\n *\n * @method #getSplitParts\n * @param {module:engine/model/element~Element} element\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\n/**\n * Stores information about what parts of processed view item are still waiting to be handled. After a piece of view item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable\n */\n\n/**\n * Custom data stored by converters for conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that `data` parameters allows you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @member {Object} #store\n */\n\n/**\n * The model's schema instance.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/model/writer~Writer} instance used to manipulate data during conversion.\n *\n * @member {module:engine/model/writer~Writer} #writer\n */\n"]},"metadata":{},"sourceType":"module"}